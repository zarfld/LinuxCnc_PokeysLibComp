component pokeys_rt "realtime module for pokeys";

description """

""";

pin in unsigned devSerial;
pin in unsigned inPulseEngineState;				// State of pulse engine - see ePoKeysPEState
pin out bit is_module = 1; //one pin is required to use halcompile)

pin out bit err;
pin out bit connected;
pin out bit connected.usb;
pin out bit connected.fusb;
pin out bit connected.udp;
pin out bit connected.net;
pin in unsigned devSerial;
pin out bit alive;

license "GPL";
author "Dewey Garrett";
option  homemod;
option  extra_setup;
;;

/* To incorporate default homing.c file from a local git src tree:
** enable #define HOMING_BASE set to the path to the current homing.c file.
** (Note: CUSTOM_HOMEMODULE precludes duplicate api symbols)
** (Edit myname as required for valid path)
*/

// #define HOMING_BASE /home/myname/linuxcnc-dev/src/emc/motion/homing.c

#define STR(s)  #s
#define XSTR(s) STR(s)

#include "motion.h"
//#include "homing.h"
#include "stdlib.h"
#include "PoKeysLib.h"

static char* serial_number = "";
RTAPI_MP_STRING(serial_number, "Device Serial Number") 

static int ConnectionType = 0;
RTAPI_MP_INT(ConnectionType, "Connection Type (1..USB, 2..UDP, 3..Network, 4..fastUSB)")

static char* IP = "0.0.0.0";
RTAPI_MP_STRING(IP, "IP Address")

static int timeout_ms = 1000;
RTAPI_MP_INT(timeout_ms, "Timeout in ms")

// EXTRA_SETUP is executed before rtapi_app_main()
EXTRA_SETUP() {
    if (serial_number != "") {
        rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: serial_number: %s\n", serial_number);
      //  devices->SerialNumber = atoi(serial_number);
    }

    if (ConnectionType != 0) {
        rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: ConnectionType: %d\n", ConnectionType);
        //	devices->ConnectionType = ConnectionType;
    }
	if (serial_number != "") {
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: serial_number: %s\n", serial_number);
		devices->SerialNumber = atoi(serial_number);
	}

	if (ConnectionType != 0) {
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: ConnectionType: %d\n", ConnectionType);
		//	devices->ConnectionType = ConnectionType;
	}

	if (IP != "0.0.0.0") {
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: IP: %s\n", IP);
		// need to convert IP to uint32_t[4]
		// splittring the string by '.' and converting to uint32_t
		uint8_t  IPaddress[4];
		char* token = strtok(IP, ".");
		int i = 0;
		while (token != NULL) {
			devices->IPaddress[i] = atoi(token);
			token = strtok(NULL, ".");
			i++;
		}
		//devices->IPaddress = (IPaddress[0] << 24) | (IPaddress[1] << 16) | (IPaddress[2] << 8) | IPaddress[3];
	}

	if (timeout_ms != 1000) {
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: timeout_ms: %d\n", timeout_ms);
		timeout_ms = timeout_ms;
	}

	//first check ConnectionType 
	uint32_t lastConectionTypeTried = 0; // 1..USB, 2..UDP, 3..Network, 4..fastUSB
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: ConnectionType: %d\n", ConnectionType);
	if (ConnectionType == 1) // USB
	{
		if (devices->SerialNumber != 0) // if serial number is set
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to device with SerialNumber: %d\n", devices->SerialNumber);
			dev = PK_ConnectToDeviceWSerial(devices->SerialNumber, timeout_ms);
			lastConectionTypeTried = 1;
		}
		else // try to find the first available device
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to find the first available device\n");
			enum_usb_dev = PK_EnumerateUSBDevices();
			if (enum_usb_dev != 0)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: enum_usb_dev: %d\n", enum_usb_dev);
				for (int i = 0; i < enum_usb_dev; i++)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: dev: %d\n", i);
					if (dev == NULL)
					{
						dev = PK_ConnectToDevice(i);
						lastConectionTypeTried = 1;
						if (dev != NULL)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: connected to device: %d\n", i);
							break;
						}
					}
				}
			}
		}
	}
	else if (ConnectionType == 2) // UDP
	{
		if (devices->SerialNumber != 0) // if serial number is set
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to UDP device with SerialNumber: %d\n", devices->SerialNumber);
			dev = PK_ConnectToDeviceWSerial_UDP(devices->SerialNumber, timeout_ms);
			lastConectionTypeTried = 2;
		}
		else// try to find the first available device
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to find the first available UDP device\n");
			sPoKeysNetworkDeviceSummary* net_devices;
			// first Network
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: SearchNetworkDevices\n");
			int32_t nDevs = PK_SearchNetworkDevices(net_devices, timeout_ms, devices->SerialNumber);
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: nDevs: %d\n", nDevs);
			if (nDevs != 0)
			{
				for (int i = 0; i < nDevs; i++)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: dev: %d\n", i);
					if (dev == NULL)
					{
						//dev = PK_ConnectToNetworkDevice(net_devices[i]);
						//pokeys.comp:947:52: error: incompatible type for argument 1 of ‘PK_ConnectToNetworkDevice’
						//pokeys.comp:947:52: note: expected ‘sPoKeysNetworkDeviceSummary *’ but argument is of type ‘sPoKeysNetworkDeviceSummary’
						dev = PK_ConnectToNetworkDevice(net_devices);
						lastConectionTypeTried = 3;
						if (dev != NULL)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: connected  device: %d\n", i);
							break;
						}
					}
				}
			}
			else
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: EnumerateNetworkDevices\n");
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: timeout_ms: %d\n", timeout_ms);
				nDevs = PK_EnumerateNetworkDevices(net_devices, timeout_ms); // does not work - it hangs here
				if (nDevs != 0)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: nDevs: %d\n", nDevs);
					enum_udp_dev = nDevs;
					dev = PK_ConnectToNetworkDevice(net_devices);
					lastConectionTypeTried = 3;
				}
			}
		}
	}
	else if (ConnectionType == 3)
	{
		if (devices->SerialNumber != 0)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to Network device with SerialNumber: %d\n", devices->SerialNumber);
			dev = PK_ConnectToDeviceWSerial(devices->SerialNumber, timeout_ms);
			lastConectionTypeTried = 3;
		}
		else // try to find the first available device
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to find the first available Network device\n");
			enum_usb_dev = PK_EnumerateUSBDevices();
			if (enum_usb_dev != 0)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: enum_usb_dev: %d\n", enum_usb_dev);
				for (int i = 0; i < enum_usb_dev; i++)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: dev: %d\n", i);
					if (dev == NULL)
					{
						dev = PK_ConnectToDevice(i);
						lastConectionTypeTried = 3;
						if (dev != NULL)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: connected to device: %d\n", i);
							break;
						}
					}
				}
			}
		}
	}
	else if (ConnectionType == 4)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: PK_EnumerateFastUSBDevices");
		/*	enum_fusb_dev = PK_EnumerateFastUSBDevices();
			if (enum_fusb_dev != 0)
			{
				for (int i = 0; i < enum_fusb_dev; i++)
				{
					if (dev == NULL)
					{
						dev = PK_ConnectToDevice(i);
						lastConectionTypeTried = 4;
						if(dev != NULL)
						{
							break;
						}
					}
				}
			}*/
	}
	else
	{
		// generic approach check all possible connections
		// first try to use the serial number and then try to use the IP address
		// if none of these is available try to search for devices
		// priorities:  Network, UDP, FastUSB, USB
		if (devices->SerialNumber != 0)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: serial number is set\n");
			//first try network
			dev = PK_ConnectToNetworkDevice(devices);
			if (dev == NULL)
			{
				// try UDP
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to UDP device with SerialNumber: %d\n", devices->SerialNumber);
				dev = PK_ConnectToDeviceWSerial_UDP(devices->SerialNumber, timeout_ms);
				lastConectionTypeTried = 2;
			}
			if (dev == NULL)
			{
				// try FastUSB/USB
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to USB device with SerialNumber: %d\n", devices->SerialNumber);
				dev = PK_ConnectToDeviceWSerial(devices->SerialNumber, timeout_ms);
				lastConectionTypeTried = 1;
			}
		}
		if (dev == NULL)
		{
			// try to enumarate (priorities:  Network, UDP, FastUSB/USB)
			sPoKeysNetworkDeviceSummary* net_devices;
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: SearchNetworkDevices with SerialNumber: %d\n", devices->SerialNumber);
			int32_t nDevs = PK_SearchNetworkDevices(net_devices, timeout_ms, devices->SerialNumber);
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: nDevs: %d\n", nDevs);
			if (nDevs != 0)
			{
				enum_udp_dev = nDevs;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to Network device with SerialNumber: %d\n", devices->SerialNumber);
				dev = PK_ConnectToNetworkDevice(net_devices);
				lastConectionTypeTried = 3;
			}
			else
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: EnumerateNetworkDevices\n");
				nDevs = PK_EnumerateNetworkDevices(net_devices, timeout_ms); // does not work - it hangs here
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: nDevs: %d\n", nDevs);
				if (nDevs != 0)
				{
					enum_udp_dev = nDevs;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to Network device\n");
					dev = PK_ConnectToNetworkDevice(net_devices);
					lastConectionTypeTried = 3;
				}
			}
			if (dev == NULL)
			{
				/*enum_fusb_dev = PK_EnumerateFastUSBDevices();
				if (enum_fusb_dev != 0)
				{
					for (int i = 0; i < enum_fusb_dev; i++)
					{
						if (dev == NULL)
						{
							dev = PK_ConnectToDevice(i);
							lastConectionTypeTried = 4;
							if(dev != NULL)
							{
								break;
							}
						}
					}
				}*/
				if (dev == NULL)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: EnumerateUSBDevices\n");
					enum_usb_dev = PK_EnumerateUSBDevices();
					if (enum_usb_dev != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: enum_usb_dev: %d\n", enum_usb_dev);
						for (int i = 0; i < enum_usb_dev; i++)
						{
							if (dev == NULL)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to USB device: %d\n", i);
								dev = PK_ConnectToDevice(i);
								lastConectionTypeTried = 1;
								if (dev != NULL)
								{
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: connected to device: %d\n", i);
									break;
								}
							}
						}
					}
				}
			}
		}
	}
	if (devices->SerialNumber != 0)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to device with SerialNumber: %d\n", devices->SerialNumber);
		dev = PK_ConnectToDeviceWSerial(devices->SerialNumber, timeout_ms);
	}
	else if (devices->IPaddress != 0)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: try to connect to device with IP: %d\n", devices->IPaddress);
		dev = PK_ConnectToNetworkDevice(devices);
	}

	if (dev != NULL)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: connected to device\n");
		if (lastConectionTypeTried == 1) // USB
		{
			connected_usb = 1;
			connected_fusb = 0;
			connected_udp = 0;
			connected_net = 0;
		}
		if (lastConectionTypeTried == 2) // UDP
		{
			connected_usb = 0;
			connected_fusb = 0;
			connected_udp = 1;
			connected_net = 0;
		}
		if (lastConectionTypeTried == 3) // Network
		{
			connected_usb = 0;
			connected_fusb = 0;
			connected_udp = 0;
			connected_net = 1;
		}
		if (lastConectionTypeTried == 4) // FastUSB
		{
			connected_usb = 0;
			connected_fusb = 1;
			connected_udp = 0;
			connected_net = 0;
		}
	}
	else
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: could not connect to device\n");
		connected_usb = 0;
		connected_fusb = 0;
		connected_udp = 0;
		connected_net = 0;
	}

}

// devSerial = extra_arg;
return 0;
}

/* channels provided by PEv2 which might be relevant:
pin out unsigned PEv2.PulseEngineState;				// State of pulse engine - see ePoKeysPEState

// Pulse engine v2 structure...
pin out unsigned PEv2.#.AxesState [8];				// Axis states (bit-mapped) - see ePK_PEAxisState
pin out unsigned PEv2.#.AxesConfig [8];				// Axis configuration - see ePK_PEv2_AxisConfig
pin in unsigned PEv2.#.AxesSwitchConfig [8];		// Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions

pin io unsigned PEv2.#.HomingSpeed [8];			// Homing speed per axis (in %)
pin io unsigned PEv2.#.HomingReturnSpeed [8];		// Homing return speed per axis (in % of the homing speed)
pin io unsigned PEv2.#.HomingAlgorithm[8];		// Homing algorithm configuration
pin io u32 PEv2.#.HomeOffsets [8];				// Home position offset
pin io unsigned PEv2.#.HomeBackOffDistance [8];		// Back-off distance after homing
*/
static emcmot_joint_t* joints;

// local per-joint data (includes hal pin data)
typedef struct {
   // local_home_state_t home_state;           // OUT pin
    bool         homing;               // OUT pin
    bool         homed;                // OUT pin
    bool         home_sw;              // IN  pin
    bool         index_enable;         // IO  pin
    bool         joint_in_sequence;
    int          pause_timer;
    double       home_offset;          // intfc, updateable
    double       home;                 // intfc, updateable
    double       home_final_vel;       // intfc
    double       home_search_vel;      // intfc
    double       home_latch_vel;       // intfc
    int          home_flags;           // intfc
    int          home_sequence;        // intfc, updateable
    bool         volatile_home;        // intfc
    bool         home_is_synchronized;
} home_local_data;

static  home_local_data H[EMCMOT_MAX_JOINTS];

// data for per-joint homing-specific hal pins:
typedef struct {
    hal_bit_t* home_sw;      // home switch input
    hal_bit_t* homing;       // joint is homing
    hal_bit_t* homed;        // joint was homed
    hal_bit_t* index_enable; // motmod sets: request reset on index
                             //        encoder clears: index arrived
 //   hal_s32_t* home_state;   // homing state machine state


    hal_u32_t* PEv2_AxesState; // State of pulse engine - see ePoKeysPEState
    hal_u32_t* PEv2_AxesCommand; // Commands to  pulse engine - see ePoKeysPECmd
    hal_u32_t* PEv2_AxesConfig; // Axis configuration - see ePK_PEv2_AxisConfig
    hal_u32_t* PEv2_AxesSwitchConfig; // Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions

    hal_u32_t* PEv2_HomingSpeed; // Homing speed per axis (in %)
    hal_u32_t* PEv2_HomingReturnSpeed; // Homing return speed per axis (in % of the homing speed)
    hal_u32_t* PEv2_HomingAlgorithm; // Homing algorithm configuration
    hal_u32_t* PEv2_HomeOffsets; // Home position offset
    hal_u32_t* PEv2_HomeBackOffDistance; // Back-off distance after homing

} one_joint_home_data_t;


typedef struct {
    one_joint_home_data_t jhd[EMCMOT_MAX_JOINTS];
} all_joints_home_data_t;

static all_joints_home_data_t* joint_home_data = 0;

static int makepins(int id, int njoints)
{
    // home_pins needed to work with configs expecting them:
    int jno, retval;
    one_joint_home_data_t* addr;

    joint_home_data = hal_malloc(sizeof(all_joints_home_data_t));
    if (joint_home_data == 0) {
        rtapi_print_msg(RTAPI_MSG_ERR, "HOMING: all_joints_home_data_t malloc failed\n");
        return -1;
    }

    retval = 0;
    for (jno = 0; jno < njoints; jno++) {
        addr = &(joint_home_data->jhd[jno]);

        retval += hal_pin_bit_newf(HAL_IN, &(addr->home_sw), id,
            "joint.%d.home-sw-in", jno);

        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homing), id,
            "joint.%d.homing", jno);

        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homed), id,
            "joint.%d.homed", jno);

    //    retval += hal_pin_s32_newf(HAL_OUT, &(addr->home_state), id,
    //        "joint.%d.home-state", jno);

        retval += hal_pin_bit_newf(HAL_IO, &(addr->index_enable), id,
            "joint.%d.index-enable", jno);

        retval += hal_pin_u32_newf(HAL_IN, &(addr->PEv2_AxesState), id,
            "joint.%d.PEv2.AxesState", jno);

        retval += hal_pin_u32_newf(HAL_OUT, &(addr->PEv2_AxesCommand), id,
            "joint.%d.PEv2.AxesCommand", jno);

        retval += hal_pin_u32_newf(HAL_IN, &(addr->PEv2_AxesConfig), id,
            "joint.%d.PEv2.AxesConfig", jno);

        retval += hal_pin_u32_newf(HAL_OUT, &(addr->PEv2_AxesSwitchConfig), id,
            "joint.%d.PEv2.AxesSwitchConfig", jno);

        retval += hal_pin_u32_newf(HAL_IO, &(addr->PEv2_HomingSpeed), id,
            "joint.%d.PEv2.HomingSpeed", jno);

        retval += hal_pin_u32_newf(HAL_IO, &(addr->PEv2_HomingReturnSpeed), id,
            "joint.%d.PEv2.HomingReturnSpeed", jno);

        retval += hal_pin_u32_newf(HAL_IO, &(addr->PEv2_HomingAlgorithm), id,
            "joint.%d.PEv2.HomingAlgorithm", jno);

        retval += hal_pin_u32_newf(HAL_IO, &(addr->PEv2_HomeOffsets), id,
            "joint.%d.PEv2.HomeOffsets", jno);

        retval += hal_pin_u32_newf(HAL_IO, &(addr->PEv2_HomeBackOffDistance), id,
            "joint.%d.PEv2.HomeBackOffDistance", jno);


    }
    return retval;
}
// All (skeleton) functions required for homing api follow:
void homeMotFunctions(void(*pSetRotaryUnlock)(int, int)
    , int (*pGetRotaryIsUnlocked)(int)
)
{
    return;
}




// one-time initialization (return 0 if ok):
int  homing_init(int id,
    double servo_period,
    int n_joints,
    int n_extrajoints,
    emcmot_joint_t* pjoints) {
    joints = pjoints;
    if (n_joints == 0) { n_joints == 8; }

    return makepins(id, n_joints);
}

// once-per-servo-period functions:
bool do_homing(void) { return 1; }//return 1 if allhomed
void read_homing_in_pins(int njoints)
{
    int jno;
    one_joint_home_data_t* addr;

    return;
}
void write_homing_out_pins(int njoints) {
    int jno;
    one_joint_home_data_t* addr;
    for (jno = 0; jno < njoints; jno++) {
        addr = &(joint_home_data->jhd[jno]);
        addr->homing = (hal_bit_t*)H[jno].homing;
        addr->homed = (hal_bit_t*)H[jno].homed;
   //     addr->home_state = (hal_s32_t *)H[jno].home_state;
        addr->index_enable = (hal_bit_t*)H[jno].index_enable;
    }
    return;
}

// responses to EMCMOT_JOINT_HOME message:
void do_home_joint(int joint_num) {
    one_joint_home_data_t* addr;
    addr = &(joint_home_data->jhd[joint_num]);
    addr->PEv2_AxesState = (hal_u32_t*)PK_PEAxisState_axHOMINGSTART;
    return; 
}


//---------------------------------------------------------------------
// QUERIES

// overall status:
bool get_allhomed() { return 1; }
bool get_homing_is_active() { return 0; }

// per-joint information:
int  get_home_sequence(int jno) { return H[jno].home_sequence; }//return s
bool get_homing(int jno) { return H[jno].homing; }
bool get_homed(int jno) { return H[jno].homed; }
bool get_index_enable(int jno) { return H[jno].index_enable; }
bool get_home_needs_unlock_first(int jno) { return 0; }
bool get_home_is_idle(int jno) { return 1; }
bool get_home_is_synchronized(int jno) { return H[jno].home_is_synchronized;}
bool get_homing_at_index_search_wait(int jno) { return 0; }

static void update_home_is_synchronized(void) {
    // invoke anytime H[*].home_sequence is altered
    int jno, jj, all_joints;
    all_joints = sizeof(H) / sizeof(H[0]);
    for (jno = 0; jno < all_joints; jno++) {
        H[jno].home_is_synchronized = 0;
        if (H[jno].home_sequence < 0) {
            // neg: sync all joints with same ABS(H[jno].home_sequence):
            for (jj = 0; jj < all_joints; jj++) {
                if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence)) {
                    H[jj].home_is_synchronized = 1;
                }
            }
        }
    }
}

// per-joint interface parameters (one-time setup)
void set_joint_homing_params(int    jno,
    double offset,
    double home,
    double home_final_vel,
    double home_search_vel,
    double home_latch_vel,
    int    home_flags,
    int    home_sequence,
    bool   volatile_home
) {
    H[jno].home_offset = offset;
    H[jno].home = home;
    H[jno].home_final_vel = home_final_vel;
    H[jno].home_search_vel = home_search_vel;
    H[jno].home_latch_vel = home_latch_vel;
    H[jno].home_flags = home_flags;
    H[jno].home_sequence = home_sequence;
    H[jno].volatile_home = volatile_home;
    update_home_is_synchronized();
    return;
}

// updateable interface params (for inihal pin changes typically):
void update_joint_homing_params(int    jno,
    double offset,
    double home,
    int    home_sequence
) {
    H[jno].home_offset = offset;
    H[jno].home = home;
    H[jno].home_sequence = home_sequence;
 //   update_home_is_synchronized();
    return;
}

//=====================================================================

// all home functions for homing api
EXPORT_SYMBOL(homeMotFunctions);

EXPORT_SYMBOL(homing_init);
EXPORT_SYMBOL(do_homing);
EXPORT_SYMBOL(get_allhomed);
EXPORT_SYMBOL(get_homed);
EXPORT_SYMBOL(get_home_is_idle);
EXPORT_SYMBOL(get_home_is_synchronized);
EXPORT_SYMBOL(get_home_needs_unlock_first);
EXPORT_SYMBOL(get_home_sequence);
EXPORT_SYMBOL(get_homing);
EXPORT_SYMBOL(get_homing_at_index_search_wait);
EXPORT_SYMBOL(get_homing_is_active);
EXPORT_SYMBOL(get_index_enable);
EXPORT_SYMBOL(read_homing_in_pins);
EXPORT_SYMBOL(do_home_joint);
EXPORT_SYMBOL(do_cancel_homing);
EXPORT_SYMBOL(set_unhomed);
EXPORT_SYMBOL(set_joint_homing_params);
EXPORT_SYMBOL(update_joint_homing_params);
EXPORT_SYMBOL(write_homing_out_pins);

#undef XSTR
#undef STR
#undef HOMING_BASE
#undef USE_HOMING_BASE
#undef CUSTOM_HOMEMODULE
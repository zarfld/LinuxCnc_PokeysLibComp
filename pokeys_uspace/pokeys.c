/* Autogenerated by /usr/bin/halcompile on Sun Dec  8 21:33:17 2024 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"
#include <unistd.h> /* UNIX standard function definitions */

// #include "<math.h>"
#include "PoKeysLib.h"
#include "PoKeysComp.h"
#include "rtapi.h"
// #include "rtapi_app.h"
#include "hal.h"
#include "stdio.h"
#include "PoKeysCompEncoders.c"
#include "PoKeysCompPoExtBus.c"
#include "PoKeysCompPoNet.c"
#include "PoKeysCompIO.c"
#include <stdlib.h>
#include "inifile.h"

static int comp_id=0;
sPoKeysDevice *dev = NULL;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:pokeys:(uSpace)PoKeys IO driver");
MODULE_INFO(linuxcnc, "pin:enum_usb_dev:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:enum_fusb_dev:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:enum_udp_dev:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:deb.out:s32:0:out::None:None");

MODULE_INFO(linuxcnc, "pin:err:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:connected:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:connected.usb:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:connected.fusb:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:connected.udp:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:connected.net:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "param:devSerial:u32:0:rw:PoKeys device serial number:None:None");
MODULE_INFO(linuxcnc, "pin:alive:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:machine_is_on:bit:0:in::None:None");


// info pins
MODULE_INFO(linuxcnc, "pin:info.PinCount:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PWMCount:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.BasicEncoderCount:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.EncodersCount:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.FastEncoders:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.UltraFastEncoders:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PWMinternalFrequency:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.AnalogInputs:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.KeyMapping:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.TriggeredKeyMapping:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.KeyRepeatDelay:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.DigitalCounters:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.JoystickButtonAxisMapping:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.JoystickAnalogToDigitalMapping:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.Macros:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.MatrixKeyboard:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.MatrixKeyboardTriggeredMapping:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.LCD:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.MatrixLED:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.ConnectionSignal:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PoExtBus:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PoNET:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.AnalogFiltering:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.InitOutputsStart:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.protI2C:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.prot1wire:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.AdditionalOptions:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.LoadStatus:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.CustomDeviceName:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PoTLog27support:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.SensorList:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.WebInterface:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.FailSafeSettings:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.JoystickHATswitch:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PulseEngine:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.PulseEnginev2:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:info.EasySensors:u32:0:out::None:None");



//rtc pins
MODULE_INFO(linuxcnc, "pin:rtc.sec:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.min:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.hour:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.dow:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.dom:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.tmp:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.doy:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.month:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.year:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.loopcount:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.lastmin:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.lastsec:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.loop_frequ:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.loop_frequ_demand:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.sec_ret:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:rtc.hal_latency:u32:0:out::None:None");




MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:Dominik Zarfl");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO

struct __comp_state
{
	

	struct __comp_state *_next;
	hal_u32_t *enum_usb_dev;
	hal_u32_t *enum_fusb_dev;
	hal_u32_t *enum_udp_dev;

	hal_s32_t *deb_out;


	hal_bit_t *err;
	hal_bit_t *connected;
	hal_bit_t *connected_usb;
	hal_bit_t *connected_fusb;
	hal_bit_t *connected_udp;
	hal_bit_t *connected_net;
	hal_bit_t *alive;
	hal_bit_t *machine_is_on;

	//info pins
	hal_u32_t *info_PinCount;
	hal_u32_t *info_PWMCount;
	hal_u32_t *info_BasicEncoderCount;
	hal_u32_t *info_EncodersCount;
	hal_u32_t *info_FastEncoders;
	hal_u32_t *info_UltraFastEncoders;
	hal_u32_t *info_PWMinternalFrequency;
	hal_u32_t *info_AnalogInputs;
	hal_u32_t *info_KeyMapping;
	hal_u32_t *info_TriggeredKeyMapping;
	hal_u32_t *info_KeyRepeatDelay;
	hal_u32_t *info_DigitalCounters;
	hal_u32_t *info_JoystickButtonAxisMapping;
	hal_u32_t *info_JoystickAnalogToDigitalMapping;
	hal_u32_t *info_Macros;
	hal_u32_t *info_MatrixKeyboard;
	hal_u32_t *info_MatrixKeyboardTriggeredMapping;
	hal_u32_t *info_LCD;
	hal_u32_t *info_MatrixLED;
	hal_u32_t *info_ConnectionSignal;
	hal_u32_t *info_PoExtBus;
	hal_u32_t *info_PoNET;
	hal_u32_t *info_AnalogFiltering;
	hal_u32_t *info_InitOutputsStart;
	hal_u32_t *info_protI2C;
	hal_u32_t *info_prot1wire;
	hal_u32_t *info_AdditionalOptions;
	hal_u32_t *info_LoadStatus;
	hal_u32_t *info_CustomDeviceName;
	hal_u32_t *info_PoTLog27support;
	hal_u32_t *info_SensorList;
	hal_u32_t *info_WebInterface;
	hal_u32_t *info_FailSafeSettings;
	hal_u32_t *info_JoystickHATswitch;
	hal_u32_t *info_PulseEngine;
	hal_u32_t *info_PulseEnginev2;
	hal_u32_t *info_EasySensors;

	all_PoExtBus_data_t *PoExtBus_data ;

	// PEv2 pins
	hal_s32_t *PEv2_deb_out;
	hal_s32_t *PEv2_deb_estop;
	hal_s32_t *PEv2_deb_axxisout[8];
	hal_bit_t *PEv2_deb_ishoming[8];
	hal_bit_t *PEv2_deb_inposition[8];
	hal_bit_t *PEv2_deb_PosMode[8];
	hal_bit_t *PEv2_deb_PosModeAct[8];
	hal_s32_t *PEv2_deb_velmode_count[8];
	hal_s32_t *PEv2_deb_posmode_count[8];
	hal_bit_t *PEv2_deb_doMove[8];
	hal_float_t *PEv2_deb_RefSpeed[8];
	hal_float_t *PEv2_deb_RefPos[8];
	hal_float_t *PEv2_deb_RefPosSpeed[8];
	hal_u32_t *PEv2_nrOfAxes;
	hal_u32_t *PEv2_maxPulseFrequency;
	hal_u32_t *PEv2_bufferDepth;
	hal_u32_t *PEv2_slotTiming;
	hal_bit_t *PEv2_params_ApplyIniSettings;
	hal_u32_t *PEv2_AxesState[8];
	hal_u32_t *PEv2_AxesCommand[8];
	hal_u32_t *PEv2_AxesConfig[8];
	hal_u32_t *PEv2_SoftLimitMaximum[8];
	hal_u32_t *PEv2_SoftLimitMinimum[8];
	hal_u32_t *PEv2_HomingSpeed[8];
	hal_u32_t *PEv2_HomingReturnSpeed[8];
	hal_u32_t *PEv2_HomeOffsets[8];
	hal_u32_t *PEv2_ProbePosition[8];
	hal_u32_t *PEv2_ProbeMaxPosition[8];
	hal_s32_t *PEv2_CurrentPosition[8];
	hal_s32_t *PEv2_PositionSetup[8];
	hal_u32_t *PEv2_ReferencePositionSpeed[8];
	hal_float_t *PEv2_MaxSpeed[8];
	hal_float_t *PEv2_MaxAcceleration[8];
	hal_float_t *PEv2_MaxDecceleration[8];
	
	hal_float_t *PEv2_joint_vel_cmd[8];
	hal_float_t *PEv2_joint_pos_cmd[8];
	hal_float_t *PEv2_joint_pos_fb[8];
	hal_bit_t *PEv2_joint_out_home[8];
	hal_bit_t *PEv2_joint_in_position[8];
	hal_bit_t *PEv2_joint_kb_jog_active[8];
	hal_bit_t *PEv2_joint_wheel_jog_active[8];

	hal_s32_t *PEv2_stepgen_TYPE[8];
	hal_float_t *PEv2_stepgen_HOME[8];
	hal_float_t *PEv2_stepgen_STEPGEN_MAXVEL[8];
	hal_float_t *PEv2_stepgen_STEPGEN_MAXACCEL[8];
	hal_float_t *PEv2_params_Feedback_Encoder_Id[8];
	hal_float_t *PEv2_stepgen_DEADBAND[8];
	hal_float_t *PEv2_stepgen_MAX_OUTPUT[8];
	hal_float_t *PEv2_stepgen_ENCODER_SCALE[8];
	hal_float_t *PEv2_stepgen_STEP_SCALE[8];
	hal_float_t *PEv2_stepgen_MIN_LIMIT[8];
	hal_float_t *PEv2_stepgen_MAX_LIMIT[8];
	hal_float_t *PEv2_stepgen_HOME_OFFSET[8];
	hal_float_t *PEv2_stepgen_HOME_SEARCH_VEL[8];
	hal_float_t *PEv2_stepgen_HOME_LATCH_VEL[8];
	hal_float_t *PEv2_stepgen_HOME_FINAL_VEL[8];
	hal_s32_t *PEv2_stepgen_HOME_IGNORE_LIMITS[8];
	hal_u32_t *PEv2_MPGjogMultiplier[8];
	hal_u32_t *PEv2_MPGjogEncoder[8];
	hal_u32_t *PEv2_MPGjogDivider[8];

	hal_u32_t *PEv2_HomeBackOffDistance[8];
	hal_bit_t *PEv2_digin_Error_in[8];
	hal_bit_t *PEv2_digin_Error_in_not[8];
	hal_u32_t *PEv2_MiscInputStatus;

	hal_u32_t *PEv2_BacklashWidth[8];
	hal_u32_t *PEv2_BacklashRegister[8];
	hal_u32_t *PEv2_BacklashAcceleration[8];
	hal_s32_t PEv2_home_sequence[8];
	hal_s32_t PEv2_AxisEnabled[8];
	hal_s32_t PEv2_AxisInverted[8];
	hal_s32_t PEv2_AxisInternalPlanner[8];
	hal_s32_t PEv2_AxisPositionMode[8];
	hal_s32_t PEv2_AxisInvertedHome[8];
	hal_s32_t PEv2_AxisSoftLimitEnabled[8];
	hal_s32_t PEv2_AxisEnabledMasked[8];
	hal_u32_t PEv2_AxesSwitchConfig[8];

	hal_u32_t PEv2_HomingAlgorithm[8];
	hal_bit_t PEv2_HomeAlg_OnHome_Stop[8];
	hal_bit_t PEv2_HomeAlg_OnHome_ArmEncoder[8];
	hal_bit_t PEv2_HomeAlg_OnHome_RevDirection[8];
	hal_bit_t PEv2_HomeAlg_OnHome_ReducedSpeed[8];
	hal_bit_t PEv2_HomeAlg_OutHome_Stop[8];
	hal_bit_t PEv2_HomeAlg_OutHome_ArmEncoder[8];
	hal_bit_t PEv2_HomeAlg_OutHome_RevDirection[8];
	hal_bit_t PEv2_HomeAlg_OutHome_ReducedSpeed[8];

	hal_u32_t PEv2_digin_Home_Offset[8];
	hal_u32_t PEv2_digin_SoftLimit_PosMin[8];
	hal_u32_t PEv2_digin_SoftLimit_PosMax[8];
	hal_bit_t PEv2_digin_LimitN_Enabled[8];
	hal_bit_t PEv2_digin_LimitP_Enabled[8];
	hal_bit_t PEv2_digin_Home_Enabled[8];
	hal_bit_t PEv2_digin_Home_OnLimitN[8];
	hal_bit_t PEv2_digin_Home_OnLimitP[8];
	hal_bit_t PEv2_digin_LimitN_invert[8];
	hal_bit_t PEv2_digin_LimitP_invert[8];
	hal_bit_t PEv2_digin_Home_invert[8];
	hal_u32_t PEv2_digin_LimitN_Pin[8];
	hal_u32_t PEv2_digin_LimitN_Filter[8];
	hal_u32_t PEv2_digin_LimitP_Pin[8];
	hal_u32_t PEv2_digin_LimitP_Filter[8];
	hal_u32_t PEv2_digin_Home_Pin[8];
	hal_u32_t PEv2_digin_Home_Filter[8];
	hal_u32_t PEv2_digout_AxisEnable_Pin[8];
	hal_bit_t PEv2_digout_AxisEnable_invert[8];
	hal_bit_t *PEv2_digin_Misc_in[8];
	hal_bit_t *PEv2_digin_Misc_in_not[8];
	hal_bit_t *PEv2_digin_Probe_in[8];
	hal_bit_t *PEv2_digin_Probe_in_not[8];
	hal_u32_t *PEv2_digin_SoftLimit_in[8];
	hal_bit_t *PEv2_digout_AxisEnabled_out[8];
	hal_bit_t *PEv2_digin_AxisEnabled_in[8];
	hal_bit_t *PEv2_digout_LimitOverride_out[8];
	hal_bit_t *PEv2_digin_LimitN_in[8];
	hal_bit_t *PEv2_digin_LimitN_in_not[8];
	hal_bit_t *PEv2_digin_LimitN_DedicatedInput[8];
	hal_bit_t *PEv2_digin_LimitP_in[8];
	hal_bit_t *PEv2_digin_LimitP_in_not[8];
	hal_bit_t *PEv2_digin_LimitP_DedicatedInput[8];
	hal_bit_t *PEv2_digin_Home_in[8];
	hal_bit_t *PEv2_digin_Home_in_not[8];
	hal_bit_t *PEv2_digin_Home_DedicatedInput[8];
	hal_bit_t *PEv2_digout_AxisEnable_out[8];

	hal_u32_t *PEv2_PulseEngineEnabled;
	hal_u32_t *PEv2_PulseGeneratorType;
	hal_bit_t *PEv2_PG_swap_stepdir;
	hal_bit_t *PEv2_PG_extended_io;
	hal_u32_t *PEv2_ChargePumpEnabled;
	hal_u32_t *PEv2_PulseEngineActivated;
	hal_u32_t *PEv2_PulseEngineState;

	hal_u32_t *PEv2_LimitOverride;
	hal_u32_t *PEv2_LimitOverrideSetup;

	hal_bit_t *PEv2_digin_Probed_in;
	hal_bit_t *PEv2_digin_Emergency_in;
	hal_bit_t *PEv2_digin_Emergency_in_not;
	hal_bit_t *PEv2_digout_Emergency_out;
	hal_bit_t *PEv2_digout_ExternalRelay_out[4];
	hal_bit_t *PEv2_digout_ExternalOC_out[4];
	hal_u32_t PEv2_digin_Emergency_Pin;
	hal_u32_t PEv2_digin_Emergency_invert;
	hal_u32_t PEv2_digout_Emergency_Pin;
	hal_u32_t PEv2_digin_Probe_Pin;
	hal_u32_t PEv2_digin_Probe_invert;

	hal_u32_t *PEv2_AxisEnabledMask;
	hal_u32_t *PEv2_AxisEnabledStatesMask;

	hal_u32_t *PEv2_ExternalRelayOutputs;
	hal_u32_t *PEv2_ExternalOCOutputs;

	hal_u32_t *PEv2_HomingStartMaskSetup;
	hal_u32_t *PEv2_ProbeStartMaskSetup;
	hal_u32_t *PEv2_ProbeStatus;
	hal_float_t *PEv2_ProbeSpeed;
	hal_u32_t *PEv2_BacklashCompensationEnabled;

	hal_u32_t *rtc_sec;
	hal_u32_t *rtc_min;
	hal_u32_t *rtc_hour;
	hal_u32_t *rtc_dow;
	hal_u32_t *rtc_dom;
	hal_u32_t *rtc_tmp;
	hal_u32_t *rtc_doy;
	hal_u32_t *rtc_month;
	hal_u32_t *rtc_year;
	hal_u32_t *rtc_loopcount;
	hal_u32_t *rtc_lastmin;
	hal_u32_t *rtc_lastsec;
	hal_u32_t *rtc_loop_frequ;
	hal_u32_t *rtc_loop_frequ_demand;
	hal_u32_t *rtc_sec_ret;
	hal_u32_t *rtc_hal_latency;

	all_IO_data_t *IO_data;

	all_encoder_data_t *encoder_data;
	all_PoNET_data_t *poNET_data;
	
	hal_u32_t devSerial;

};

struct __comp_state *__comp_first_inst = 0, *__comp_last_inst = 0;

static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
uint32_t device_id = 0;
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg)
{
	int r = 0;
	int j = 0;
	int sz = sizeof(struct __comp_state) + __comp_get_data_size();
	struct __comp_state *inst = hal_malloc(sz);
	memset(inst, 0, sz);
	r = extra_setup(inst, prefix, extra_arg);
	if (r != 0)
		return r;

	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: export %s\n", __FILE__, __FUNCTION__, prefix);
		
	//PoExtBus Pins
	//PKPoExtBus_export_pins(char *prefix, long extra_arg, int id, int njoints, all_PoExtBus_data_t *poExtBus_data)
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PoExtBus pins\n");
	r = PKPoExtBus_export_pins( prefix, extra_arg, comp_id, 10, inst->PoExtBus_data);
	if (r != 0)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PKPoExtBus_export_pins failed\n");
		return r;
	}
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PoExtBus pins done \n");


		
	
	// Encoder pins
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Encoder pins\n");
	r = PKEncoder_export_pins(prefix, extra_arg,comp_id,29,*&(inst->encoder_data));
	if (r != 0)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PKEncoder_export_pins failed\n");
		return r;
	}
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Encoder pins done \n");
	
	// params
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Encoder params\n");
	r=PKEncoder_export_params(prefix, extra_arg,comp_id,29);
	if (r != 0)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PKEncoder_export_params failed\n");
		return r;
	}
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: Encoder params done \n");
	
	//int PKPoNet_export_pins(char *prefix, long extra_arg, int id, int njoints, all_PoNET_data_t *poNET_data, sPoKeysDevice *dev)
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PoNET pins\n");
	r=PKPoNet_export_pins(prefix,extra_arg,comp_id,16,inst->poNET_data ,dev);
	if (r != 0)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PKPoNet_export_pins failed\n");
		return r;
	}
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PoNET pins done \n");

	// PoKeys IO pins
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: IO pins\n");
	r=PKIO_export_pins(prefix,extra_arg,comp_id,inst->IO_data, dev);
	if (r != 0)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: PKIO_export_pins failed\n");
		return r;
	}
	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: IO pins done \n");



	r = hal_pin_u32_newf(HAL_OUT, &(inst->enum_usb_dev), comp_id,
						 "%s.enum-usb-dev", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->enum_fusb_dev), comp_id,
						 "%s.enum-fusb-dev", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->enum_udp_dev), comp_id,
						 "%s.enum-udp-dev", prefix);
	if (r != 0)
		return r;
	r = hal_pin_s32_newf(HAL_OUT, &(inst->deb_out), comp_id,
						 "%s.deb.out", prefix);
	if (r != 0)
		return r;

	//PulseEngine Pins
	r = hal_pin_s32_newf(HAL_OUT, &(inst->PEv2_deb_out), comp_id,
						 "%s.PEv2.deb.out", prefix);
	if (r != 0)
		return r;
	r = hal_pin_s32_newf(HAL_OUT, &(inst->PEv2_deb_estop), comp_id,
						 "%s.PEv2.deb.estop", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_s32_newf(HAL_OUT, &(inst->PEv2_deb_axxisout[j]), comp_id,
							 "%s.PEv2.%01d.deb.axxisout", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_deb_ishoming[j]), comp_id,
							 "%s.PEv2.%01d.deb.ishoming", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_deb_inposition[j]), comp_id,
							 "%s.PEv2.%01d.deb.inposition", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_deb_PosMode[j]), comp_id,
							 "%s.PEv2.%01d.deb.PosMode", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_deb_PosModeAct[j]), comp_id,
							 "%s.PEv2.%01d.deb.PosModeAct", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_s32_newf(HAL_OUT, &(inst->PEv2_deb_velmode_count[j]), comp_id,
							 "%s.PEv2.%01d.deb.velmode-count", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_s32_newf(HAL_OUT, &(inst->PEv2_deb_posmode_count[j]), comp_id,
							 "%s.PEv2.%01d.deb.posmode-count", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_deb_doMove[j]), comp_id,
							 "%s.PEv2.%01d.deb.doMove", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_float_newf(HAL_OUT, &(inst->PEv2_deb_RefSpeed[j]), comp_id,
							   "%s.PEv2.%01d.deb.RefSpeed", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_float_newf(HAL_OUT, &(inst->PEv2_deb_RefPos[j]), comp_id,
							   "%s.PEv2.%01d.deb.RefPos", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_float_newf(HAL_OUT, &(inst->PEv2_deb_RefPosSpeed[j]), comp_id,
							   "%s.PEv2.%01d.deb.RefPosSpeed", prefix, j);
		if (r != 0)
			return r;
	}

	
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->err), comp_id,
						 "%s.err", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->connected), comp_id,
						 "%s.connected", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->connected_usb), comp_id,
						 "%s.connected.usb", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->connected_fusb), comp_id,
						 "%s.connected.fusb", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->connected_udp), comp_id,
						 "%s.connected.udp", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->connected_net), comp_id,
						 "%s.connected.net", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->alive), comp_id,
						 "%s.alive", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_IN, &(inst->machine_is_on), comp_id,
						 "%s.machine-is-on", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PinCount), comp_id,
						 "%s.info.PinCount", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PWMCount), comp_id,
						 "%s.info.PWMCount", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_BasicEncoderCount), comp_id,
						 "%s.info.BasicEncoderCount", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_EncodersCount), comp_id,
						 "%s.info.EncodersCount", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_FastEncoders), comp_id,
						 "%s.info.FastEncoders", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_UltraFastEncoders), comp_id,
						 "%s.info.UltraFastEncoders", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PWMinternalFrequency), comp_id,
						 "%s.info.PWMinternalFrequency", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_AnalogInputs), comp_id,
						 "%s.info.AnalogInputs", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_KeyMapping), comp_id,
						 "%s.info.KeyMapping", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_TriggeredKeyMapping), comp_id,
						 "%s.info.TriggeredKeyMapping", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_KeyRepeatDelay), comp_id,
						 "%s.info.KeyRepeatDelay", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_DigitalCounters), comp_id,
						 "%s.info.DigitalCounters", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_JoystickButtonAxisMapping), comp_id,
						 "%s.info.JoystickButtonAxisMapping", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_JoystickAnalogToDigitalMapping), comp_id,
						 "%s.info.JoystickAnalogToDigitalMapping", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_Macros), comp_id,
						 "%s.info.Macros", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_MatrixKeyboard), comp_id,
						 "%s.info.MatrixKeyboard", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_MatrixKeyboardTriggeredMapping), comp_id,
						 "%s.info.MatrixKeyboardTriggeredMapping", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_LCD), comp_id,
						 "%s.info.LCD", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_MatrixLED), comp_id,
						 "%s.info.MatrixLED", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_ConnectionSignal), comp_id,
						 "%s.info.ConnectionSignal", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PoExtBus), comp_id,
						 "%s.info.PoExtBus", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PoNET), comp_id,
						 "%s.info.PoNET", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_AnalogFiltering), comp_id,
						 "%s.info.AnalogFiltering", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_InitOutputsStart), comp_id,
						 "%s.info.InitOutputsStart", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_protI2C), comp_id,
						 "%s.info.protI2C", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_prot1wire), comp_id,
						 "%s.info.prot1wire", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_AdditionalOptions), comp_id,
						 "%s.info.AdditionalOptions", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_LoadStatus), comp_id,
						 "%s.info.LoadStatus", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_CustomDeviceName), comp_id,
						 "%s.info.CustomDeviceName", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PoTLog27support), comp_id,
						 "%s.info.PoTLog27support", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_SensorList), comp_id,
						 "%s.info.SensorList", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_WebInterface), comp_id,
						 "%s.info.WebInterface", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_FailSafeSettings), comp_id,
						 "%s.info.FailSafeSettings", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_JoystickHATswitch), comp_id,
						 "%s.info.JoystickHATswitch", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PulseEngine), comp_id,
						 "%s.info.PulseEngine", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_PulseEnginev2), comp_id,
						 "%s.info.PulseEnginev2", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->info_EasySensors), comp_id,
						 "%s.info.EasySensors", prefix);
	if (r != 0)
		return r;



	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_nrOfAxes), comp_id,
						 "%s.PEv2.nrOfAxes", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_maxPulseFrequency), comp_id,
						 "%s.PEv2.maxPulseFrequency", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_bufferDepth), comp_id,
						 "%s.PEv2.bufferDepth", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_slotTiming), comp_id,
						 "%s.PEv2.slotTiming", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_IO, &(inst->PEv2_params_ApplyIniSettings), comp_id,
						 "%s.PEv2.params.ApplyIniSettings", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_AxesState[j]), comp_id,
							 "%s.PEv2.%01d.AxesState", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_u32_newf(HAL_IN, &(inst->PEv2_AxesCommand[j]), comp_id,
							 "%s.PEv2.%01d.AxesCommand", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_AxesConfig[j]), comp_id,
							 "%s.PEv2.%01d.AxesConfig", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_SoftLimitMaximum[j]), comp_id,
							 "%s.PEv2.%01d.SoftLimitMaximum", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_SoftLimitMinimum[j]), comp_id,
							 "%s.PEv2.%01d.SoftLimitMinimum", prefix, j);
		if (r != 0)
			return r;

		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_HomingSpeed[j]), comp_id,
							 "%s.PEv2.%01d.HomingSpeed", prefix, j);
		if (r != 0)
			return r;
	}

	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_HomingReturnSpeed[j]), comp_id,
							 "%s.PEv2.%01d.HomingReturnSpeed", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_HomeOffsets[j]), comp_id,
							 "%s.PEv2.%01d.HomeOffsets", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_ProbePosition[j]), comp_id,
							 "%s.PEv2.%01d.ProbePosition", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_ProbeMaxPosition[j]), comp_id,
							 "%s.PEv2.%01d.ProbeMaxPosition", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_s32_newf(HAL_OUT, &(inst->PEv2_CurrentPosition[j]), comp_id,
							 "%s.PEv2.%01d.CurrentPosition", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_s32_newf(HAL_IO, &(inst->PEv2_PositionSetup[j]), comp_id,
							 "%s.PEv2.%01d.PositionSetup", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_ReferencePositionSpeed[j]), comp_id,
							 "%s.PEv2.%01d.ReferencePositionSpeed", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IO, &(inst->PEv2_MaxSpeed[j]), comp_id,
							   "%s.PEv2.%01d.MaxSpeed", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IO, &(inst->PEv2_MaxAcceleration[j]), comp_id,
							   "%s.PEv2.%01d.MaxAcceleration", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IO, &(inst->PEv2_MaxDecceleration[j]), comp_id,
							   "%s.PEv2.%01d.MaxDecceleration", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_joint_vel_cmd[j]), comp_id,
							   "%s.PEv2.%01d.joint-vel-cmd", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_joint_pos_cmd[j]), comp_id,
							   "%s.PEv2.%01d.joint-pos-cmd", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_OUT, &(inst->PEv2_joint_pos_fb[j]), comp_id,
							   "%s.PEv2.%01d.joint-pos-fb", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_joint_out_home[j]), comp_id,
							 "%s.PEv2.%01d.joint-out-home", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_joint_in_position[j]), comp_id,
							 "%s.PEv2.%01d.joint-in-position", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_joint_kb_jog_active[j]), comp_id,
							 "%s.PEv2.%01d.joint-kb-jog-active", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_joint_wheel_jog_active[j]), comp_id,
							 "%s.PEv2.%01d.joint-wheel-jog-active", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_s32_newf(HAL_IN, &(inst->PEv2_stepgen_TYPE[j]), comp_id,
							 "%s.PEv2.%01d.stepgen.TYPE", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_HOME[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.HOME", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_STEPGEN_MAXVEL[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.STEPGEN-MAXVEL", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_STEPGEN_MAXACCEL[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.STEPGEN-MAXACCEL", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_params_Feedback_Encoder_Id[j]), comp_id,
							   "%s.PEv2.%01d.params.Feedback-Encoder-Id", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_DEADBAND[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.DEADBAND", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_MAX_OUTPUT[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.MAX-OUTPUT", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_ENCODER_SCALE[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.ENCODER-SCALE", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_STEP_SCALE[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.STEP-SCALE", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_MIN_LIMIT[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.MIN-LIMIT", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_MAX_LIMIT[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.MAX-LIMIT", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_HOME_OFFSET[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.HOME-OFFSET", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_HOME_SEARCH_VEL[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.HOME-SEARCH-VEL", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_HOME_LATCH_VEL[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.HOME-LATCH-VEL", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_float_newf(HAL_IN, &(inst->PEv2_stepgen_HOME_FINAL_VEL[j]), comp_id,
							   "%s.PEv2.%01d.stepgen.HOME-FINAL-VEL", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_s32_newf(HAL_IN, &(inst->PEv2_stepgen_HOME_IGNORE_LIMITS[j]), comp_id,
							 "%s.PEv2.%01d.stepgen.HOME-IGNORE-LIMITS", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_MPGjogMultiplier[j]), comp_id,
							 "%s.PEv2.%01d.MPGjogMultiplier", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_MPGjogEncoder[j]), comp_id,
							 "%s.PEv2.%01d.MPGjogEncoder", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_MPGjogDivider[j]), comp_id,
							 "%s.PEv2.%01d.MPGjogDivider", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_LimitN_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.LimitN.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_LimitN_in_not[j]), comp_id,
							 "%s.PEv2.%01d.digin.LimitN.in-not", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_LimitN_DedicatedInput[j]), comp_id,
							 "%s.PEv2.%01d.digin.LimitN.DedicatedInput", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_LimitP_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.LimitP.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_LimitP_in_not[j]), comp_id,
							 "%s.PEv2.%01d.digin.LimitP.in-not", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_LimitP_DedicatedInput[j]), comp_id,
							 "%s.PEv2.%01d.digin.LimitP.DedicatedInput", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Home_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.Home.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Home_in_not[j]), comp_id,
							 "%s.PEv2.%01d.digin.Home.in-not", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Home_DedicatedInput[j]), comp_id,
							 "%s.PEv2.%01d.digin.Home.DedicatedInput", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_digout_AxisEnable_out[j]), comp_id,
							 "%s.PEv2.%01d.digout.AxisEnable.out", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_HomeBackOffDistance[j]), comp_id,
							 "%s.PEv2.%01d.HomeBackOffDistance", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_PulseEngineEnabled), comp_id,
						 "%s.PEv2.PulseEngineEnabled", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_PulseGeneratorType), comp_id,
						 "%s.PEv2.PulseGeneratorType", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_PG_swap_stepdir), comp_id,
						 "%s.PEv2.PG-swap-stepdir", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_IO, &(inst->PEv2_PG_extended_io), comp_id,
						 "%s.PEv2.PG-extended-io", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_ChargePumpEnabled), comp_id,
						 "%s.PEv2.ChargePumpEnabled", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_PulseEngineActivated), comp_id,
						 "%s.PEv2.PulseEngineActivated", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_PulseEngineState), comp_id,
						 "%s.PEv2.PulseEngineState", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Error_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.Error.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Error_in_not[j]), comp_id,
							 "%s.PEv2.%01d.digin.Error.in-not", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_MiscInputStatus), comp_id,
						 "%s.PEv2.MiscInputStatus", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Misc_in[j]), comp_id,
							 "%s.PEv2.digin.Misc-%01d.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Misc_in_not[j]), comp_id,
							 "%s.PEv2.digin.Misc-%01d.in-not", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_LimitOverride), comp_id,
						 "%s.PEv2.LimitOverride", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_LimitOverrideSetup), comp_id,
						 "%s.PEv2.LimitOverrideSetup", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Probed_in), comp_id,
						 "%s.PEv2.digin.Probed.in", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Probe_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.Probe.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Probe_in_not[j]), comp_id,
							 "%s.PEv2.%01d.digin.Probe.in-not", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Emergency_in), comp_id,
						 "%s.PEv2.digin.Emergency.in", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_Emergency_in_not), comp_id,
						 "%s.PEv2.digin.Emergency.in-not", prefix);
	if (r != 0)
		return r;
	r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_digout_Emergency_out), comp_id,
						 "%s.PEv2.digout.Emergency.out", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_digin_SoftLimit_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.SoftLimit.in", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_AxisEnabledMask), comp_id,
						 "%s.PEv2.AxisEnabledMask", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_AxisEnabledStatesMask), comp_id,
						 "%s.PEv2.AxisEnabledStatesMask", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_digout_AxisEnabled_out[j]), comp_id,
							 "%s.PEv2.%01d.digout.AxisEnabled.out", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digin_AxisEnabled_in[j]), comp_id,
							 "%s.PEv2.%01d.digin.AxisEnabled.in", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_bit_newf(HAL_OUT, &(inst->PEv2_digout_LimitOverride_out[j]), comp_id,
							 "%s.PEv2.%01d.digout.LimitOverride.out", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_ExternalRelayOutputs), comp_id,
						 "%s.PEv2.ExternalRelayOutputs", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_ExternalOCOutputs), comp_id,
						 "%s.PEv2.ExternalOCOutputs", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (4); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_digout_ExternalRelay_out[j]), comp_id,
							 "%s.PEv2.digout.ExternalRelay-%01d.out", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (4); j++)
	{
		r = hal_pin_bit_newf(HAL_IN, &(inst->PEv2_digout_ExternalOC_out[j]), comp_id,
							 "%s.PEv2.digout.ExternalOC-%01d.out", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_HomingStartMaskSetup), comp_id,
						 "%s.PEv2.HomingStartMaskSetup", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_ProbeStartMaskSetup), comp_id,
						 "%s.PEv2.ProbeStartMaskSetup", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->PEv2_ProbeStatus), comp_id,
						 "%s.PEv2.ProbeStatus", prefix);
	if (r != 0)
		return r;
	r = hal_pin_float_newf(HAL_IO, &(inst->PEv2_ProbeSpeed), comp_id,
						   "%s.PEv2.ProbeSpeed", prefix);
	if (r != 0)
		return r;
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_BacklashWidth[j]), comp_id,
							 "%s.PEv2.%01d.BacklashWidth", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_BacklashRegister[j]), comp_id,
							 "%s.PEv2.%01d.BacklashRegister", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_BacklashAcceleration[j]), comp_id,
							 "%s.PEv2.%01d.BacklashAcceleration", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_pin_u32_newf(HAL_IO, &(inst->PEv2_BacklashCompensationEnabled), comp_id,
						 "%s.PEv2.BacklashCompensationEnabled", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_sec), comp_id,
						 "%s.rtc.sec", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_min), comp_id,
						 "%s.rtc.min", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_hour), comp_id,
						 "%s.rtc.hour", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_dow), comp_id,
						 "%s.rtc.dow", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_dom), comp_id,
						 "%s.rtc.dom", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_tmp), comp_id,
						 "%s.rtc.tmp", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_doy), comp_id,
						 "%s.rtc.doy", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_month), comp_id,
						 "%s.rtc.month", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_year), comp_id,
						 "%s.rtc.year", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_loopcount), comp_id,
						 "%s.rtc.loopcount", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_lastmin), comp_id,
						 "%s.rtc.lastmin", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_lastsec), comp_id,
						 "%s.rtc.lastsec", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_loop_frequ), comp_id,
						 "%s.rtc.loop-frequ", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IN, &(inst->rtc_loop_frequ_demand), comp_id,
						 "%s.rtc.loop-frequ-demand", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_IN, &(inst->rtc_sec_ret), comp_id,
						 "%s.rtc.sec-ret", prefix);
	if (r != 0)
		return r;
	r = hal_pin_u32_newf(HAL_OUT, &(inst->rtc_hal_latency), comp_id,
						 "%s.rtc.hal-latency", prefix);
	if (r != 0)
		return r;



	

	


	r = hal_param_u32_newf(HAL_RW, &(inst->devSerial), comp_id,
						   "%s.devSerial", prefix);
	if (r != 0)
		return r;

	
	for (j = 0; j < (8); j++)
	{
		r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_home_sequence[j]), comp_id,
							   "%s.PEv2.%01d.home-sequence", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisEnabled[j]), comp_id,
							   "%s.PEv2.%01d.AxisEnabled", prefix, j);
		if (r != 0)
			return r;

				r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisInverted[j]), comp_id,
							   "%s.PEv2.%01d.AxisInverted", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisInternalPlanner[j]), comp_id,
							   "%s.PEv2.%01d.AxisInternalPlanner", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisPositionMode[j]), comp_id,
							   "%s.PEv2.%01d.AxisPositionMode", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisInvertedHome[j]), comp_id,
							   "%s.PEv2.%01d.AxisInvertedHome", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisSoftLimitEnabled[j]), comp_id,
							   "%s.PEv2.%01d.AxisSoftLimitEnabled", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_s32_newf(HAL_RW, &(inst->PEv2_AxisEnabledMasked[j]), comp_id,
							   "%s.PEv2.%01d.AxisEnabledMasked", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_SoftLimit_PosMin[j]), comp_id,
							   "%s.PEv2.%01d.digin.SoftLimit.PosMin", prefix, j);
		if (r != 0)
			return r;

					r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_SoftLimit_PosMax[j]), comp_id,
							   "%s.PEv2.%01d.digin.SoftLimit.PosMax", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_HomingAlgorithm[j]), comp_id,
							   "%s.PEv2.%01d.HomingAlgorithm", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OnHome_Stop[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OnHome.Stop", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OnHome_ArmEncoder[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OnHome.ArmEncoder", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OnHome_RevDirection[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OnHome.RevDirection", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OnHome_ReducedSpeed[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OnHome.ReducedSpeed", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OutHome_Stop[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OutHome.Stop", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OutHome_ArmEncoder[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OutHome.ArmEncoder", prefix, j);
		if (r != 0)
			return r;
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OutHome_RevDirection[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OutHome.RevDirection", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_HomeAlg_OutHome_ReducedSpeed[j]), comp_id,
							   "%s.PEv2.%01d.HomeAlg.OutHome.ReducedSpeed", prefix, j);
		if (r != 0)
			return r;
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Home_Offset[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.Offset", prefix, j);
		if (r != 0)
			return r;
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_AxesSwitchConfig[j]), comp_id,
							   "%s.PEv2.%01d.AxesSwitchConfig", prefix, j);
		if (r != 0)
			return r;
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_LimitN_Enabled[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitN.Enabled", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_LimitP_Enabled[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitP.Enabled", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_Home_Enabled[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.Enabled", prefix, j);
		if (r != 0)
			return r;
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_Home_OnLimitN[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.OnLimitN", prefix, j);
		if (r != 0)
			return r;

		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_Home_OnLimitP[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.OnLimitP", prefix, j);
		if (r != 0)
			return r;
	}


	for (j = 0; j < (8); j++)
	{
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_LimitN_invert[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitN.invert", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_LimitP_invert[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitP.invert", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digin_Home_invert[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.invert", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_LimitN_Pin[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitN.Pin", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_LimitN_Filter[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitN.Filter", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_LimitP_Pin[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitP.Pin", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_LimitP_Filter[j]), comp_id,
							   "%s.PEv2.%01d.digin.LimitP.Filter", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Home_Pin[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.Pin", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Home_Filter[j]), comp_id,
							   "%s.PEv2.%01d.digin.Home.Filter", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digout_AxisEnable_Pin[j]), comp_id,
							   "%s.PEv2.%01d.digout.AxisEnable.Pin", prefix, j);
		if (r != 0)
			return r;
	}
	for (j = 0; j < (8); j++)
	{
		r = hal_param_bit_newf(HAL_RW, &(inst->PEv2_digout_AxisEnable_invert[j]), comp_id,
							   "%s.PEv2.%01d.digout.AxisEnable.invert", prefix, j);
		if (r != 0)
			return r;
	}
	r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Emergency_Pin), comp_id,
						   "%s.PEv2.digin.Emergency.Pin", prefix);
	if (r != 0)
		return r;
	r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Emergency_invert), comp_id,
						   "%s.PEv2.digin.Emergency.invert", prefix);
	if (r != 0)
		return r;
	r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digout_Emergency_Pin), comp_id,
						   "%s.PEv2.digout.Emergency.Pin", prefix);
	if (r != 0)
		return r;
	r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Probe_Pin), comp_id,
						   "%s.PEv2.digin.Probe.Pin", prefix);
	if (r != 0)
		return r;
	r = hal_param_u32_newf(HAL_RW, &(inst->PEv2_digin_Probe_invert), comp_id,
						   "%s.PEv2.digin.Probe.invert", prefix);
	if (r != 0)
		return r;
	
	if (__comp_last_inst)
		__comp_last_inst->_next = inst;
	__comp_last_inst = inst;
	if (!__comp_first_inst)
		__comp_first_inst = inst;
	return 0;
}
static int default_count = 1, count = 0;
char *names[16] = {
	0,
};
int rtapi_app_main(void)
{
	int r = 0;
	int i;
	comp_id = hal_init("pokeys");
	if (comp_id < 0)
		return comp_id;
	if (count && names[0])
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "count= and names= are mutually exclusive\n");
		return -EINVAL;
	}
	if (!count && !names[0])
		count = default_count;
	if (count)
	{
		for (i = 0; i < count; i++)
		{
			char buf[HAL_NAME_LEN + 1];
			rtapi_snprintf(buf, sizeof(buf), "pokeys.%d", i);
			r = export(buf, i);
			if (r != 0)
				break;
		}
	}
	else
	{
		int max_names = sizeof(names) / sizeof(names[0]);
		for (i = 0; (i < max_names) && names[i]; i++)
		{
			if (strlen(names[i]) < 1)
			{
				rtapi_print_msg(RTAPI_MSG_ERR, "names[%d] is invalid (empty string)\n", i);
				r = -EINVAL;
				break;
			}
			r = export(names[i], i);
			if (r != 0)
				break;
		}
	}
	if (r)
	{
		hal_exit(comp_id);
	}
	else
	{
		hal_ready(comp_id);
	}
	return r;
}

void rtapi_app_exit(void)
{
	hal_exit(comp_id);
}
static void user_mainloop(void);

int __comp_parse_count(int *argc, char **argv)
{
	int i;
	for (i = 0; i < *argc; i++)
	{
		if (strncmp(argv[i], "count=", 6) == 0)
		{
			errno = 0;
			count = strtoul(&argv[i][6], NULL, 0);
			for (; i + 1 < *argc; i++)
			{
				argv[i] = argv[i + 1];
			}
			argv[i] = NULL;
			(*argc)--;
			if (errno == 0)
			{
				return 1;
			}
		}
	}
	return 0;
}

int __comp_parse_names(int *argc, char **argv)
{
	int i;
	for (i = 0; i < *argc; i++)
	{
		if (strncmp(argv[i], "names=", 6) == 0)
		{
			char *p = &argv[i][6];
			int j;
			for (; i + 1 < *argc; i++)
			{
				argv[i] = argv[i + 1];
			}
			argv[i] = NULL;
			(*argc)--;
			for (j = 0; j < 16; j++)
			{
				names[j] = strtok(p, ",");
				p = NULL;
				if (names[j] == NULL)
				{
					return 1;
				}
			}
			return 1;
		}
	}
	return 0;
}

int argc = 0;
char **argv = 0;
int main(int argc_, char **argv_)
{
	argc = argc_;
	argv = argv_;
	int found_count, found_names;
	found_count = __comp_parse_count(&argc, argv);
	found_names = __comp_parse_names(&argc, argv);
	if (found_count && found_names)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "count= and names= are mutually exclusive\n");
		return 1;
	}

	if (rtapi_app_main() < 0)
		return 1;
	user_mainloop();
	rtapi_app_exit();
	return 0;
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef enum_usb_dev
#define enum_usb_dev (*__comp_inst->enum_usb_dev)
#undef enum_fusb_dev
#define enum_fusb_dev (*__comp_inst->enum_fusb_dev)
#undef enum_udp_dev
#define enum_udp_dev (*__comp_inst->enum_udp_dev)
#undef deb_out
#define deb_out (*__comp_inst->deb_out)
#undef PEv2_deb_out
#define PEv2_deb_out (*__comp_inst->PEv2_deb_out)
#undef PEv2_deb_estop
#define PEv2_deb_estop (*__comp_inst->PEv2_deb_estop)
#undef PEv2_deb_axxisout
#define PEv2_deb_axxisout(i) (*(__comp_inst->PEv2_deb_axxisout[i]))
#undef PEv2_deb_ishoming
#define PEv2_deb_ishoming(i) (*(__comp_inst->PEv2_deb_ishoming[i]))
#undef PEv2_deb_inposition
#define PEv2_deb_inposition(i) (*(__comp_inst->PEv2_deb_inposition[i]))
#undef PEv2_deb_PosMode
#define PEv2_deb_PosMode(i) (*(__comp_inst->PEv2_deb_PosMode[i]))
#undef PEv2_deb_PosModeAct
#define PEv2_deb_PosModeAct(i) (*(__comp_inst->PEv2_deb_PosModeAct[i]))
#undef PEv2_deb_velmode_count
#define PEv2_deb_velmode_count(i) (*(__comp_inst->PEv2_deb_velmode_count[i]))
#undef PEv2_deb_posmode_count
#define PEv2_deb_posmode_count(i) (*(__comp_inst->PEv2_deb_posmode_count[i]))
#undef PEv2_deb_doMove
#define PEv2_deb_doMove(i) (*(__comp_inst->PEv2_deb_doMove[i]))
#undef PEv2_deb_RefSpeed
#define PEv2_deb_RefSpeed(i) (*(__comp_inst->PEv2_deb_RefSpeed[i]))
#undef PEv2_deb_RefPos
#define PEv2_deb_RefPos(i) (*(__comp_inst->PEv2_deb_RefPos[i]))
#undef PEv2_deb_RefPosSpeed
#define PEv2_deb_RefPosSpeed(i) (*(__comp_inst->PEv2_deb_RefPosSpeed[i]))
#undef adcout_deb_out
#define adcout_deb_out(i) (*(__comp_inst->adcout_deb_out[i]))
#undef adcout_deb_setval
#define adcout_deb_setval(i) (*(__comp_inst->adcout_deb_setval[i]))
#undef adcout_deb_outv
#define adcout_deb_outv (*__comp_inst->adcout_deb_outv)
#undef err
#define err (*__comp_inst->err)
#undef connected
#define connected (*__comp_inst->connected)
#undef connected_usb
#define connected_usb (*__comp_inst->connected_usb)
#undef connected_fusb
#define connected_fusb (*__comp_inst->connected_fusb)
#undef connected_udp
#define connected_udp (*__comp_inst->connected_udp)
#undef connected_net
#define connected_net (*__comp_inst->connected_net)
#undef alive
#define alive (*__comp_inst->alive)
#undef machine_is_on
#define machine_is_on (0 + *__comp_inst->machine_is_on)
#undef info_PinCount
#define info_PinCount (*__comp_inst->info_PinCount)
#undef info_PWMCount
#define info_PWMCount (*__comp_inst->info_PWMCount)
#undef info_BasicEncoderCount
#define info_BasicEncoderCount (*__comp_inst->info_BasicEncoderCount)
#undef info_EncodersCount
#define info_EncodersCount (*__comp_inst->info_EncodersCount)
#undef info_FastEncoders
#define info_FastEncoders (*__comp_inst->info_FastEncoders)
#undef info_UltraFastEncoders
#define info_UltraFastEncoders (*__comp_inst->info_UltraFastEncoders)
#undef info_PWMinternalFrequency
#define info_PWMinternalFrequency (*__comp_inst->info_PWMinternalFrequency)
#undef info_AnalogInputs
#define info_AnalogInputs (*__comp_inst->info_AnalogInputs)
#undef info_KeyMapping
#define info_KeyMapping (*__comp_inst->info_KeyMapping)
#undef info_TriggeredKeyMapping
#define info_TriggeredKeyMapping (*__comp_inst->info_TriggeredKeyMapping)
#undef info_KeyRepeatDelay
#define info_KeyRepeatDelay (*__comp_inst->info_KeyRepeatDelay)
#undef info_DigitalCounters
#define info_DigitalCounters (*__comp_inst->info_DigitalCounters)
#undef info_JoystickButtonAxisMapping
#define info_JoystickButtonAxisMapping (*__comp_inst->info_JoystickButtonAxisMapping)
#undef info_JoystickAnalogToDigitalMapping
#define info_JoystickAnalogToDigitalMapping (*__comp_inst->info_JoystickAnalogToDigitalMapping)
#undef info_Macros
#define info_Macros (*__comp_inst->info_Macros)
#undef info_MatrixKeyboard
#define info_MatrixKeyboard (*__comp_inst->info_MatrixKeyboard)
#undef info_MatrixKeyboardTriggeredMapping
#define info_MatrixKeyboardTriggeredMapping (*__comp_inst->info_MatrixKeyboardTriggeredMapping)
#undef info_LCD
#define info_LCD (*__comp_inst->info_LCD)
#undef info_MatrixLED
#define info_MatrixLED (*__comp_inst->info_MatrixLED)
#undef info_ConnectionSignal
#define info_ConnectionSignal (*__comp_inst->info_ConnectionSignal)
#undef info_PoExtBus
#define info_PoExtBus (*__comp_inst->info_PoExtBus)
#undef info_PoNET
#define info_PoNET (*__comp_inst->info_PoNET)
#undef info_AnalogFiltering
#define info_AnalogFiltering (*__comp_inst->info_AnalogFiltering)
#undef info_InitOutputsStart
#define info_InitOutputsStart (*__comp_inst->info_InitOutputsStart)
#undef info_protI2C
#define info_protI2C (*__comp_inst->info_protI2C)
#undef info_prot1wire
#define info_prot1wire (*__comp_inst->info_prot1wire)
#undef info_AdditionalOptions
#define info_AdditionalOptions (*__comp_inst->info_AdditionalOptions)
#undef info_LoadStatus
#define info_LoadStatus (*__comp_inst->info_LoadStatus)
#undef info_CustomDeviceName
#define info_CustomDeviceName (*__comp_inst->info_CustomDeviceName)
#undef info_PoTLog27support
#define info_PoTLog27support (*__comp_inst->info_PoTLog27support)
#undef info_SensorList
#define info_SensorList (*__comp_inst->info_SensorList)
#undef info_WebInterface
#define info_WebInterface (*__comp_inst->info_WebInterface)
#undef info_FailSafeSettings
#define info_FailSafeSettings (*__comp_inst->info_FailSafeSettings)
#undef info_JoystickHATswitch
#define info_JoystickHATswitch (*__comp_inst->info_JoystickHATswitch)
#undef info_PulseEngine
#define info_PulseEngine (*__comp_inst->info_PulseEngine)
#undef info_PulseEnginev2
#define info_PulseEnginev2 (*__comp_inst->info_PulseEnginev2)
#undef info_EasySensors
#define info_EasySensors (*__comp_inst->info_EasySensors)

#undef PEv2_nrOfAxes
#define PEv2_nrOfAxes (*__comp_inst->PEv2_nrOfAxes)
#undef PEv2_maxPulseFrequency
#define PEv2_maxPulseFrequency (*__comp_inst->PEv2_maxPulseFrequency)
#undef PEv2_bufferDepth
#define PEv2_bufferDepth (*__comp_inst->PEv2_bufferDepth)
#undef PEv2_slotTiming
#define PEv2_slotTiming (*__comp_inst->PEv2_slotTiming)
#undef PEv2_params_ApplyIniSettings
#define PEv2_params_ApplyIniSettings (*__comp_inst->PEv2_params_ApplyIniSettings)
#undef PEv2_AxesState
#define PEv2_AxesState(i) (*(__comp_inst->PEv2_AxesState[i]))
#undef PEv2_AxesCommand
#define PEv2_AxesCommand(i) (0 + *(__comp_inst->PEv2_AxesCommand[i]))
#undef PEv2_AxesConfig
#define PEv2_AxesConfig(i) (*(__comp_inst->PEv2_AxesConfig[i]))
#undef PEv2_SoftLimitMaximum
#define PEv2_SoftLimitMaximum(i) (*(__comp_inst->PEv2_SoftLimitMaximum[i]))
#undef PEv2_SoftLimitMinimum
#define PEv2_SoftLimitMinimum(i) (*(__comp_inst->PEv2_SoftLimitMinimum[i]))
#undef PEv2_HomingSpeed
#define PEv2_HomingSpeed(i) (*(__comp_inst->PEv2_HomingSpeed[i]))
#undef PEv2_HomingReturnSpeed
#define PEv2_HomingReturnSpeed(i) (*(__comp_inst->PEv2_HomingReturnSpeed[i]))
#undef PEv2_HomeOffsets
#define PEv2_HomeOffsets(i) (*(__comp_inst->PEv2_HomeOffsets[i]))
#undef PEv2_ProbePosition
#define PEv2_ProbePosition(i) (*(__comp_inst->PEv2_ProbePosition[i]))
#undef PEv2_ProbeMaxPosition
#define PEv2_ProbeMaxPosition(i) (*(__comp_inst->PEv2_ProbeMaxPosition[i]))
#undef PEv2_CurrentPosition
#define PEv2_CurrentPosition(i) (*(__comp_inst->PEv2_CurrentPosition[i]))
#undef PEv2_PositionSetup
#define PEv2_PositionSetup(i) (*(__comp_inst->PEv2_PositionSetup[i]))
#undef PEv2_ReferencePositionSpeed
#define PEv2_ReferencePositionSpeed(i) (*(__comp_inst->PEv2_ReferencePositionSpeed[i]))
#undef PEv2_MaxSpeed
#define PEv2_MaxSpeed(i) (*(__comp_inst->PEv2_MaxSpeed[i]))
#undef PEv2_MaxAcceleration
#define PEv2_MaxAcceleration(i) (*(__comp_inst->PEv2_MaxAcceleration[i]))
#undef PEv2_MaxDecceleration
#define PEv2_MaxDecceleration(i) (*(__comp_inst->PEv2_MaxDecceleration[i]))
#undef PEv2_joint_vel_cmd
#define PEv2_joint_vel_cmd(i) (0 + *(__comp_inst->PEv2_joint_vel_cmd[i]))
#undef PEv2_joint_pos_cmd
#define PEv2_joint_pos_cmd(i) (0 + *(__comp_inst->PEv2_joint_pos_cmd[i]))
#undef PEv2_joint_pos_fb
#define PEv2_joint_pos_fb(i) (*(__comp_inst->PEv2_joint_pos_fb[i]))
#undef PEv2_joint_out_home
#define PEv2_joint_out_home(i) (0 + *(__comp_inst->PEv2_joint_out_home[i]))
#undef PEv2_joint_in_position
#define PEv2_joint_in_position(i) (0 + *(__comp_inst->PEv2_joint_in_position[i]))
#undef PEv2_joint_kb_jog_active
#define PEv2_joint_kb_jog_active(i) (0 + *(__comp_inst->PEv2_joint_kb_jog_active[i]))
#undef PEv2_joint_wheel_jog_active
#define PEv2_joint_wheel_jog_active(i) (0 + *(__comp_inst->PEv2_joint_wheel_jog_active[i]))
#undef PEv2_stepgen_TYPE
#define PEv2_stepgen_TYPE(i) (0 + *(__comp_inst->PEv2_stepgen_TYPE[i]))
#undef PEv2_stepgen_HOME
#define PEv2_stepgen_HOME(i) (0 + *(__comp_inst->PEv2_stepgen_HOME[i]))
#undef PEv2_stepgen_STEPGEN_MAXVEL
#define PEv2_stepgen_STEPGEN_MAXVEL(i) (0 + *(__comp_inst->PEv2_stepgen_STEPGEN_MAXVEL[i]))
#undef PEv2_stepgen_STEPGEN_MAXACCEL
#define PEv2_stepgen_STEPGEN_MAXACCEL(i) (0 + *(__comp_inst->PEv2_stepgen_STEPGEN_MAXACCEL[i]))
#undef PEv2_params_Feedback_Encoder_Id
#define PEv2_params_Feedback_Encoder_Id(i) (0 + *(__comp_inst->PEv2_params_Feedback_Encoder_Id[i]))
#undef PEv2_stepgen_DEADBAND
#define PEv2_stepgen_DEADBAND(i) (0 + *(__comp_inst->PEv2_stepgen_DEADBAND[i]))
#undef PEv2_stepgen_MAX_OUTPUT
#define PEv2_stepgen_MAX_OUTPUT(i) (0 + *(__comp_inst->PEv2_stepgen_MAX_OUTPUT[i]))
#undef PEv2_stepgen_ENCODER_SCALE
#define PEv2_stepgen_ENCODER_SCALE(i) (0 + *(__comp_inst->PEv2_stepgen_ENCODER_SCALE[i]))
#undef PEv2_stepgen_STEP_SCALE
#define PEv2_stepgen_STEP_SCALE(i) (0 + *(__comp_inst->PEv2_stepgen_STEP_SCALE[i]))
#undef PEv2_stepgen_MIN_LIMIT
#define PEv2_stepgen_MIN_LIMIT(i) (0 + *(__comp_inst->PEv2_stepgen_MIN_LIMIT[i]))
#undef PEv2_stepgen_MAX_LIMIT
#define PEv2_stepgen_MAX_LIMIT(i) (0 + *(__comp_inst->PEv2_stepgen_MAX_LIMIT[i]))
#undef PEv2_stepgen_HOME_OFFSET
#define PEv2_stepgen_HOME_OFFSET(i) (0 + *(__comp_inst->PEv2_stepgen_HOME_OFFSET[i]))
#undef PEv2_stepgen_HOME_SEARCH_VEL
#define PEv2_stepgen_HOME_SEARCH_VEL(i) (0 + *(__comp_inst->PEv2_stepgen_HOME_SEARCH_VEL[i]))
#undef PEv2_stepgen_HOME_LATCH_VEL
#define PEv2_stepgen_HOME_LATCH_VEL(i) (0 + *(__comp_inst->PEv2_stepgen_HOME_LATCH_VEL[i]))
#undef PEv2_stepgen_HOME_FINAL_VEL
#define PEv2_stepgen_HOME_FINAL_VEL(i) (0 + *(__comp_inst->PEv2_stepgen_HOME_FINAL_VEL[i]))
#undef PEv2_stepgen_HOME_IGNORE_LIMITS
#define PEv2_stepgen_HOME_IGNORE_LIMITS(i) (0 + *(__comp_inst->PEv2_stepgen_HOME_IGNORE_LIMITS[i]))
#undef PEv2_MPGjogMultiplier
#define PEv2_MPGjogMultiplier(i) (*(__comp_inst->PEv2_MPGjogMultiplier[i]))
#undef PEv2_MPGjogEncoder
#define PEv2_MPGjogEncoder(i) (*(__comp_inst->PEv2_MPGjogEncoder[i]))
#undef PEv2_MPGjogDivider
#define PEv2_MPGjogDivider(i) (*(__comp_inst->PEv2_MPGjogDivider[i]))
#undef PEv2_digin_LimitN_in
#define PEv2_digin_LimitN_in(i) (*(__comp_inst->PEv2_digin_LimitN_in[i]))
#undef PEv2_digin_LimitN_in_not
#define PEv2_digin_LimitN_in_not(i) (*(__comp_inst->PEv2_digin_LimitN_in_not[i]))
#undef PEv2_digin_LimitN_DedicatedInput
#define PEv2_digin_LimitN_DedicatedInput(i) (*(__comp_inst->PEv2_digin_LimitN_DedicatedInput[i]))
#undef PEv2_digin_LimitP_in
#define PEv2_digin_LimitP_in(i) (*(__comp_inst->PEv2_digin_LimitP_in[i]))
#undef PEv2_digin_LimitP_in_not
#define PEv2_digin_LimitP_in_not(i) (*(__comp_inst->PEv2_digin_LimitP_in_not[i]))
#undef PEv2_digin_LimitP_DedicatedInput
#define PEv2_digin_LimitP_DedicatedInput(i) (*(__comp_inst->PEv2_digin_LimitP_DedicatedInput[i]))
#undef PEv2_digin_Home_in
#define PEv2_digin_Home_in(i) (*(__comp_inst->PEv2_digin_Home_in[i]))
#undef PEv2_digin_Home_in_not
#define PEv2_digin_Home_in_not(i) (*(__comp_inst->PEv2_digin_Home_in_not[i]))
#undef PEv2_digin_Home_DedicatedInput
#define PEv2_digin_Home_DedicatedInput(i) (*(__comp_inst->PEv2_digin_Home_DedicatedInput[i]))
#undef PEv2_digout_AxisEnable_out
#define PEv2_digout_AxisEnable_out(i) (0 + *(__comp_inst->PEv2_digout_AxisEnable_out[i]))
#undef PEv2_HomeBackOffDistance
#define PEv2_HomeBackOffDistance(i) (*(__comp_inst->PEv2_HomeBackOffDistance[i]))
#undef PEv2_PulseEngineEnabled
#define PEv2_PulseEngineEnabled (*__comp_inst->PEv2_PulseEngineEnabled)
#undef PEv2_PulseGeneratorType
#define PEv2_PulseGeneratorType (*__comp_inst->PEv2_PulseGeneratorType)
#undef PEv2_PG_swap_stepdir
#define PEv2_PG_swap_stepdir (0 + *__comp_inst->PEv2_PG_swap_stepdir)
#undef PEv2_PG_extended_io
#define PEv2_PG_extended_io (*__comp_inst->PEv2_PG_extended_io)
#undef PEv2_ChargePumpEnabled
#define PEv2_ChargePumpEnabled (*__comp_inst->PEv2_ChargePumpEnabled)
#undef PEv2_PulseEngineActivated
#define PEv2_PulseEngineActivated (*__comp_inst->PEv2_PulseEngineActivated)
#undef PEv2_PulseEngineState
#define PEv2_PulseEngineState (*__comp_inst->PEv2_PulseEngineState)
#undef PEv2_digin_Error_in
#define PEv2_digin_Error_in(i) (*(__comp_inst->PEv2_digin_Error_in[i]))
#undef PEv2_digin_Error_in_not
#define PEv2_digin_Error_in_not(i) (*(__comp_inst->PEv2_digin_Error_in_not[i]))
#undef PEv2_MiscInputStatus
#define PEv2_MiscInputStatus (*__comp_inst->PEv2_MiscInputStatus)
#undef PEv2_digin_Misc_in
#define PEv2_digin_Misc_in(i) (*(__comp_inst->PEv2_digin_Misc_in[i]))
#undef PEv2_digin_Misc_in_not
#define PEv2_digin_Misc_in_not(i) (*(__comp_inst->PEv2_digin_Misc_in_not[i]))
#undef PEv2_LimitOverride
#define PEv2_LimitOverride (*__comp_inst->PEv2_LimitOverride)
#undef PEv2_LimitOverrideSetup
#define PEv2_LimitOverrideSetup (*__comp_inst->PEv2_LimitOverrideSetup)
#undef PEv2_digin_Probed_in
#define PEv2_digin_Probed_in (*__comp_inst->PEv2_digin_Probed_in)
#undef PEv2_digin_Probe_in
#define PEv2_digin_Probe_in(i) (*(__comp_inst->PEv2_digin_Probe_in[i]))
#undef PEv2_digin_Probe_in_not
#define PEv2_digin_Probe_in_not(i) (*(__comp_inst->PEv2_digin_Probe_in_not[i]))
#undef PEv2_digin_Emergency_in
#define PEv2_digin_Emergency_in (*__comp_inst->PEv2_digin_Emergency_in)
#undef PEv2_digin_Emergency_in_not
#define PEv2_digin_Emergency_in_not (*__comp_inst->PEv2_digin_Emergency_in_not)
#undef PEv2_digout_Emergency_out
#define PEv2_digout_Emergency_out (0 + *__comp_inst->PEv2_digout_Emergency_out)
#undef PEv2_digin_SoftLimit_in
#define PEv2_digin_SoftLimit_in(i) (*(__comp_inst->PEv2_digin_SoftLimit_in[i]))
#undef PEv2_AxisEnabledMask
#define PEv2_AxisEnabledMask (*__comp_inst->PEv2_AxisEnabledMask)
#undef PEv2_AxisEnabledStatesMask
#define PEv2_AxisEnabledStatesMask (*__comp_inst->PEv2_AxisEnabledStatesMask)
#undef PEv2_digout_AxisEnabled_out
#define PEv2_digout_AxisEnabled_out(i) (0 + *(__comp_inst->PEv2_digout_AxisEnabled_out[i]))
#undef PEv2_digin_AxisEnabled_in
#define PEv2_digin_AxisEnabled_in(i) (*(__comp_inst->PEv2_digin_AxisEnabled_in[i]))
#undef PEv2_digout_LimitOverride_out
#define PEv2_digout_LimitOverride_out(i) (*(__comp_inst->PEv2_digout_LimitOverride_out[i]))
#undef PEv2_ExternalRelayOutputs
#define PEv2_ExternalRelayOutputs (*__comp_inst->PEv2_ExternalRelayOutputs)
#undef PEv2_ExternalOCOutputs
#define PEv2_ExternalOCOutputs (*__comp_inst->PEv2_ExternalOCOutputs)
#undef PEv2_digout_ExternalRelay_out
#define PEv2_digout_ExternalRelay_out(i) (0 + *(__comp_inst->PEv2_digout_ExternalRelay_out[i]))
#undef PEv2_digout_ExternalOC_out
#define PEv2_digout_ExternalOC_out(i) (0 + *(__comp_inst->PEv2_digout_ExternalOC_out[i]))
#undef PEv2_HomingStartMaskSetup
#define PEv2_HomingStartMaskSetup (*__comp_inst->PEv2_HomingStartMaskSetup)
#undef PEv2_ProbeStartMaskSetup
#define PEv2_ProbeStartMaskSetup (*__comp_inst->PEv2_ProbeStartMaskSetup)
#undef PEv2_ProbeStatus
#define PEv2_ProbeStatus (*__comp_inst->PEv2_ProbeStatus)
#undef PEv2_ProbeSpeed
#define PEv2_ProbeSpeed (*__comp_inst->PEv2_ProbeSpeed)
#undef PEv2_BacklashWidth
#define PEv2_BacklashWidth(i) (*(__comp_inst->PEv2_BacklashWidth[i]))
#undef PEv2_BacklashRegister
#define PEv2_BacklashRegister(i) (*(__comp_inst->PEv2_BacklashRegister[i]))
#undef PEv2_BacklashAcceleration
#define PEv2_BacklashAcceleration(i) (*(__comp_inst->PEv2_BacklashAcceleration[i]))
#undef PEv2_BacklashCompensationEnabled
#define PEv2_BacklashCompensationEnabled (*__comp_inst->PEv2_BacklashCompensationEnabled)
#undef rtc_sec
#define rtc_sec (*__comp_inst->rtc_sec)
#undef rtc_min
#define rtc_min (*__comp_inst->rtc_min)
#undef rtc_hour
#define rtc_hour (*__comp_inst->rtc_hour)
#undef rtc_dow
#define rtc_dow (*__comp_inst->rtc_dow)
#undef rtc_dom
#define rtc_dom (*__comp_inst->rtc_dom)
#undef rtc_tmp
#define rtc_tmp (*__comp_inst->rtc_tmp)
#undef rtc_doy
#define rtc_doy (*__comp_inst->rtc_doy)
#undef rtc_month
#define rtc_month (*__comp_inst->rtc_month)
#undef rtc_year
#define rtc_year (*__comp_inst->rtc_year)
#undef rtc_loopcount
#define rtc_loopcount (*__comp_inst->rtc_loopcount)
#undef rtc_lastmin
#define rtc_lastmin (*__comp_inst->rtc_lastmin)
#undef rtc_lastsec
#define rtc_lastsec (*__comp_inst->rtc_lastsec)
#undef rtc_loop_frequ
#define rtc_loop_frequ (*__comp_inst->rtc_loop_frequ)
#undef rtc_loop_frequ_demand
#define rtc_loop_frequ_demand (0 + *__comp_inst->rtc_loop_frequ_demand)
#undef rtc_sec_ret
#define rtc_sec_ret (0 + *__comp_inst->rtc_sec_ret)
#undef rtc_hal_latency
#define rtc_hal_latency (*__comp_inst->rtc_hal_latency)
#undef counter_value
#define counter_value(i) (*(__comp_inst->counter_value[i]))
#undef adcin_value_raw
#define adcin_value_raw(i) (*(__comp_inst->adcin_value_raw[i]))
#undef adcin_value
#define adcin_value(i) (*(__comp_inst->adcin_value[i]))
#undef digin_in
#define digin_in(i) (*(__comp_inst->digin_in[i]))
#undef digin_in_not
#define digin_in_not(i) (*(__comp_inst->digin_in_not[i]))
#undef digout_out
#define digout_out(i) (0 + *(__comp_inst->digout_out[i]))
#undef encoder_count
//#define encoder_count(i) (*(__comp_inst->encoder_count[i]))
//#undef encoder_position
//#define encoder_position(i) (*(__comp_inst->encoder_position[i]))
//#undef encoder_velocity
//#define encoder_velocity(i) (*(__comp_inst->encoder_velocity[i]))
//#undef encoder_reset
//#define encoder_reset(i) (0 + *(__comp_inst->encoder_reset[i]))
//#undef encoder_index_enable
//#define encoder_index_enable(i) (0 + *(__comp_inst->encoder_index_enable[i]))
#undef adcout_value
#define adcout_value(i) (0 + *(__comp_inst->adcout_value[i]))
#undef adcout_enable
#define adcout_enable(i) (0 + *(__comp_inst->adcout_enable[i]))

#undef devSerial
#define devSerial (__comp_inst->devSerial)

#undef PEv2_home_sequence
#define PEv2_home_sequence(i) (__comp_inst->PEv2_home_sequence[i])
#undef PEv2_AxisEnabled
#define PEv2_AxisEnabled(i) (__comp_inst->PEv2_AxisEnabled[i])
#undef PEv2_AxisInverted
#define PEv2_AxisInverted(i) (__comp_inst->PEv2_AxisInverted[i])
#undef PEv2_AxisInternalPlanner
#define PEv2_AxisInternalPlanner(i) (__comp_inst->PEv2_AxisInternalPlanner[i])
#undef PEv2_AxisPositionMode
#define PEv2_AxisPositionMode(i) (__comp_inst->PEv2_AxisPositionMode[i])
#undef PEv2_AxisInvertedHome
#define PEv2_AxisInvertedHome(i) (__comp_inst->PEv2_AxisInvertedHome[i])
#undef PEv2_AxisSoftLimitEnabled
#define PEv2_AxisSoftLimitEnabled(i) (__comp_inst->PEv2_AxisSoftLimitEnabled[i])
#undef PEv2_AxisEnabledMasked
#define PEv2_AxisEnabledMasked(i) (__comp_inst->PEv2_AxisEnabledMasked[i])
#undef PEv2_digin_SoftLimit_PosMin
#define PEv2_digin_SoftLimit_PosMin(i) (__comp_inst->PEv2_digin_SoftLimit_PosMin[i])
#undef PEv2_digin_SoftLimit_PosMax
#define PEv2_digin_SoftLimit_PosMax(i) (__comp_inst->PEv2_digin_SoftLimit_PosMax[i])
#undef PEv2_HomingAlgorithm
#define PEv2_HomingAlgorithm(i) (__comp_inst->PEv2_HomingAlgorithm[i])
#undef PEv2_HomeAlg_OnHome_Stop
#define PEv2_HomeAlg_OnHome_Stop(i) (__comp_inst->PEv2_HomeAlg_OnHome_Stop[i])
#undef PEv2_HomeAlg_OnHome_ArmEncoder
#define PEv2_HomeAlg_OnHome_ArmEncoder(i) (__comp_inst->PEv2_HomeAlg_OnHome_ArmEncoder[i])
#undef PEv2_HomeAlg_OnHome_RevDirection
#define PEv2_HomeAlg_OnHome_RevDirection(i) (__comp_inst->PEv2_HomeAlg_OnHome_RevDirection[i])
#undef PEv2_HomeAlg_OnHome_ReducedSpeed
#define PEv2_HomeAlg_OnHome_ReducedSpeed(i) (__comp_inst->PEv2_HomeAlg_OnHome_ReducedSpeed[i])
#undef PEv2_HomeAlg_OutHome_Stop
#define PEv2_HomeAlg_OutHome_Stop(i) (__comp_inst->PEv2_HomeAlg_OutHome_Stop[i])
#undef PEv2_HomeAlg_OutHome_ArmEncoder
#define PEv2_HomeAlg_OutHome_ArmEncoder(i) (__comp_inst->PEv2_HomeAlg_OutHome_ArmEncoder[i])
#undef PEv2_HomeAlg_OutHome_RevDirection
#define PEv2_HomeAlg_OutHome_RevDirection(i) (__comp_inst->PEv2_HomeAlg_OutHome_RevDirection[i])
#undef PEv2_HomeAlg_OutHome_ReducedSpeed
#define PEv2_HomeAlg_OutHome_ReducedSpeed(i) (__comp_inst->PEv2_HomeAlg_OutHome_ReducedSpeed[i])
#undef PEv2_digin_Home_Offset
#define PEv2_digin_Home_Offset(i) (__comp_inst->PEv2_digin_Home_Offset[i])
#undef PEv2_AxesSwitchConfig
#define PEv2_AxesSwitchConfig(i) (__comp_inst->PEv2_AxesSwitchConfig[i])
#undef PEv2_digin_LimitN_Enabled
#define PEv2_digin_LimitN_Enabled(i) (__comp_inst->PEv2_digin_LimitN_Enabled[i])
#undef PEv2_digin_LimitP_Enabled
#define PEv2_digin_LimitP_Enabled(i) (__comp_inst->PEv2_digin_LimitP_Enabled[i])
#undef PEv2_digin_Home_Enabled
#define PEv2_digin_Home_Enabled(i) (__comp_inst->PEv2_digin_Home_Enabled[i])
#undef PEv2_digin_Home_OnLimitN
#define PEv2_digin_Home_OnLimitN(i) (__comp_inst->PEv2_digin_Home_OnLimitN[i])
#undef PEv2_digin_Home_OnLimitP
#define PEv2_digin_Home_OnLimitP(i) (__comp_inst->PEv2_digin_Home_OnLimitP[i])
#undef PEv2_digin_LimitN_invert
#define PEv2_digin_LimitN_invert(i) (__comp_inst->PEv2_digin_LimitN_invert[i])
#undef PEv2_digin_LimitP_invert
#define PEv2_digin_LimitP_invert(i) (__comp_inst->PEv2_digin_LimitP_invert[i])
#undef PEv2_digin_Home_invert
#define PEv2_digin_Home_invert(i) (__comp_inst->PEv2_digin_Home_invert[i])
#undef PEv2_digin_LimitN_Pin
#define PEv2_digin_LimitN_Pin(i) (__comp_inst->PEv2_digin_LimitN_Pin[i])
#undef PEv2_digin_LimitN_Filter
#define PEv2_digin_LimitN_Filter(i) (__comp_inst->PEv2_digin_LimitN_Filter[i])
#undef PEv2_digin_LimitP_Pin
#define PEv2_digin_LimitP_Pin(i) (__comp_inst->PEv2_digin_LimitP_Pin[i])
#undef PEv2_digin_LimitP_Filter
#define PEv2_digin_LimitP_Filter(i) (__comp_inst->PEv2_digin_LimitP_Filter[i])
#undef PEv2_digin_Home_Pin
#define PEv2_digin_Home_Pin(i) (__comp_inst->PEv2_digin_Home_Pin[i])
#undef PEv2_digin_Home_Filter
#define PEv2_digin_Home_Filter(i) (__comp_inst->PEv2_digin_Home_Filter[i])
#undef PEv2_digout_AxisEnable_Pin
#define PEv2_digout_AxisEnable_Pin(i) (__comp_inst->PEv2_digout_AxisEnable_Pin[i])
#undef PEv2_digout_AxisEnable_invert
#define PEv2_digout_AxisEnable_invert(i) (__comp_inst->PEv2_digout_AxisEnable_invert[i])
#undef PEv2_digin_Emergency_Pin
#define PEv2_digin_Emergency_Pin (__comp_inst->PEv2_digin_Emergency_Pin)
#undef PEv2_digin_Emergency_invert
#define PEv2_digin_Emergency_invert (__comp_inst->PEv2_digin_Emergency_invert)
#undef PEv2_digout_Emergency_Pin
#define PEv2_digout_Emergency_Pin (__comp_inst->PEv2_digout_Emergency_Pin)
#undef PEv2_digin_Probe_Pin
#define PEv2_digin_Probe_Pin (__comp_inst->PEv2_digin_Probe_Pin)
#undef PEv2_digin_Probe_invert
#define PEv2_digin_Probe_invert (__comp_inst->PEv2_digin_Probe_invert)
#undef adcin_scale
#define adcin_scale(i) (__comp_inst->adcin_scale[i])
#undef adcin_offset
#define adcin_offset(i) (__comp_inst->adcin_offset[i])
#undef digout_invert
#define digout_invert(i) (__comp_inst->digout_invert[i])
//#undef encoder_scale
//#define encoder_scale(i) (__comp_inst->encoder_scale[i])
#undef adcout_offset
#define adcout_offset(i) (__comp_inst->adcout_offset[i])
#undef adcout_scale
#define adcout_scale(i) (__comp_inst->adcout_scale[i])
#undef adcout_high_limit
#define adcout_high_limit(i) (__comp_inst->adcout_high_limit[i])
#undef adcout_low_limit
#define adcout_low_limit(i) (__comp_inst->adcout_low_limit[i])
#undef adcout_max_v
#define adcout_max_v(i) (__comp_inst->adcout_max_v[i])
#undef adcout_PinId
#define adcout_PinId(i) (__comp_inst->adcout_PinId[i])
#undef adcout_pwm_period
#define adcout_pwm_period (__comp_inst->adcout_pwm_period)
#undef FOR_ALL_INSTS
#define FOR_ALL_INSTS()               \
	struct __comp_state *__comp_inst; \
	for (__comp_inst = __comp_first_inst; __comp_inst; __comp_inst = __comp_inst->_next)

#line 577 "/home/zarfld/Documents/LinuxCnc_PokeysLibComp/pokeys_uspace/pokeys.comp"




static int comp_id; /* component ID */
//bool initEncodersDone = 0;
bool HAL_Machine_On = false;
bool setPkConfig = false;
bool setPinConfig = false;
bool I2C_isscanning = false;
bool secBlink = false;
unsigned Loop_Frequ = 0;
//uint8_t kbd48CNC_Counter[48];

bool posMode[8];
uint8_t posCount[8];
uint8_t velCount[8];
float last_joint_pos_cmd[8];
float last_joint_vel_cmd[8];
uint8_t rtc_latencycheck_set = 0;
int rtc_latencyCounter = 0;
// pin io unsigned PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration  - No Pin needed
uint8_t PEv2_PulseEngineStateSetup = 0;
uint8_t PulseEngineState = 0;
bool Pins_DigitalValueSet_ignore[55];

bool Homing_active = false;
bool Homing_done[8] = {false, false, false, false, false, false, false, false};
bool IsHoming[8] = {false, false, false, false, false, false, false, false};
int i = 0;

float temp_MaxAcceleration[8];
float minAccel = 0.0001;


typedef struct
{
	uint8_t matrixKBconfiguration;	  // Matrix keyboard configuration (set to 1 to enable matrix keyboard support)
	uint8_t matrixKBwidth;			  // Matrix keyboard width (number of columns)
	uint8_t matrixKBheight;			  // Matrix keyboard height (number of rows)
	uint8_t reserved[5];			  // placeholder
	uint8_t matrixKBcolumnsPins[8];	  // List of matrix keyboard column connections
	uint8_t matrixKBrowsPins[16];	  // List of matrix keyboard row connections
	uint8_t macroMappingOptions[128]; // Selects between direct key mapping and mapping to macro sequence for each key (assumes fixed width of 8 columns)
	//    uint8_t keyMappingKeyCode[128];            // USB keyboard key code for each key (assumes fixed width of 8 columns), also down key code in triggered mapping mode
	//    uint8_t keyMappingKeyModifier[128];        // USB keyboard key modifier, also down key modifier in triggered mapping mode (assumes fixed width of 8 columns)
	//    uint8_t keyMappingTriggeredKey[128];       // Selects between normal direct key mapping and triggered key mapping for each key (assumes fixed width of 8 columns)
	//    uint8_t keyMappingKeyCodeUp[128];          // USB keyboard up key code in triggered mapping mode (assumes fixed width of 8 columns)
	//    uint8_t keyMappingKeyModifierUp[128];      // USB keyboard up key modifier in triggered mapping mode (assumes fixed width of 8 columns)
	//    uint8_t matrixKBvalues[128];               // Current state of each matrix keyboard key (assumes fixed width of 8 columns)
	//	bool matrixKBPins[128];               // extracted from matrixKBrowsPins

} PK_MatrixKB_Parameters;

typedef enum
{
	PK_PEAxisCommand_axIDLE = 0,		 // Axis  in IDLE
	PK_PEAxisCommand_axHOMINGSTART = 1,	 // Start Homing procedure
	PK_PEAxisCommand_axHOMINGCANCEL = 2, // Cancel Homing procedure
	PK_PEAxisCommand_axHOMINGFinalize = 3, // Cancel Homing procedure
} pokeys_home_command_t;

pokeys_home_command_t old_PEv2_AxesCommand[8] = {0};


typedef enum
{
	PK_PEv2Homing_OnHomeStop = (1 << 3),			  // Axis  in IDLE
	PK_PEv2Homing_OnHomeArmEncoder = (1 << 2),		  // Start Homing procedure
	PK_PEv2Homing_OnHomeReverseDirection = (1 << 1),  // Cancel Homing procedure
	PK_PEv2Homing_OnHomeReducedSpeed = (1 << 0),	  // Cancel Homing procedure
	PK_PEv2Homing_OutHomeStop = (1 << 7),			  // Axis  in IDLE
	PK_PEv2Homing_OutHomeArmEncoder = (1 << 6),		  // Start Homing procedure
	PK_PEv2Homing_OutHomeReverseDirection = (1 << 5), // Cancel Homing procedure
	PK_PEv2Homing_OutHomeReducedSpeed = (1 << 4),	  // Cancel Homing procedure
} pokeys_homing_algorithm_t;




unsigned int sleepdur = 1000;
bool use_sleepdur1 = true;
unsigned int sleepdur1 = 1000;
unsigned int sleepdur2 = 1000;
float StepScale[8];

//bool DoPWM = false;
bool DoEncoders = true;

PK_MatrixKB_Parameters MatrixKB;

bool Get_BitOfByte(uint8_t in_Byte, int Bit_Id)
{
	return (in_Byte >> Bit_Id) & 0x01;
}

uint8_t Set_BitOfByte(uint8_t in_Byte, int Bit_Id, bool value)
{

	if (value == true)
	{
		in_Byte |= 1 << Bit_Id;
	}
	else
	{
		in_Byte &= ~(1 << Bit_Id);
	}
	return in_Byte;
}

uint8_t Merge_8BitsToByte(bool Bit_array[8])
{
	uint8_t sum = 0;
	for (int i = 0; i < 8; i++)
	{
		//    sum += Bit_array[i] - '0';
		//    sum<<=1;

		if (Bit_array[i] == true)
		{
			sum |= 1 << i;
		}
		else
		{
			sum &= ~(1 << i);
		}
	}
	return sum;
}



int Config_MatrixKB()
{



	if (PK_MatrixKBConfigurationGet(dev) == PK_OK)
	{
		MatrixKB.matrixKBconfiguration = dev->matrixKB.matrixKBconfiguration;
		MatrixKB.matrixKBwidth = dev->matrixKB.matrixKBheight;
		MatrixKB.matrixKBheight = dev->matrixKB.matrixKBwidth;

		for (i = 0; i < 8; i++)
		{
			MatrixKB.matrixKBrowsPins[i] = dev->matrixKB.matrixKBrowsPins[i];
			MatrixKB.matrixKBrowsPins[8 + i] = dev->matrixKB.matrixKBrowsPins[8 + i];

			MatrixKB.matrixKBcolumnsPins[i] = dev->matrixKB.matrixKBcolumnsPins[i];
		}

		for (i = 0; i < 128; i++)
		{
			MatrixKB.macroMappingOptions[i] = dev->matrixKB.macroMappingOptions[i];
		}
		usleep(sleepdur);
	}

	// PK_MatrixKBConfigurationSet
	return 0;
}

int Update_MatrixKB()
{
	if (PK_MatrixKBStatusGet(dev) == PK_OK)
	{
		for (i = 0; i < 128; i++)
		{
			//	MatrixKB.matrixKBvalues[i] = dev->matrixKB.matrixKBvalues[i];
		}
		usleep(sleepdur);
	}
	if (PK_MatrixKBConfigurationGet(dev) == PK_OK)
	{
		int i = 0;
		int h = 0;
		int w = 0;
		for (h = 0; h < MatrixKB.matrixKBheight; h++)
		{
			for (w = 0; w < MatrixKB.matrixKBwidth; w++)
			{
				//	MatrixKB.matrixKBPins[i] = Get_BitOfByte(MatrixKB.matrixKBrowsPins[h], w);
				i++;
			}
		}
		usleep(sleepdur);
	}
	return 0;
}


int Update_LCD()
{
	if (PK_LCDUpdate(dev) == PK_OK)
	{
		usleep(sleepdur);
	}
	if (PK_LCDSetCustomCharacters(dev) == PK_OK)
	{
		usleep(sleepdur);
	}
	return 0;
}


int Config_PoStep()
{
	if (PK_PoStep_ConfigurationGet(dev) == PK_OK)
	{
		usleep(sleepdur);
	}

	if (PK_PoStep_DriverConfigurationGet(dev) == PK_OK)
	{
		usleep(sleepdur);
	}

	// PK_PoStep_ConfigurationSet(dev)
	// PK_PoStep_DriverConfigurationSet(dev)
	return 0;
}

int Update_PoStep()
{
	if (PK_PoStep_StatusGet(dev) == PK_OK)
	{
		usleep(sleepdur);
	}
	return 0;
}

static char *serial_number = "";
// Not available in userspace code.
// RTAPI_MP_STRING(serial_number, "Device Serial Number")

static int ConnectionType = 0; // 1..USB, 2..UDP, 3..Network, 4..fastUSB
// Not available in userspace code.
// RTAPI_MP_INT(ConnectionType, "Connection Type (1..USB, 2..UDP, 3..Network, 4..fastUSB)")

static char *IP = "0.0.0.0";
// Not available in userspace code.
// RTAPI_MP_STRING(IP, "IP Address")

static int timeout_ms = 2000;
// Not available in userspace code.
// RTAPI_MP_INT(timeout_ms, "Timeout in ms")

static int retry = 3;

int instance_number = 0;

sPoKeysDevice *TryConnectToDevice(uint32_t intSerial)
{
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: serial_number: %d\n", intSerial);
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: serial_number=%d\n", __FILE__, __FUNCTION__, intSerial);
	sPoKeysDevice *retDev = NULL;
	uint32_t i_Timeout = 1000;
	uint32_t enm_usb_dev = 0;
	uint32_t enm_fusb_dev = 0;
	uint32_t enm_udp_dev = 0;
	int32_t nDevs = 0;
	uint32_t lastConectionTypeTried = 0;

	if (timeout_ms > 0){
		i_Timeout = timeout_ms;
	}
	if (intSerial != 0){
		retDev == PK_ConnectToDevice(0); // waits for usb device
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: intSerial=%d\n", __FILE__, __FUNCTION__, intSerial);
		if (retDev == NULL){
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateUSBDevices\n", __FILE__, __FUNCTION__);
			enm_usb_dev = PK_EnumerateUSBDevices();
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: enm_usb_dev :%d\n", __FILE__, __FUNCTION__, enm_usb_dev);
			enm_fusb_dev = PK_EnumerateFastUSBDevices();
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: enm_fusb_dev :%d\n", __FILE__, __FUNCTION__, enm_fusb_dev);
			if (enm_usb_dev != 0 || enm_fusb_dev != 0){
				rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d)\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
				retDev = PK_ConnectToDeviceWSerial((uint32_t)intSerial, i_Timeout); // waits for usb device
				lastConectionTypeTried = 1;
				if (retDev == NULL){
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) FAILED\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
					retDev = PK_ConnectToDeviceWSerial((uint32_t)intSerial, i_Timeout); // waits for usb device
					lastConectionTypeTried = 1;
					if (retDev == NULL){
						rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) FAILED\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);

						retDev = PK_ConnectToDeviceWSerial(intSerial, i_Timeout); // waits for usb device
						lastConectionTypeTried = 1;
						if (retDev == NULL){
							rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) FAILED\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);

							retDev = PK_ConnectToDevice(0); // waits for usb device
							lastConectionTypeTried = 1;
							if (retDev == NULL){
								rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(0) FAILED\n", __FILE__, __FUNCTION__);

								retDev = PK_ConnectToDevice(intSerial); // waits for usb device
								lastConectionTypeTried = 1;
								if (retDev == NULL){
									rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) FAILED\n", __FILE__, __FUNCTION__, intSerial);
								}
								else{
									rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) OK\n", __FILE__, __FUNCTION__, intSerial);
								}

							}
							else{
								rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(0) OK\n", __FILE__, __FUNCTION__);
							}
						}
						else{
							rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) OK\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
						}
					}
					else{
						rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) OK\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
					}

				}
				else{
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d) OK\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
				}

				


			}
		}
		if (retDev == NULL){
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d)\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
			retDev = PK_ConnectToDeviceWSerial_UDP(intSerial, i_Timeout); // waits for udp device
			if (retDev == NULL){
				rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d) FAILED\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
			}
			else{
				rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d) OK\n", __FILE__, __FUNCTION__, intSerial, i_Timeout);
			}
			lastConectionTypeTried = 2;
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 2\n", __FILE__, __FUNCTION__);
		}
		if (retDev == NULL){
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_SearchNetworkDevices(net_devices, %d, %d)\n", __FILE__, __FUNCTION__, i_Timeout, intSerial);
			sPoKeysNetworkDeviceSummary *net_devices;
			int32_t nDevs = PK_SearchNetworkDevices(net_devices, i_Timeout, intSerial);
			if (nDevs != 0){
				enm_udp_dev = nDevs;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices)\n", __FILE__, __FUNCTION__);
				retDev = PK_ConnectToNetworkDevice(net_devices);
				if (retDev == NULL){
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices) FAILED\n", __FILE__, __FUNCTION__);
				}
				else{
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices) OK\n", __FILE__, __FUNCTION__);
				}
				lastConectionTypeTried = 3;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
			}
			else{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateNetworkDevices(net_devices, %d)\n", __FILE__, __FUNCTION__, i_Timeout);
				//	nDevs = PK_EnumerateNetworkDevices(net_devices, i_Timeout); // does not work - it hangs here
				// deb_out = 1135;
				if (nDevs != 0){
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: nDevs: %s\n", __FILE__, __FUNCTION__, nDevs);
					enm_udp_dev = nDevs;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices)\n", __FILE__, __FUNCTION__);
					retDev = PK_ConnectToNetworkDevice(net_devices);
					lastConectionTypeTried = 3;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
				}
			}
		}
	}
	else
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: udp_devices[16]\n", __FILE__, __FUNCTION__);
		sPoKeysNetworkDeviceSummary udp_devices[16];

		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateUSBDevices()\n", __FILE__, __FUNCTION__);
		enm_usb_dev = PK_EnumerateUSBDevices();
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateUSBDevices()=%d\n", __FILE__, __FUNCTION__, enm_usb_dev);

		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateFastUSBDevices()\n", __FILE__, __FUNCTION__);
		// enm_fusb_dev = PK_EnumerateFastUSBDevices();
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateFastUSBDevices()=%d\n", __FILE__, __FUNCTION__, enm_fusb_dev);
		i_Timeout = 1000;
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_EnumerateNetworkDevices(udp_devices, %d)\n", __FILE__, __FUNCTION__, i_Timeout);
		int32_t nDevs = PK_EnumerateNetworkDevices(udp_devices, i_Timeout); // does not work - it hangs here
																			//	rtapi_print("");
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: nDevs: %d\n", __FILE__, __FUNCTION__, nDevs);
		// enm_udp_dev = nDevs;

		if (nDevs != 0)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(udp_devices) - %d\n", __FILE__, __FUNCTION__, nDevs);
			for (int i = 0; i < 16; i++)
			{
				if (retDev == NULL)
				{
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: udp_devices[%d].SerialNumber: %d\n", __FILE__, __FUNCTION__, i, udp_devices[i].SerialNumber);
					if (udp_devices[i].SerialNumber != 0)
					{
						rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d)\n", __FILE__, __FUNCTION__, udp_devices[i].SerialNumber, i_Timeout);
						retDev = PK_ConnectToDeviceWSerial_UDP(udp_devices[i].SerialNumber, i_Timeout); // waits for udp device
						lastConectionTypeTried = 2;
						rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: lastConectionTypeTried = 2\n", __FILE__, __FUNCTION__);
					}
				}
				else
				{
					break;
				}
			}
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
		}
		if (enm_fusb_dev > 0)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice FastUSB\n", __FILE__, __FUNCTION__);
			for (int i = 0; i < enm_fusb_dev+1; i++)
			{
				rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d)\n", __FILE__, __FUNCTION__, i);
				retDev = PK_ConnectToDevice(i);
				if (retDev == NULL){
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) FAILED\n", __FILE__, __FUNCTION__, i);
				}
				else{
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) OK\n", __FILE__, __FUNCTION__, i);
				}
			}
			lastConectionTypeTried = 4;
		}

		if (enm_usb_dev > 0)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice FastUSB\n", __FILE__, __FUNCTION__);
			for (int i = 0; i < enm_usb_dev+1; i++)
			{
				rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d)\n", __FILE__, __FUNCTION__, i);
				retDev = PK_ConnectToDevice(i);
				if (retDev == NULL){
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) FAILED\n", __FILE__, __FUNCTION__, i);
				}
				else{
					rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: PK_ConnectToDevice(%d) OK\n", __FILE__, __FUNCTION__, i);
				}
			}
			lastConectionTypeTried = 4;
		}
		// deb_out = 120;
	}
	if (retDev != NULL)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: Connected to device\n", __FILE__, __FUNCTION__);
		// connected = 1;
		if (lastConectionTypeTried == 1)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: USB\n", __FILE__, __FUNCTION__);
			// cannot set pins outside of user_mainloop()
			//	connected_usb = 1;
			//	connected_fusb = 0;
			//	connected_udp = 0;
			//	connected_net = 0;
		}
		if (lastConectionTypeTried == 2)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: UDP\n", __FILE__, __FUNCTION__);
			// cannot set pins outside of user_mainloop()
			//	connected_usb = 0;
			//	connected_fusb = 0;
			//	connected_udp = 1;
			//	connected_net = 0;
		}
		if (lastConectionTypeTried == 3)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: Network\n", __FILE__, __FUNCTION__);
			// cannot set pins outside of user_mainloop()
			//	connected_usb = 0;
			//	connected_fusb = 0;
			//	connected_udp = 0;
			//	connected_net = 1;
		}
		return retDev;
	}
	else
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: failed to connect to device\n", __FILE__, __FUNCTION__);
		// connected_usb = 0;
		// connected_fusb = 0;
		// connected_udp = 0;
		// connected_net = 0;
		// err = 1;
		return NULL;
	}
}

bool initdone = 0;

void user_mainloop(void)
{

	rtapi_print("  \n");
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: user_mainloop started  \n", __FILE__, __FUNCTION__);
	rtapi_print("  \n");
	// rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: trigger hal_init('pokeys'#')\n", __FILE__, __FUNCTION__);
	//  comp_id = hal_init("pokeys"); // seems already initialized
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: comp_id: %d\n", __FILE__, __FUNCTION__, comp_id);
	rtapi_print("  \n");
	while (0xb)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: while(0xb) \n", __FILE__, __FUNCTION__);

		FOR_ALL_INSTS()
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: FOR_ALL_INSTS() \n", __FILE__, __FUNCTION__);
			rtc_loopcount++;
			HAL_Machine_On = machine_is_on;

			deb_out = 100;

			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: initdone: %s\n", __FILE__, __FUNCTION__, initdone ? "true" : "false");
			while (dev == NULL | initdone != 1)
			{
				Loop_Frequ = rtc_loop_frequ;
				uint32_t lastConectionTypeTried = 0;
				if (PEv2_digout_Emergency_out != true)
				{
					usleep(sleepdur);
				}

				if (dev == NULL)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: TryConnectToDevice %d \n", __FILE__, __FUNCTION__, devSerial);
					dev = TryConnectToDevice(devSerial);
					if (dev != NULL)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Connected to device\n", __FILE__, __FUNCTION__);
					}
				}

				if (dev != NULL)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev != NULL\n", __FILE__, __FUNCTION__);
					if (devSerial == 0)
					{

						devSerial = dev->DeviceData.SerialNumber;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: devSerial: %d\n", __FILE__, __FUNCTION__, devSerial);
					}
					switch (dev->connectionType)
					{
					case PK_DeviceType_USBDevice:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: USB\n", __FILE__, __FUNCTION__);
						connected_usb = 1;
						connected_fusb = 0;
						connected_udp = 0;
						connected_net = 0;
						break;
					case PK_DeviceType_FastUSBDevice:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: FastUSB\n", __FILE__, __FUNCTION__);
						connected_usb = 0;
						connected_fusb = 1;
						connected_udp = 0;
						connected_net = 0;
						break;
					case PK_DeviceType_NetworkDevice:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: NetworkDevice\n", __FILE__, __FUNCTION__);

						/*  PK_ConnectionParam_TCP = 0,
							PK_ConnectionParam_UDP = 1*/
						if (dev->connectionParam == 0)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: TCP\n", __FILE__, __FUNCTION__);
							connected_usb = 0;
							connected_fusb = 0;
							connected_udp = 0;
							connected_net = 1;
						}
						else
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: UDP\n", __FILE__, __FUNCTION__);
							connected_usb = 0;
							connected_fusb = 0;
							connected_udp = 1;
							connected_net = 0;
						}

						break;
					}

					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: initialize info pins\n", __FILE__, __FUNCTION__);

					info_PinCount = dev->info.iPinCount;											 // Number of pins, physically on the device
					info_PWMCount = dev->info.iPWMCount;											 // Number of pins that support PWM output
					info_BasicEncoderCount = dev->info.iBasicEncoderCount;							 // Number of basic encoders
					info_EncodersCount = dev->info.iEncodersCount;									 // Number of encoder slots available
					info_FastEncoders = dev->info.iFastEncoders;									 // Number of fast encoders supported
					info_UltraFastEncoders = dev->info.iUltraFastEncoders;							 // Number of available ultra fast encoders
					info_PWMinternalFrequency = dev->info.PWMinternalFrequency;						 // Main PWM peripheral clock
					info_AnalogInputs = dev->info.iAnalogInputs;									 // Number of info_protI2Cavailable analog inputs
					info_KeyMapping = dev->info.iKeyMapping;										 // Device supports key mapping (acts as a USB keyboard)
					info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;						 // Device supports triggered key mapping
					info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;								 // Device supports user customizable key repeat rates and delays
					info_DigitalCounters = dev->info.iDigitalCounters;								 // Device supports digital counters
					info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;			 // Device supports mapping of joystick buttons
					info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping; // Device supports mapping of analog inputs to digital keys
					info_Macros = dev->info.iMacros;												 // Device supports customizable macro sequences
					info_MatrixKeyboard = dev->info.iMatrixKeyboard;								 // Device supports matrix keyboard
					info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping; // Device supports matrix keyboard triggered key mapping
					info_LCD = dev->info.iLCD;														 // Device supports alphanumeric LCD display
					info_MatrixLED = dev->info.iMatrixLED;											 // Device supports matrix LED display
					info_ConnectionSignal = dev->info.iConnectionSignal;							 // Device supports connection signal output
					info_PoExtBus = dev->info.iPoExtBus;											 // Device supports PoExtBus digital outputs
					info_PoNET = dev->info.iPoNET;													 // Device supports PoNET bus devices
					info_AnalogFiltering = dev->info.iAnalogFiltering;								 // Device supports analog inputs low-pass digital filtering
					info_InitOutputsStart = dev->info.iInitOutputsStart;							 // Device supports initializing outputs at startup
					info_protI2C = dev->info.iprotI2C;												 // Device supports I2C bus (master)
					info_prot1wire = dev->info.iprot1wire;											 // Device supports 1-wire bus (master)
					info_AdditionalOptions = dev->info.iAdditionalOptions;							 // Device supports additional options with activation keys
					info_LoadStatus = dev->info.iLoadStatus;										 // Device supports reporting load status
					info_CustomDeviceName = dev->info.iCustomDeviceName;							 // Device supports specifying custom device names
					info_PoTLog27support = dev->info.iPoTLog27support;								 // Device supports PoTLog27 firmware
					info_SensorList = dev->info.iSensorList;										 // Device supports sensor lists
					info_WebInterface = dev->info.iWebInterface;									 // Device supports web interface
					info_FailSafeSettings = dev->info.iFailSafeSettings;							 // Device supports fail-safe mode
					info_JoystickHATswitch = dev->info.iJoystickHATswitch;							 // Device supports joystick HAT switch mapping
					info_PulseEngine = dev->info.iPulseEngine;										 // Device supports Pulse engine
					info_PulseEnginev2 = dev->info.iPulseEnginev2;									 // Device supports Pulse engine v2
					info_EasySensors = dev->info.iEasySensors;										 // Device supports EasySensors

					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Device info pins initialized\n", __FILE__, __FUNCTION__);
					switch (dev->DeviceData.DeviceTypeID)
					{
					case PK_DeviceID_PoKeys57CNC:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_PoKeys57CNC\n", __FILE__, __FUNCTION__);
						PEv2_PulseEngineEnabled = 8;
						PEv2_PG_extended_io = true;
						break;
					case PK_DeviceID_PoKeys57CNCdb25:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_PoKeys57CNCdb25\n", __FILE__, __FUNCTION__);
						PEv2_PG_extended_io = false;
						break;
					case PK_DeviceID_57U:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_57U\n", __FILE__, __FUNCTION__);
						PEv2_PG_extended_io = false;
						break;
					case PK_DeviceID_57E:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_57E\n", __FILE__, __FUNCTION__);
						PEv2_PG_extended_io = false;
						break;
					}

					if (info_protI2C != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_protI2C = %d \n", __FILE__, __FUNCTION__, info_protI2C);

						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_I2CBusScanStart\n", __FILE__, __FUNCTION__);
						if (PK_I2CBusScanStart(dev) == PK_OK)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_I2CBusScanStart - scan started\n", __FILE__, __FUNCTION__);
							I2C_isscanning = true;
							usleep(sleepdur);
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: I2C_isscanning = %d\n", __FILE__, __FUNCTION__, I2C_isscanning);
					}

					if (setPinConfig == true)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: setPinConfig = true\n", __FILE__, __FUNCTION__);
						if (PK_PinConfigurationSet(dev) == PK_OK)
						{
							usleep(sleepdur);
							setPinConfig = false;
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: setPinConfig -done\n", __FILE__, __FUNCTION__);
					}
					
					// dev->DeviceData.DeviceLockStatus=1;

					if (PEv2_params_ApplyIniSettings != 0 && info_PulseEnginev2 != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SaveConfiguration - PEv2_params_ApplyIniSettings\n", __FILE__, __FUNCTION__);
						if (PK_SaveConfiguration(dev) != PK_OK)
						{
							usleep(sleepdur * 2);
							if (PK_SaveConfiguration(dev) != PK_OK)
							{
								usleep(sleepdur * 2);
							}
						}
					}
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Device info pins initialized\n", __FILE__, __FUNCTION__);
					initdone = 1;
				}

				usleep(sleepdur);
			}
			alive = 1;
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: alive=1\n", __FILE__, __FUNCTION__);
			deb_out = 200;
			// RTC
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_RTCGet(dev)\n", __FILE__, __FUNCTION__);
			if (PK_RTCGet(dev) == PK_OK)
			{
				deb_out = 210;
				rtc_sec = dev->RTC.SEC;
				rtc_min = dev->RTC.MIN;
				rtc_hour = dev->RTC.HOUR;
				rtc_dow = dev->RTC.DOW;
				rtc_dom = dev->RTC.DOM;
				rtc_tmp = dev->RTC.tmp;
				rtc_doy = dev->RTC.DOY;
				rtc_month = dev->RTC.MONTH;
				rtc_year = dev->RTC.YEAR;

				if (rtc_lastsec != rtc_sec)
				{
					deb_out = 211;
					rtc_loop_frequ = rtc_loopcount;
					rtc_loopcount = 0;
					rtc_lastsec = rtc_sec;

					if (secBlink)
					{
						secBlink = false;
					}
					else
					{
						secBlink = true;
					}

					// sleepdur
					if (rtc_loop_frequ > 15)
					{
						if (rtc_loop_frequ_demand == 0)
						{
							sleepdur = sleepdur * rtc_loop_frequ / 15;
						}
						else
						{
							sleepdur = sleepdur * rtc_loop_frequ / rtc_loop_frequ_demand;
						}
					}
					else
					{
						sleepdur = sleepdur / 2;
					}
					if (sleepdur > 1000000)
					{
						sleepdur = 1000000;
					}
					if (sleepdur < 50)
					{
						sleepdur = 50;
					}

					if (rtc_latencycheck_set = -1)
					{
						rtc_latencyCounter = 0;
						rtc_latencycheck_set = dev->RTC.SEC;
					}
				}
				// hope to get loopfrequency more stable - as on everyminute additional actions
				if (use_sleepdur1 == false)
				{
					sleepdur2 = sleepdur;
					sleepdur = sleepdur1;
					use_sleepdur1 = true;
				}
				else
				{
					sleepdur1 = sleepdur;
				}
				if (rtc_lastmin != rtc_min)
				{
					use_sleepdur1 = false;
					sleepdur1 = sleepdur;
					sleepdur = sleepdur2;
				}

				if (rtc_sec_ret >= rtc_latencycheck_set && rtc_latencycheck_set > 0)
				{
					rtc_hal_latency = rtc_latencyCounter;
					rtc_latencycheck_set = -1;
				}
				else if (rtc_latencycheck_set >= -0)
				{
					rtc_latencyCounter++;
				}
				deb_out = 212;
			}

			// PulseEnginev2
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PulseEnginev2 = %d\n", __FILE__, __FUNCTION__, info_PulseEnginev2);
			if (info_PulseEnginev2 != 0)
			{
				uint8_t bm_LimitStatusP; // Limit+ status (bit-mapped)
				uint8_t bm_LimitStatusN; // Limit- status (bit-mapped)
				uint8_t bm_HomeStatus;	 // Home status (bit-mapped)
				uint8_t bm_ErrorStatus;
				uint8_t bm_ProbeStatus = dev->PEv2.ProbeStatus; // will be update in "PK_PEv2_ProbingFinish" or "PK_PEv2_ProbingFinishSimple"
				uint8_t bm_DedicatedLimitNInputs;
				uint8_t bm_DedicatedLimitPInputs;
				uint8_t bm_DedicatedHomeInputs;

				if (bm_ProbeStatus != 0)
				{
					PEv2_digin_Probed_in = true;
				}
				else
				{
					PEv2_digin_Probed_in = false;
				}
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_StatusGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PEv2_StatusGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_StatusGet(dev) = PK_OK\n", __FILE__, __FUNCTION__);
					// Engine info
					PEv2_nrOfAxes = dev->PEv2.info.nrOfAxes;
					PEv2_maxPulseFrequency = dev->PEv2.info.maxPulseFrequency;
					PEv2_bufferDepth = dev->PEv2.info.bufferDepth;
					PEv2_slotTiming = dev->PEv2.info.slotTiming;

					PEv2_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
					PEv2_LimitOverride = dev->PEv2.LimitOverride;

					// Basic engine states
					PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
					PEv2_PulseEngineActivated = dev->PEv2.PulseEngineActivated;

					PulseEngineState = dev->PEv2.PulseEngineState;
					PEv2_PulseEngineState = PulseEngineState;
					PEv2_PulseEngineStateSetup = PulseEngineState;

					PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
					PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;

					// Switch states
					bm_LimitStatusP = dev->PEv2.LimitStatusP; // Limit+ status (bit-mapped)
					bm_LimitStatusN = dev->PEv2.LimitStatusN; // Limit- status (bit-mapped)
					bm_HomeStatus = dev->PEv2.HomeStatus;	  // Home status (bit-mapped)
					if (PEv2_params_ApplyIniSettings == false)
					{
						PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
					}

					// Other inputs
					bm_ErrorStatus = dev->PEv2.ErrorInputStatus;
					PEv2_MiscInputStatus = dev->PEv2.MiscInputStatus;

					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: HAL_Machine_On = %s\n", __FILE__, __FUNCTION__, HAL_Machine_On);

					if (HAL_Machine_On == 0)
					{
						PEv2_PulseEngineStateSetup = PK_PEState_peSTOPPED;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_PulseEngineStateSetup = PK_PEState_peSTOPPED\n", __FILE__, __FUNCTION__);
					}
					else if (PulseEngineState == PK_PEState_peSTOPPED)
					{
						PEv2_PulseEngineStateSetup = PK_PEState_peRUNNING;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_PulseEngineStateSetup = PK_PEState_peRUNNING\n", __FILE__, __FUNCTION__);
					}
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PulseEngineState = %d\n", __FILE__, __FUNCTION__, PulseEngineState);
					switch (PulseEngineState)
					{
					case PK_PEState_peSTOPPED: // Pulse engine is stopped
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOPPED\n", __FILE__, __FUNCTION__);
						if (HAL_Machine_On != 0)
						{
							PEv2_PulseEngineStateSetup = PK_PEState_peRUNNING;
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_PulseEngineStateSetup = PK_PEState_peRUNNING\n", __FILE__, __FUNCTION__);
						}
						break;
					case PK_PEState_peINTERNAL: // PEv1: Internal motion controller is in use, PEv2: not used
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peINTERNAL\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peBUFFER: // PEv1: Buffered operation mode is in use, PEv2: not used
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peBUFFER\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peRUNNING: // Pulse engine is activated
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peRUNNING\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peJOGGING: // Jogging mode enabled
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peJOGGING\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peSTOPPING: // Pulse engine is stopping
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOPPING\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peHOME: // All axes are homed
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHOME\n", __FILE__, __FUNCTION__);
						if (Homing_active)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_HomingFinish(dev) \n", __FILE__, __FUNCTION__);
							//	PK_PEv2_HomingFinish(dev);
							Homing_active = false;
						}
						break;
					case PK_PEState_peHOMING: // Axes homing is in progress
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHOMING\n", __FILE__, __FUNCTION__);
						Homing_active = true;
						break;
					case PK_PEState_pePROBECOMPLETE: // All axes are homed
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_pePROBECOMPLETE\n", __FILE__, __FUNCTION__);

						break;
					case PK_PEState_pePROBE: // Axes probing is in progress
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_pePROBE\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_pePROBEERROR: // Error occured during probing
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_pePROBEERROR\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peHYBRIDPROBE_STOPPING:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHYBRIDPROBE_STOPPING\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peHYBRIDPROBE_COMPLETE:
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHYBRIDPROBE_COMPLETE\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peSTOP_LIMIT: // Pulse engine stopped due to limit reached
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOP_LIMIT\n", __FILE__, __FUNCTION__);
						break;
					case PK_PEState_peSTOP_EMERGENCY: // Pulse engine stopped due to emergency switch
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOP_EMERGENCY\n", __FILE__, __FUNCTION__);
						PEv2_digin_Emergency_in = true;
						PEv2_digin_Emergency_in_not = false;
						PEv2_deb_estop = 10;
						break;
					}
					usleep(sleepdur);
				}
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_Status2Get(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PEv2_Status2Get(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_Status2Get(dev) = PK_OK\n", __FILE__, __FUNCTION__);
					bm_DedicatedLimitNInputs = dev->PEv2.DedicatedLimitNInputs;
					bm_DedicatedLimitPInputs = dev->PEv2.DedicatedLimitPInputs;
					bm_DedicatedHomeInputs = dev->PEv2.DedicatedHomeInputs;
					usleep(sleepdur);
				}
				else
				{
					usleep(sleepdur);
					if (PK_PEv2_Status2Get(dev) == PK_OK)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_Status2Get(dev) = PK_OK\n", __FILE__, __FUNCTION__);
						bm_DedicatedLimitNInputs = dev->PEv2.DedicatedLimitNInputs;
						bm_DedicatedLimitPInputs = dev->PEv2.DedicatedLimitPInputs;
						bm_DedicatedHomeInputs = dev->PEv2.DedicatedHomeInputs;
						usleep(sleepdur);
					}
				}
				bool doPositionSet = false;
				bool doMove = false;
				bool isMoving = false;
				bool doStateSet = false;
				bool doHomingStart = false;
				bool doHomingEnd = false;
				int HomingStartMaskSetup = 0;

				bool InPosition[8];
				bool POSITION_MODE_active[8];

				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PEv2_nrOfAxes = %d\n", __FILE__, __FUNCTION__, PEv2_nrOfAxes);
				if (PEv2_nrOfAxes != 0)
				{
					uint8_t bm_SoftLimitStatus = dev->PEv2.SoftLimitStatus;
					int tAxisEnabledMask = 0;

					int32_t intCurrentPosition[8];
					float PosFb[8];
					for (i = 0; i < PEv2_nrOfAxes; i++)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d] \n", __FILE__, __FUNCTION__, i);

						InPosition[i] = false;

						uint8_t intAxesState = dev->PEv2.AxesState[i];
						uint8_t intAxesCommand = PEv2_AxesCommand(i);
						PEv2_AxesState(i) = intAxesState;
						PEv2_deb_axxisout(i) = 200 + i;
						StepScale[i] = PEv2_stepgen_STEP_SCALE(i);
						PEv2_deb_axxisout(i) = 210 + i;
						// PEv2_CurrentPosition(i) = dev->PEv2.CurrentPosition[i];
						intCurrentPosition[i] = dev->PEv2.CurrentPosition[i];
						PEv2_deb_axxisout(i) = 220 + i;

						PEv2_digin_Error_in(i) = Get_BitOfByte(bm_ErrorStatus, i);
						PEv2_digin_Error_in_not(i) = !Get_BitOfByte(bm_ErrorStatus, i);
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: intAxesState = %d\n", __FILE__, __FUNCTION__, intAxesState);
						switch (intAxesState)
						{
						case PK_PEAxisState_axSTOPPED: // Axis is stopped
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEAxisState_axSTOPPED\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axSTOPPED \n", __FILE__, __FUNCTION__, i);
								IsHoming[i] = false;
							}

							PEv2_deb_out = 310 + i;
							// PEv2_digin_AxisEnabled_in(i) = false;
							// PEv2_digin_LimitOverride_in(i) = false;

							break;
						case PK_PEAxisState_axREADY: // Axis ready
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEAxisState_axREADY\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axREADY \n", __FILE__, __FUNCTION__, i);
							}
							// IsHoming[i] = false;
							PEv2_deb_out = 320 + i;
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = false;

							break;
						case PK_PEAxisState_axRUNNING: // Axis is running
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEAxisState_axRUNNING\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axRUNNING \n", __FILE__, __FUNCTION__, i);
							}
							// IsHoming[i] = false;
							PEv2_deb_out = 330 + i;
							break;
						case PK_PEAxisState_axHOMING_RESETTING: // Stopping the axis to reset the position counters
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMING_RESETTING\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axHOMING_RESETTING \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_LimitOverride_in(i) = true;
							// PEv2_digin_AxisEnabled_in(i) = true;
							IsHoming[i] = true;
							PEv2_deb_out = 340 + i;
							break;
						case PK_PEAxisState_axHOMING_BACKING_OFF: // Backing off switch
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMING_BACKING_OFF\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axHOMING_BACKING_OFF \n", __FILE__, __FUNCTION__, i);
							}
							IsHoming[i] = true;
							PEv2_deb_out = 340 + i;

							// PEv2_digin_LimitOverride_in(i) = true;
							// PEv2_digin_AxisEnabled_in(i) = true;
							break;
						case PK_PEAxisState_axHOME: // Axis is homed
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOME\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axHOME \n", __FILE__, __FUNCTION__, i);
							}
							PEv2_deb_out = 340 + i;
							// IsHoming[i] = false;
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = true;
							// PEv2_joint_
							break;
						case PK_PEAxisState_axHOMINGSTART: // Homing procedure is starting on axis
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMINGSTART\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axHOMINGSTART \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = true;
							IsHoming[i] = true;
							Homing_active = true;
							PEv2_deb_out = 340 + i;
							break;
						case PK_PEAxisState_axHOMINGSEARCH: // Homing procedure first step - going to home
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMINGSEARCH\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axHOMINGSEARCH \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = true;
							IsHoming[i] = true;
							Homing_active = true;
							PEv2_deb_out = 340 + i;
							break;
						case PK_PEAxisState_axHOMINGBACK: // Homing procedure second step - slow homing
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMINGBACK\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axHOMINGBACK \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = true;
							IsHoming[i] = true;
							Homing_active = true;
							PEv2_deb_out = 340 + i;
							break;
						case PK_PEAxisState_axPROBED: // Probing completed for this axis
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axPROBED\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axPROBED \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = false;
							// IsHoming[i] = false;
							PEv2_deb_out = 350 + i;
							break;
						case PK_PEAxisState_axPROBESTART: // Probing procedure is starting on axis
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axPROBESTART\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axPROBESTART \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = false;
							// IsHoming[i] = false;
							PEv2_deb_out = 350 + i;
							break;
						case PK_PEAxisState_axPROBESEARCH: // Probing procedure - probing
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axPROBESEARCH\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axPROBESEARCH \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = false;
							// IsHoming[i] = false;
							PEv2_deb_out = 350 + i;
							break;
						case PK_PEAxisState_axERROR: // Axis error
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axERROR\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axERROR \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = false;
							// PEv2_digin_LimitOverride_in(i) = false;
							IsHoming[i] = false;
							PEv2_deb_out = 360 + i;

							break;
						case PK_PEAxisState_axLIMIT: // Axis limit tripped
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axLIMIT\n", __FILE__, __FUNCTION__);
							if (IsHoming[i] == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d].AxesState = PK_PEAxisState_axLIMIT \n", __FILE__, __FUNCTION__, i);
							}
							// PEv2_digin_AxisEnabled_in(i) = true;
							// PEv2_digin_LimitOverride_in(i) = false;
							// IsHoming[i] = false;
							PEv2_deb_out = 370 + i;
							break;
						default:

							PEv2_deb_out = 380 + i;
							break;
						}

						// calculate actual velocity by position difference (time estimated by actual rtc_loop_frequ [Hz] / [1/sec] )
						if (IsHoming[i] == false)
						{
							if (StepScale[i] != 0)
							{
								PEv2_deb_axxisout(i) = 230 + i;
								PosFb[i] = intCurrentPosition[i] / StepScale[i];
							}
							else
							{
								PEv2_deb_axxisout(i) = 240 + i;
								PosFb[i] = intCurrentPosition[i];
							}
						}
						else
						{
							// when homing, use the command position as feedback
							// during homing the position is being reset to 0, so the feedback would be 0
							// which causes FERROR
							PosFb[i] = PEv2_joint_pos_cmd(i);
						}

						PEv2_deb_axxisout(i) = 250 + i;
						PEv2_joint_pos_fb(i) = PosFb[i];
						PEv2_deb_axxisout(i) = 260 + i;
						PEv2_CurrentPosition(i) = intCurrentPosition[i];
						PEv2_deb_axxisout(i) = 270 + i;

						PEv2_digin_Probe_in(i) = Get_BitOfByte(bm_ProbeStatus, i);

						/*
						   param rw unsigned PEv2.#.digin.LimitN.Pin [8] "Limit- switch pin (0 for external dedicated input)";			// Limit- switch pin (0 for external dedicated input)
						   param rw unsigned PEv2.#.digin.LimitN.Filter[8] "Digital filter for limit- switch";		// Digital filter for limit- switch
						   param rw bit PEv2.#.digin.LimitN.invert[8] "Invert limit- (PK_ASO_SWITCH_INVERT_LIMIT_N)";
						   param rw bit PEv2.#.digin.LimitN.Enabled[8] "Limit- is available (PK_ASO_SWITCH_LIMIT_N)";
						*/
						if (PEv2_digin_LimitP_Pin(i) > 0)
						{
							if (PEv2_digin_LimitP_invert(i) != 0)
							{
								PEv2_digin_LimitP_in(i) = !Get_BitOfByte(bm_LimitStatusP, i);
								PEv2_digin_LimitP_in_not(i) = Get_BitOfByte(bm_LimitStatusP, i);
							}
							else
							{
								PEv2_digin_LimitP_in(i) = !Get_BitOfByte(bm_LimitStatusP, i);
								PEv2_digin_LimitP_in_not(i) = Get_BitOfByte(bm_LimitStatusP, i);
							}
							PEv2_digin_LimitP_DedicatedInput(i) = Get_BitOfByte(bm_DedicatedLimitPInputs, i);
						}
						else if (PEv2_digin_LimitP_Enabled(i) != 0)
						{
							if (PEv2_digin_LimitP_invert(i) != 0)
							{
								PEv2_digin_LimitP_in(i) = !Get_BitOfByte(bm_DedicatedLimitPInputs, i);
								PEv2_digin_LimitP_in_not(i) = Get_BitOfByte(bm_DedicatedLimitPInputs, i);
								PEv2_digin_LimitP_DedicatedInput(i) = !Get_BitOfByte(bm_DedicatedLimitPInputs, i);
							}
							else
							{
								PEv2_digin_LimitP_in(i) = Get_BitOfByte(bm_DedicatedLimitPInputs, i);
								PEv2_digin_LimitP_in_not(i) = !Get_BitOfByte(bm_DedicatedLimitPInputs, i);
								PEv2_digin_LimitP_DedicatedInput(i) = Get_BitOfByte(bm_DedicatedLimitPInputs, i);
							}
						}

						if (PEv2_digin_LimitN_Pin(i) > 0)
						{
							if (PEv2_digin_LimitN_invert(i) != 0)
							{
								PEv2_digin_LimitN_in(i) = !Get_BitOfByte(bm_LimitStatusN, i);
								PEv2_digin_LimitN_in_not(i) = Get_BitOfByte(bm_LimitStatusN, i);
							}
							else
							{
								PEv2_digin_LimitN_in(i) = !Get_BitOfByte(bm_LimitStatusN, i);
								PEv2_digin_LimitN_in_not(i) = Get_BitOfByte(bm_LimitStatusN, i);
							}
							PEv2_digin_LimitN_DedicatedInput(i) = Get_BitOfByte(bm_DedicatedLimitNInputs, i);
						}
						else if (PEv2_digin_LimitN_Enabled(i) != 0)
						{
							if (PEv2_digin_LimitN_invert(i) != 0)
							{
								PEv2_digin_LimitN_in(i) = !Get_BitOfByte(bm_DedicatedLimitNInputs, i);
								PEv2_digin_LimitN_in_not(i) = Get_BitOfByte(bm_DedicatedLimitNInputs, i);
								PEv2_digin_LimitN_DedicatedInput(i) = !Get_BitOfByte(bm_DedicatedLimitNInputs, i);
							}
							else
							{
								PEv2_digin_LimitN_in(i) = Get_BitOfByte(bm_DedicatedLimitNInputs, i);
								PEv2_digin_LimitN_in_not(i) = !Get_BitOfByte(bm_DedicatedLimitNInputs, i);
								PEv2_digin_LimitN_DedicatedInput(i) = Get_BitOfByte(bm_DedicatedLimitNInputs, i);
							}
						}

						if (PEv2_digin_Home_Pin(i) > 0)
						{
							if (PEv2_digin_Home_invert(i) != 0)
							{
								PEv2_digin_Home_in(i) = !Get_BitOfByte(bm_HomeStatus, i);
								PEv2_digin_Home_in_not(i) = Get_BitOfByte(bm_HomeStatus, i);
							}
							else
							{
								PEv2_digin_Home_in(i) = Get_BitOfByte(bm_HomeStatus, i);
								PEv2_digin_Home_in_not(i) = !Get_BitOfByte(bm_HomeStatus, i);
							}
							PEv2_digin_Home_DedicatedInput(i) = Get_BitOfByte(bm_DedicatedHomeInputs, i);
						}
						else if (PEv2_digin_Home_Enabled(i))
						{
							if (PEv2_digin_Home_invert(i) != 0)
							{
								PEv2_digin_Home_in(i) = !Get_BitOfByte(bm_DedicatedHomeInputs, i);
								PEv2_digin_Home_in_not(i) = Get_BitOfByte(bm_DedicatedHomeInputs, i);
							}
							else
							{
								PEv2_digin_Home_in(i) = Get_BitOfByte(bm_DedicatedHomeInputs, i);
								PEv2_digin_Home_in_not(i) = !Get_BitOfByte(bm_DedicatedHomeInputs, i);
							}
						}

						PEv2_deb_axxisout(i) = 280;

						PEv2_digin_SoftLimit_in(i) = Get_BitOfByte(bm_SoftLimitStatus, i);
						PEv2_deb_axxisout(i) = 290 + i;

						/*
						PEv2.#.digin.Error.in[8]

						bm_ErrorStatus
						*/

						if ((intAxesState == PK_PEAxisState_axSTOPPED || intAxesState == PK_PEAxisState_axREADY || intAxesState == PK_PEAxisState_axHOME) && old_PEv2_AxesCommand[i] != PEv2_AxesCommand(i) && (PEv2_AxesCommand(i) == PK_PEAxisState_axHOMINGSTART || PEv2_AxesCommand(i) == PK_PEAxisCommand_axHOMINGSTART))
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Trigger HomingStart\n", __FILE__, __FUNCTION__);

							int MyHomeSequ, seq;
							MyHomeSequ = PEv2_home_sequence(i);
							HomingStartMaskSetup = (1 << i); // Home my axis only (bit MyHomeSequ)
							rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: ensurinig that all axes (%d) with same Sequence(%d) startmask initialized (%d) \n", i, PEv2_home_sequence(i), HomingStartMaskSetup);

							// ensure that all axes with same Sequence start homing at the same time
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: ensure that all axes with same Sequence start homing at the same time\n", __FILE__, __FUNCTION__);
							int j_count = 0;
							for (seq = 0; seq < PEv2_nrOfAxes; seq++)
							{

								if (PEv2_home_sequence(seq) == PEv2_home_sequence(i))
								{
									//	rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: ensure that all axes (%d) with same Sequence(%d) start homing at the same time \n", seq, PEv2_home_sequence(i));

									HomingStartMaskSetup |= (1 << seq); // Home axis seq only (bit seq)
									j_count++;
									doHomingStart = true;
								}
							}

							if (j_count == 0)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: no axes with same Sequence(%d) as joint(%d) found \n", PEv2_home_sequence(i), i);
							}
							else
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: ensured that all axes (%d) with same Sequence(%d) startmask was set (%d) \n", i, PEv2_home_sequence(i), HomingStartMaskSetup);
							}
						}
						else if (intAxesState == PK_PEAxisState_axHOME && PEv2_AxesCommand(i) == PK_PEAxisCommand_axHOMINGFinalize)
						{
							int MyHomeSequ, seq;
							MyHomeSequ = PEv2_home_sequence(i);
							HomingStartMaskSetup = (1 << i); // Home my axis only (bit MyHomeSequ)
							rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: ensurinig that all axes (%d) with same Sequence(%d) startmask initialized (%d) \n", i, PEv2_home_sequence(i), HomingStartMaskSetup);

							// ensure that all axes with same Sequence start homing at the same time
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: ensure that all axes with same Sequence start homing at the same time\n", __FILE__, __FUNCTION__);
							int j_count = 0;
							for (seq = 0; seq < PEv2_nrOfAxes; seq++)
							{

								if (PEv2_home_sequence(seq) == PEv2_home_sequence(i))
								{
									//	rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: ensure that all axes (%d) with same Sequence(%d) start homing at the same time \n", seq, PEv2_home_sequence(i));

									HomingStartMaskSetup |= (1 << seq); // Home axis seq only (bit seq)
									j_count++;
									doHomingEnd = true;
								}
							}

							if (j_count == 0)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: no axes with same Sequence(%d) as joint(%d) found \n", PEv2_home_sequence(i), i);
							}
							else
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: ensured that all axes (%d) with same Sequence(%d) startmask was set (%d) \n", i, PEv2_home_sequence(i), HomingStartMaskSetup);
							}
							
						}
						else if (PEv2_AxesCommand(i) == PK_PEAxisCommand_axHOMINGCANCEL && old_PEv2_AxesCommand[i] != PEv2_AxesCommand(i) && (intAxesState == PK_PEAxisState_axHOMINGSTART || intAxesState == PK_PEAxisState_axHOMINGSEARCH || intAxesState == PK_PEAxisState_axHOMINGBACK))
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Trigger HomingCancel\n", __FILE__, __FUNCTION__);
							//	dev->PEv2.PulseEngineStateSetup = PK_PEState_peSTOPPED;
						}
						old_PEv2_AxesCommand[i] = PEv2_AxesCommand(i);

						tAxisEnabledMask = Set_BitOfByte(tAxisEnabledMask, i, PEv2_digout_AxisEnabled_out(i));
						PEv2_LimitOverrideSetup = Set_BitOfByte(PEv2_LimitOverrideSetup, i, PEv2_digout_LimitOverride_out(i));
						PEv2_deb_axxisout(i) = 2900 + i;
						POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
						PEv2_deb_axxisout(i) = 29000 + i;

						if (PEv2_joint_in_position(i) != 0)
						{
							InPosition[i] = true;
						}
						else
						{
							InPosition[i] = false;
						}
						PEv2_deb_ishoming(i) = IsHoming[i];
						PEv2_deb_inposition(i) = InPosition[i];

						if (HAL_Machine_On != 0)
						{
							PEv2_deb_out = 390 + i;
							posMode[i] = false;
							if (IsHoming[i] == false)
							{
								float VelCmd = PEv2_joint_vel_cmd(i);
								float PosCmd = PEv2_joint_pos_cmd(i);

								PEv2_deb_out = 400 + i;

								float ReferenceSpeed;
								float ReferencePosition;
								PEv2_deb_axxisout(i) = 1000;

								if (StepScale[i] != 0)
								{
									PEv2_deb_axxisout(i) = 1100 + i;
									ReferenceSpeed = VelCmd * StepScale[i];
									PEv2_deb_axxisout(i) = 1110 + i;
									ReferencePosition = PosCmd * StepScale[i];
									PEv2_deb_axxisout(i) = 1120 + i;
								}
								else
								{
									PEv2_deb_axxisout(i) = 1200 + i;
									ReferenceSpeed = VelCmd;
									PEv2_deb_axxisout(i) = 1210 + i;
									ReferencePosition = PosCmd;
									PEv2_deb_axxisout(i) = 1220 + i;
								}

								/*
								for the last short move before in-position is reached switch to positionmode for more precise positioning
								*/
								if ((InPosition[i] == true) && (dev->PEv2.CurrentPosition[i] != (int32_t)ReferencePosition))
								{
									InPosition[i] = false;
								}
								if (InPosition[i] = false)
								{
									dev->PEv2.param1 = i;
									PK_PEv2_AxisConfigurationGet(dev);
									POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);

									dev->PEv2.param1 = i;
									PK_PEv2_AxisConfigurationGet(dev);
									POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);

									if ((ReferenceSpeed = 0))
									{
										posMode[i] = true;

										dev->PEv2.param1 = i;
										PK_PEv2_AxisConfigurationGet(dev);
										POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);

										if ((POSITION_MODE_active[i] == false))
										{
											posCount[i]++;
											// first ensure stopped Axis
											if (dev->PEv2.ReferencePositionSpeed[i] != 0)
											{
												dev->PEv2.ReferencePositionSpeed[i] = 0;
												PK_PEv2_PulseEngineMove(dev);
											}

											// then switch to Position Mode
											dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, true);
											dev->PEv2.param1 = i;

											if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK)
											{
												PK_PEv2_AxisConfigurationSet(dev);
											}
										}
										else
										{
											posCount[i] += 1000;
										}
									}
									else
									{
										posCount[i] += 100000;
									}
								}
								else
								{
									// posMode[i] = false;
									dev->PEv2.param1 = i;
									PK_PEv2_AxisConfigurationGet(dev);
									POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);

									if (POSITION_MODE_active[i] == true)
									{
										velCount[i]++;
										dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
										dev->PEv2.param1 = i;
										if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK)
										{
											PK_PEv2_AxisConfigurationSet(dev);
										}

										posMode[i] = false;
									}
								}

								dev->PEv2.param1 = i;
								PK_PEv2_AxisConfigurationGet(dev);
								POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
								dev->PEv2.param1 = i;
								PK_PEv2_AxisConfigurationGet(dev);
								POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
								PEv2_deb_posmode_count(i) = posCount[i];
								PEv2_deb_velmode_count(i) = velCount[i];
								PEv2_deb_axxisout(i) = 1300 + i;
								PEv2_deb_RefSpeed(i) = ReferenceSpeed;
								PEv2_deb_RefPos(i) = ReferencePosition;
								PEv2_deb_PosMode(i) = posMode[i];
								PEv2_deb_PosModeAct(i) = POSITION_MODE_active[i];

								if (POSITION_MODE_active[i] == true)
								{
									PEv2_deb_axxisout(i) = 13100 + i;
									if (InPosition[i] == false)
									{
										if (last_joint_pos_cmd[i] != PEv2_joint_pos_cmd(i))
										{
											PEv2_deb_axxisout(i) = 1310 + i;
											dev->PEv2.ReferencePositionSpeed[i] = (int32_t)ReferencePosition;
											PEv2_ReferencePositionSpeed(i) = (int)ReferencePosition;
											PEv2_deb_axxisout(i) = 1320 + i;
											last_joint_pos_cmd[i] = PEv2_joint_pos_cmd(i);
											if (dev->PEv2.AxesState[i] == PK_PEAxisState_axREADY || dev->PEv2.AxesState[i] == PK_PEAxisState_axSTOPPED)
											{
												// PK_PEv2_PulseEngineMove(dev);
												doMove = true;
												PEv2_deb_axxisout(i) = 1330 + i;
											}
											else
											{
												PEv2_deb_axxisout(i) = 1340 + i;
											}
										}
									}
									else
									{

										PEv2_deb_axxisout(i) = 1600 + i;
										if (dev->PEv2.ReferencePositionSpeed[i] != dev->PEv2.CurrentPosition[i])
										{
											PEv2_deb_axxisout(i) = 160 + i;
											dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
											dev->PEv2.param1 = i;
											PK_PEv2_AxisConfigurationSet(dev);

											dev->PEv2.ReferencePositionSpeed[i] = 0;
											PEv2_ReferencePositionSpeed(i) = 0;
											last_joint_vel_cmd[i] = 0;
											doMove = true;
											// PEv2_joint_pos_fb(i) = PEv2_joint_pos_cmd(i);
										}

										POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
										if (POSITION_MODE_active[i] = true)
										{
											dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
											dev->PEv2.param1 = i;
											PK_PEv2_AxisConfigurationSet(dev);
											PK_PEv2_AxisConfigurationSet(dev);

											// if (PK_PEv2_AxisConfigurationSet(dev) = PK_OK)
											//{
											dev->PEv2.ReferencePositionSpeed[i] = 0;
											PEv2_ReferencePositionSpeed(i) = 0;
											last_joint_vel_cmd[i] = 0;
											doMove = true;
											//}
											/*else
											{
												dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
												dev->PEv2.param1 = i;
												PK_PEv2_AxisConfigurationSet(dev);
												dev->PEv2.ReferencePositionSpeed[i] = 0;
												PEv2_ReferencePositionSpeed(i) = 0;
												last_joint_vel_cmd[i] = 0;
												doMove = true;
											}*/
										}
									}
								}
								else
								{
									if (InPosition[i] != true)
									{
										PEv2_deb_axxisout(i) = 14100 + i;
										if (last_joint_vel_cmd[i] != PEv2_joint_vel_cmd(i))
										{
											PEv2_deb_axxisout(i) = 1410 + i;

											dev->PEv2.ReferencePositionSpeed[i] = (int32_t)ReferenceSpeed;
											PEv2_ReferencePositionSpeed(i) = (int)ReferenceSpeed;
											PEv2_deb_axxisout(i) = 1420 + i;
											last_joint_vel_cmd[i] = PEv2_joint_vel_cmd(i);
											if (dev->PEv2.AxesState[i] == PK_PEAxisState_axRUNNING || dev->PEv2.AxesState[i] == PK_PEAxisState_axREADY)
											{

												doMove = true;
												PEv2_deb_axxisout(i) = 1430 + i;
											}
											else
											{
												PEv2_deb_axxisout(i) = 1440 + i;
											}
										}
										else
										{
											PEv2_deb_axxisout(i) = 1450 + i;
										}
									}
									else
									{
										PEv2_deb_axxisout(i) = 1700 + i;
										// InPosition -> StopAxis
										if (dev->PEv2.ReferencePositionSpeed[i] != 0)
										{
											dev->PEv2.ReferencePositionSpeed[i] = 0;
											PEv2_ReferencePositionSpeed(i) = 0;
											last_joint_vel_cmd[i] = 0;
											doMove = true;
											// PEv2_joint_pos_fb(i) = PEv2_joint_pos_cmd(i);
										}
									}
								}
							}
							else
							{
								PEv2_deb_axxisout(i) = 2400 + i;
								// dev->PEv2.ReferencePositionSpeed[i]=0;
								switch (intAxesState)
								{
								case PK_PEAxisState_axHOMING_RESETTING: // Stopping the axis to reset the position counters
									// PEv2_AxisLimitOverride(i) = true;
									// PEv2_digin_AxisEnabled_in(i) = true;
									break;
								case PK_PEAxisState_axHOMING_BACKING_OFF: // Backing off switch
									// PEv2_AxisLimitOverride(i) = true;
									// PEv2_digin_AxisEnabled_in(i) = true;
									break;
								case PK_PEAxisState_axHOME: // Axis is homed
									// PEv2_digin_AxisEnabled_in(i) = true;
									// PEv2_AxisLimitOverride(i) = true;
									//  PEv2_joint_
									break;
								case PK_PEAxisState_axHOMINGSTART: // Homing procedure is starting on axis
									// PEv2_digin_AxisEnabled_in(i) = true;
									// PEv2_AxisLimitOverride(i) = true;
									break;
								case PK_PEAxisState_axHOMINGSEARCH: // Homing procedure first step - going to home
									// PEv2_digin_AxisEnabled_in(i) = true;
									// PEv2_AxisLimitOverride(i) = true;
									break;
								case PK_PEAxisState_axHOMINGBACK: // Homing procedure second step - slow homing
									// PEv2_digin_AxisEnabled_in(i) = true;
									// PEv2_AxisLimitOverride(i) = true;
									break;

								default:
									// dev->PEv2.PulseEngineStateSetup = PK_PEAxisState_axHOMINGSTART;

									break;
								}
								PEv2_deb_axxisout(i) = 2410 + i;
							}
						}
						else
						{
							PEv2_deb_out = 3900 + i;
						}

						PEv2_deb_doMove(i) = doMove;
						PEv2_deb_RefPosSpeed(i) = dev->PEv2.ReferencePositionSpeed[i];
					}

					if (tAxisEnabledMask != dev->PEv2.AxisEnabledMask)
					{
						dev->PEv2.AxisEnabledMask = tAxisEnabledMask;
						doStateSet = true;
					}
					if (PEv2_LimitOverrideSetup != dev->PEv2.LimitOverrideSetup)
					{
						dev->PEv2.LimitOverrideSetup = PEv2_LimitOverrideSetup;
						doStateSet = true;
					}
				}

				if (PK_PEv2_ExternalOutputsGet(dev) == PK_OK)
				{
					PEv2_ExternalRelayOutputs = dev->PEv2.ExternalRelayOutputs;
					PEv2_ExternalOCOutputs = dev->PEv2.ExternalOCOutputs;
				}

				if (PEv2_PG_extended_io != false)
				{


					uint8_t ExternalRelayOutputs_set = 0;
					uint8_t ExternalOCOutputs_set = 0;

					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 7, PEv2_digout_ExternalRelay_out(0));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 0, PEv2_digout_ExternalRelay_out(1));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 2, PEv2_digout_ExternalRelay_out(2));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 1, PEv2_digout_ExternalRelay_out(3));

					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 3, PEv2_digout_ExternalOC_out(0));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 4, PEv2_digout_ExternalOC_out(1));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 5, PEv2_digout_ExternalOC_out(2));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set, 6, PEv2_digout_ExternalOC_out(3));

					if (ExternalOCOutputs_set != dev->PEv2.ExternalOCOutputs)
					{
						dev->PEv2.ExternalOCOutputs = ExternalOCOutputs_set;
						PK_PEv2_ExternalOutputsSet(dev);
						PK_PEv2_ExternalOutputsSet(dev);
					}
				}
				if (dev->PEv2.HomingStartMaskSetup != HomingStartMaskSetup && HomingStartMaskSetup != 0 && doHomingStart)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: Startmask at trigger (%d) \n", HomingStartMaskSetup);

					PEv2_deb_axxisout(i) = 5100;
					dev->PEv2.HomingStartMaskSetup = HomingStartMaskSetup;
					PK_PEv2_HomingStart(dev);
					Homing_active = true;
				}
				else if(dev->PEv2.HomingStartMaskSetup != HomingStartMaskSetup && HomingStartMaskSetup != 0 && doHomingEnd)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PK_HOMING: Startmask at trigger (%d) \n", HomingStartMaskSetup);

					PEv2_deb_axxisout(i) = 5100;
					dev->PEv2.HomingStartMaskSetup = HomingStartMaskSetup;
					//PK_PEv2_HomingStart(dev);
					PK_PEv2_HomingFinish(dev);
					Homing_active = true;
				}
				else if (PulseEngineState != PEv2_PulseEngineStateSetup && doHomingStart == 0)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PK_PEv2: PEv2_PulseEngineStateSetup (%d) \n", PEv2_PulseEngineStateSetup);
					dev->PEv2.PulseEngineStateSetup = PEv2_PulseEngineStateSetup;
					// dev->PEv2.AxisEnabledMask = PEv2_AxisEnabledMask;
					doStateSet = true;
				}
				/*	else if (rtc_loopcount==0 && Homing_active!=true)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PK_PEv2: PEv2_PulseEngineStateSetup(rtc_loopcount) (%d) \n", PEv2_PulseEngineStateSetup);
					//	dev->PEv2.PulseEngineStateSetup = PEv2_PulseEngineStateSetup;
						//dev->PEv2.AxisEnabledMask = PEv2_AxisEnabledMask;
					//	doStateSet=true;
					}*/

				if (PEv2_LimitOverrideSetup != dev->PEv2.LimitOverrideSetup)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PK_PEv2: PEv2_LimitOverrideSetup (%d) \n", PEv2_LimitOverrideSetup);
					dev->PEv2.LimitOverrideSetup = PEv2_LimitOverrideSetup;
					doStateSet = true;
				}

				if (doStateSet == true)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PK_PEv2: PEv2_PulseEngineStateSet (%d) \n", dev->PEv2.PulseEngineStateSetup);

					if (PK_PEv2_PulseEngineStateSet(dev) != PK_OK)
					{
						usleep(sleepdur);
						if (PK_PEv2_PulseEngineStateSet(dev) != PK_OK)
						{
							usleep(sleepdur);
						}
					}
				}

				if (doMove == true)
				{
					PEv2_deb_out = 4000;
					rtapi_print_msg(RTAPI_MSG_DBG, "PK_PEv2: PEv2_PulseEngineMove  \n");
					if (PK_PEv2_PulseEngineMove(dev) != PK_OK)
					{
						PEv2_deb_out = 4200;
						usleep(sleepdur);
						if (PK_PEv2_PulseEngineMove(dev) != PK_OK)
						{
							usleep(sleepdur);
						}
					}
					else
					{
						PEv2_deb_out = 4500;
					}
				}


				deb_out = 224;
			}


			

			bool EncoderValuesGet = false;

	

			PKEncoder_Update(dev);
			deb_out = 220;
			usleep(sleepdur);

		PKIO_Update(dev);
		deb_out = 230;
		usleep(sleepdur);


			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PEv2_PulseEngineEnabled = %d\n", __FILE__, __FUNCTION__, PEv2_PulseEngineEnabled);
			if (PEv2_PulseEngineEnabled != 0)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PulseEngineState = %d\n", __FILE__, __FUNCTION__, dev->PEv2.PulseEngineState);
				if (dev->PEv2.PulseEngineState == PK_PEState_peSTOP_EMERGENCY)
				{
					PEv2_digin_Emergency_in = false;
					PEv2_digin_Emergency_in_not = true;
				}
				else
				{
					PEv2_digin_Emergency_in = true;
					PEv2_digin_Emergency_in_not = false;
				}
			}

	

			//rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: info_PoExtBus = %d\n", __FILE__, __FUNCTION__, info_PoExtBus);
			PKPoExtBus_Update(dev);
			deb_out = 238;
			usleep(sleepdur);

			//rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: info_PoNET = %d\n", __FILE__, __FUNCTION__, info_PoNET);
			PKPoNet_Update(dev);
			deb_out = 239;
			usleep(sleepdur);

	if (rtc_lastmin != rtc_min )
	{
		rtc_lastmin = rtc_min;
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: rtc_lastmin = %d\n", __FILE__, __FUNCTION__, rtc_lastmin);
	
			if (HAL_Machine_On == false)
			{
				alive = 0;

				deb_out = 310;
				

				info_PinCount = dev->info.iPinCount;											 // Number of pins, physically on the device
				info_PWMCount = dev->info.iPWMCount;											 // Number of pins that support PWM output
				info_BasicEncoderCount = dev->info.iBasicEncoderCount;							 // Number of basic encoders
				info_EncodersCount = dev->info.iEncodersCount;									 // Number of encoder slots available
				info_FastEncoders = dev->info.iFastEncoders;									 // Number of fast encoders supported
				info_UltraFastEncoders = dev->info.iUltraFastEncoders;							 // Number of available ultra fast encoders
				info_PWMinternalFrequency = dev->info.PWMinternalFrequency;						 // Main PWM peripheral clock
				info_AnalogInputs = dev->info.iAnalogInputs;									 // Number of available analog inputs
				info_KeyMapping = dev->info.iKeyMapping;										 // Device supports key mapping (acts as a USB keyboard)
				info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;						 // Device supports triggered key mapping
				info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;								 // Device supports user customizable key repeat rates and delays
				info_DigitalCounters = dev->info.iDigitalCounters;								 // Device supports digital counters
				info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;			 // Device supports mapping of joystick buttons
				info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping; // Device supports mapping of analog inputs to digital keys
				info_Macros = dev->info.iMacros;												 // Device supports customizable macro sequences
				info_MatrixKeyboard = dev->info.iMatrixKeyboard;								 // Device supports matrix keyboard
				info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping; // Device supports matrix keyboard triggered key mapping
				info_LCD = dev->info.iLCD;														 // Device supports alphanumeric LCD display
				info_MatrixLED = dev->info.iMatrixLED;											 // Device supports matrix LED display
				info_ConnectionSignal = dev->info.iConnectionSignal;							 // Device supports connection signal output
				info_PoExtBus = dev->info.iPoExtBus;											 // Device supports PoExtBus digital outputs
				info_PoNET = dev->info.iPoNET;													 // Device supports PoNET bus devices
				info_AnalogFiltering = dev->info.iAnalogFiltering;								 // Device supports analog inputs low-pass digital filtering
				info_InitOutputsStart = dev->info.iInitOutputsStart;							 // Device supports initializing outputs at startup
				info_protI2C = dev->info.iprotI2C;												 // Device supports I2C bus (master)
				info_prot1wire = dev->info.iprot1wire;											 // Device supports 1-wire bus (master)
				info_AdditionalOptions = dev->info.iAdditionalOptions;							 // Device supports additional options with activation keys
				info_LoadStatus = dev->info.iLoadStatus;										 // Device supports reporting load status
				info_CustomDeviceName = dev->info.iCustomDeviceName;							 // Device supports specifying custom device names
				info_PoTLog27support = dev->info.iPoTLog27support;								 // Device supports PoTLog27 firmware
				info_SensorList = dev->info.iSensorList;										 // Device supports sensor lists
				info_WebInterface = dev->info.iWebInterface;									 // Device supports web interface
				info_FailSafeSettings = dev->info.iFailSafeSettings;							 // Device supports fail-safe mode
				info_JoystickHATswitch = dev->info.iJoystickHATswitch;							 // Device supports joystick HAT switch mapping
				info_PulseEngine = dev->info.iPulseEngine;										 // Device supports Pulse engine
				info_PulseEnginev2 = dev->info.iPulseEnginev2;									 // Device supports Pulse engine v2
				info_EasySensors = dev->info.iEasySensors;										 // Device supports EasySensors
				deb_out = 311;

				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PulseEnginev2 = %d\n", __FILE__, __FUNCTION__, info_PulseEnginev2);
				if (info_PulseEnginev2 != 0)
				{
					bool DoPeSetup = false;
					bool DoPeReboot = false;
					setPinConfig = false;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_params_ApplyIniSettings = %d\n", __FILE__, __FUNCTION__, PEv2_params_ApplyIniSettings);
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: HAL_Machine_On = %d\n", __FILE__, __FUNCTION__, HAL_Machine_On);
					if ((PEv2_params_ApplyIniSettings != 0) && (HAL_Machine_On == 0))
					{
						// dev->PEv2.AxisEnabledStatesMask=0; //Disable axis power when not in Running state
						// PK_PEv2_PulseEngineSetup(dev);
						usleep(sleepdur);
						if (PEv2_digin_Probe_Pin != 0)
						{ // check if pin is parametrized in HAL
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev->Pins[%d].PinFunction = %d\n", __FILE__, __FUNCTION__, PEv2_digin_Probe_Pin - 1, dev->Pins[PEv2_digin_Probe_Pin - 1].PinFunction);
							if (dev->Pins[PEv2_digin_Probe_Pin - 1].PinFunction != PK_PinCap_digitalInput)
							{
								dev->Pins[PEv2_digin_Probe_Pin - 1].PinFunction = PK_PinCap_digitalInput;
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SL_SetPinFunction(dev, %d, PK_PinCap_digitalInput)\n", __FILE__, __FUNCTION__, PEv2_digin_Probe_Pin - 1);
								PK_SL_SetPinFunction(dev, PEv2_digin_Probe_Pin - 1, PK_PinCap_digitalInput);
								setPinConfig = true;
							}
						}

						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2.EmergencyInputPin = %d\n", __FILE__, __FUNCTION__, dev->PEv2.EmergencyInputPin);
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_digin_Emergency_Pin = %d\n", __FILE__, __FUNCTION__, PEv2_digin_Emergency_Pin);
						if (dev->PEv2.EmergencyInputPin != PEv2_digin_Emergency_Pin)
						{
							dev->PEv2.EmergencyInputPin = PEv2_digin_Emergency_Pin;
							DoPeSetup = true;
							if (PEv2_digin_Emergency_Pin != 0)
							{ // check if pin is parametrized in HAL
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev->Pins[%d].PinFunction = %d\n", __FILE__, __FUNCTION__, PEv2_digin_Emergency_Pin - 1, dev->Pins[PEv2_digin_Emergency_Pin - 1].PinFunction);
								dev->Pins[PEv2_digin_Emergency_Pin - 1].PinFunction = PK_PinCap_digitalInput;
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SL_SetPinFunction(dev, %d, PK_PinCap_digitalInput)\n", __FILE__, __FUNCTION__, PEv2_digin_Emergency_Pin - 1);
								PK_SL_SetPinFunction(dev, PEv2_digin_Emergency_Pin - 1, PK_PinCap_digitalInput);

								setPinConfig = true;
							}
						}

						if (PEv2_digout_Emergency_Pin != 0)
						{ // check if pin is parametrized in HAL
							if (dev->Pins[PEv2_digout_Emergency_Pin - 1].PinFunction != PK_PinCap_digitalOutput)
							{
								dev->Pins[PEv2_digout_Emergency_Pin - 1].PinFunction = PK_PinCap_digitalOutput;
								PK_SL_SetPinFunction(dev, PEv2_digin_Emergency_Pin - 1, PK_PinCap_digitalOutput);
								Pins_DigitalValueSet_ignore[PEv2_digin_Emergency_Pin - 1] = true;
								setPinConfig = true;
							}
						}

						if (dev->PEv2.PulseEngineEnabled != dev->PEv2.info.nrOfAxes)
						{
							dev->PEv2.PulseEngineEnabled = dev->PEv2.info.nrOfAxes;
							PEv2_PulseEngineEnabled = dev->PEv2.info.nrOfAxes;
							DoPeSetup = true;
						}

						if (PEv2_PulseEngineEnabled != 0)
						{
							dev->PEv2.PulseEngineActivated = 1;
							DoPeSetup = true;
						}
						if (PEv2_PulseGeneratorType == 0)
						{

							if (PEv2_PG_swap_stepdir != false)
							{
								PEv2_PulseGeneratorType = Set_BitOfByte(PEv2_PulseGeneratorType, 6, true); // swap step / dir signals
								DoPeSetup = true;
							}

							if (PEv2_PG_extended_io != false)
							{
								PEv2_PulseGeneratorType = Set_BitOfByte(PEv2_PulseGeneratorType, 7, true); // extended io
								DoPeSetup = true;
							}
						}

						if (dev->PEv2.ChargePumpEnabled != PEv2_ChargePumpEnabled)
						{
							dev->PEv2.ChargePumpEnabled = PEv2_ChargePumpEnabled;
							DoPeSetup = true;
						}
						if (dev->PEv2.PulseGeneratorType != PEv2_PulseGeneratorType)
						{
							dev->PEv2.PulseGeneratorType = PEv2_PulseGeneratorType;
							DoPeSetup = true;
						}
						if (dev->PEv2.EmergencySwitchPolarity != PEv2_digin_Emergency_invert)
						{
							dev->PEv2.EmergencySwitchPolarity = PEv2_digin_Emergency_invert;
							DoPeSetup = true;
						}
						// dev->PEv2.PulseEngineBufferSize = PEv2_stepgen_PulseEngineBufferSize;

						// dev->PEv2.AxisEnabledStatesMask = PEv2_stepgen_AxisEnabledStatesMask;
						if (DoPeSetup == true)
						{
							if (PK_PEv2_PulseEngineSetup(dev) != PK_OK)
							{
								usleep(sleepdur);
							}

							if (PK_PEv2_PulseEngineSetup(dev) == PK_OK)
							{
								usleep(sleepdur);
							}
							if (DoPeReboot == true)
							{
								PK_PEv2_PulseEngineReboot(dev);
								usleep(1000000);
							}
						}
					}
					else
					{
						if (PK_PEv2_StatusGet(dev) == PK_OK && PK_PEv2_Status2Get(dev) == PK_OK)
						{
							PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
							PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
							PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;
							// PEv2_stepgen_PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
							PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
							// PEv2_stepgen_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;

							PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
							PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
							PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;
							// PEv2_stepgen_PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
							PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
							// PEv2_stepgen_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
						}

						if (PK_PEv2_AdditionalParametersGet(dev) == PK_OK)
						{
							PEv2_digin_Emergency_Pin = dev->PEv2.EmergencyInputPin;
							usleep(sleepdur);
						}
					}

					uint8_t AxesConfig[8];
					uint8_t AxesSwitchConfig[8];
					for (i = 0; i < dev->PEv2.info.nrOfAxes; i++)
					{
						if (PEv2_params_ApplyIniSettings != 0)
						{
							bool doAxisConfig = false;
							// Convert mm/s -> pulses/s
							/* read parameters for Axis configuration - see ePK_PEv2_AxisConfig
							PK_AC_ENABLED            = (1 << 0),       // 1 Axis enabled
							PK_AC_INVERTED           = (1 << 1),       // 2 Axis inverted
							PK_AC_INTERNAL_PLANNER   = (1 << 2),       // 4 Axis uses internal motion planner
							PK_AC_POSITION_MODE      = (1 << 3),       // 8 Internal motion planner for this axis is in position mode
							PK_AC_INVERTED_HOME      = (1 << 4),       // 16 Axis homing direction is inverted
							PK_AC_SOFT_LIMIT_ENABLED = (1 << 5),       // 32 Use soft-limits for this axis
							PK_AC_ENABLED_MASKED     = (1 << 7)        // 128 Use output enable pin masking

							pin out unsigned PEv2.#.AxesConfig[8];				// Axis configuration - see ePK_PEv2_AxisConfig
							param rw s32 PEv2.#.AxisEnabled[8] "Axis enabled";
							param rw s32 PEv2.#.AxisInverted[8] "Axis inverted";
							param rw s32 PEv2.#.AxisInternalPlanner[8] "Axis uses internal motion planner";
							param rw s32 PEv2.#.AxisPositionMode[8] "Internal motion planner for this axis is in position mode";
							param rw s32 PEv2.#.AxisInvertedHome[8] "Axis homing direction is inverted";
							param rw s32 PEv2.#.AxisSoftLimitEnabled[8] "Use soft-limits for this axis";
							param rw s32 PEv2.#.AxisEnabledMasked[8] "Use output enable pin masking";
							 */
							AxesConfig[i] = 0;
							if (PEv2_AxisEnabled(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 0, true); // PK_AC_ENABLED ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 0, false); // PK_AC_ENABLED ;
							}
							if (PEv2_AxisInverted(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 1, true); // PK_AC_INVERTED ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 1, false); // PK_AC_INVERTED ;
							}
							if (PEv2_AxisInternalPlanner(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 2, true); // PK_AC_INTERNAL_PLANNER ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 2, false); // PK_AC_INTERNAL_PLANNER ;
							}
							if (PEv2_AxisPositionMode(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 3, true); // PK_AC_POSITION_MODE ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 3, false); // PK_AC_POSITION_MODE ;
							}
							if (PEv2_AxisInvertedHome(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 4, true); // PK_AC_INVERTED_HOME ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 4, false); // PK_AC_INVERTED_HOME ;
							}
							if (PEv2_AxisSoftLimitEnabled(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 5, true); // PK_AC_SOFT_LIMIT_ENABLED ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 5, false); // PK_AC_SOFT_LIMIT_ENABLED ;
							}
							if (PEv2_AxisEnabledMasked(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 7, true); // PK_AC_ENABLED_MASKED ;
							}
							else
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 7, false); // PK_AC_ENABLED_MASKED ;
							}
							/* PEv2_AxesSwitchConfig
							PK_ASO_SWITCH_LIMIT_N: 1 << 0 = 1
							PK_ASO_SWITCH_LIMIT_P : 1 << 1 = 2
							PK_ASO_SWITCH_HOME : 1 << 2 = 4
							PK_ASO_SWITCH_COMBINED_LN_H : 1 << 3 = 8
							PK_ASO_SWITCH_COMBINED_LP_H : 1 << 4 = 16
							PK_ASO_SWITCH_INVERT_LIMIT_N : 1 << 5 = 32
							PK_ASO_SWITCH_INVERT_LIMIT_P : 1 << 6 = 64
							PK_ASO_SWITCH_INVERT_HOME : 1 << 7 = 128

							param rw unsigned PEv2.#.AxesSwitchConfig[8];		// Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions
							param rw bit PEv2.#.digin.LimitN.Enabled[8] "Limit- is available (PK_ASO_SWITCH_LIMIT_N)";
							param rw bit PEv2.#.digin.LimitP.Enabled[8] "Limit+ is available (PK_ASO_SWITCH_LIMIT_P)";
							param rw bit PEv2.#.digin.Home.Enabled[8] "Invert home-switch (PK_ASO_SWITCH_HOME)";
							param rw bit PEv2.#.digin.Home.OnLimitN[8] "Shared with Limit- (PK_ASO_SWITCH_COMBINED_LN_H)";
							param rw bit PEv2.#.digin.Home.OnLimitP[8] "Shared with Limit+ (PK_ASO_SWITCH_COMBINED_LP_H)";
							param rw bit PEv2.#.digin.LimitN.invert[8] "Invert limit- (PK_ASO_SWITCH_INVERT_LIMIT_N)";
							param rw bit PEv2.#.digin.LimitP.invert[8] "Invert limit+ (PK_ASO_SWITCH_INVERT_LIMIT_P)";
							param rw bit PEv2.#.digin.Home.invert[8] "Invert home-switch (PK_ASO_SWITCH_INVERT_HOME)";
							*/
							AxesSwitchConfig[i] = PEv2_AxesSwitchConfig(i); // initial value from ini file

							if (PEv2_digin_LimitN_Enabled(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 0, true); // PK_ASO_SWITCH_LIMIT_N ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 0, false); // PK_ASO_SWITCH_LIMIT_N ;
							}
							if (PEv2_digin_LimitP_Enabled(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 1, true); // PK_ASO_SWITCH_LIMIT_P ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 1, false); // PK_ASO_SWITCH_LIMIT_P ;
							}
							if (PEv2_digin_Home_Enabled(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 2, true); // PK_ASO_SWITCH_HOME ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 2, false); // PK_ASO_SWITCH_HOME ;
							}
							if (PEv2_digin_Home_OnLimitN(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 3, true); // PK_ASO_SWITCH_COMBINED_LN_H ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 3, false); // PK_ASO_SWITCH_COMBINED_LN_H ;
							}
							if (PEv2_digin_Home_OnLimitP(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 4, true); // PK_ASO_SWITCH_COMBINED_LP_H ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 4, false); // PK_ASO_SWITCH_COMBINED_LP_H ;
							}
							if (PEv2_digin_LimitN_invert(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 5, true); // PK_ASO_SWITCH_INVERT_LIMIT_N ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 5, false); // PK_ASO_SWITCH_INVERT_LIMIT_N ;
							}
							if (PEv2_digin_LimitP_invert(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 6, true); // PK_ASO_SWITCH_INVERT_LIMIT_P ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 6, false); // PK_ASO_SWITCH_INVERT_LIMIT_P ;
							}
							if (PEv2_digin_Home_invert(i) != 0)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 7, true); // PK_ASO_SWITCH_INVERT_HOME ;
							}
							else
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 7, false); // PK_ASO_SWITCH_INVERT_HOME ;
							}

							if (PEv2_stepgen_STEP_SCALE(i) != 0)
							{
								// need to ensure positve values for the following calculations otherwise machine will not move
								PEv2_MaxSpeed(i) = abs(PEv2_stepgen_STEPGEN_MAXVEL(i) * StepScale[i]);				 // Maximum axis speed convert (mm/s) to (pulses / s)
																
								PEv2_MaxAcceleration(i) = abs(PEv2_stepgen_STEPGEN_MAXACCEL(i) * StepScale[i]); // Maximum axis deceleration convert (mm/s) to (in pulses/s)
								
								PEv2_MaxDecceleration(i) = abs(PEv2_stepgen_STEPGEN_MAXACCEL(i) * StepScale[i]); // Maximum axis deceleration convert (mm/s) to (in pulses/s)

								float LimitOffset = 0.0;
								if (PEv2_stepgen_MAX_LIMIT(i) > PEv2_stepgen_MIN_LIMIT(i))
								{

									if (PEv2_stepgen_MIN_LIMIT(i) != abs(PEv2_stepgen_MIN_LIMIT(i)))
									{
										LimitOffset = abs(PEv2_stepgen_MIN_LIMIT(i)); // shift reference to 0 and make sure it is positive
									}

									PEv2_digin_SoftLimit_PosMax(i) = (PEv2_stepgen_MAX_LIMIT(i) + LimitOffset) * PEv2_stepgen_STEP_SCALE(i); // Soft limit maximum position
									PEv2_digin_SoftLimit_PosMin(i) = (PEv2_stepgen_MIN_LIMIT(i) + LimitOffset) * PEv2_stepgen_STEP_SCALE(i); // Soft limit minimum position
																																			 // AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 5, true);  // PK_AC_SOFT_LIMIT_ENABLED ;
								}
								else
								{
									if (PEv2_stepgen_MAX_LIMIT(i) != abs(PEv2_stepgen_MAX_LIMIT(i)))
									{
										LimitOffset = abs(PEv2_stepgen_MAX_LIMIT(i)); // shift reference to 0 and make sure it is positive
									}
									PEv2_digin_SoftLimit_PosMax(i) = (PEv2_stepgen_MIN_LIMIT(i) + LimitOffset) * PEv2_stepgen_STEP_SCALE(i); // Soft limit maximum position
									PEv2_digin_SoftLimit_PosMin(i) = (PEv2_stepgen_MAX_LIMIT(i) + LimitOffset) * PEv2_stepgen_STEP_SCALE(i); // Soft limit minimum position
																																			 // AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 1, true);  // PK_AC_INVERTED ;
																																			 // AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 5, true);  // PK_AC_SOFT_LIMIT_ENABLED ;
								}
								if (PEv2_digin_SoftLimit_PosMax(i) == PEv2_digin_SoftLimit_PosMin(i))
								{ // DISABLE SOFT LIMITS
								  //  AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 5, false);  // PK_AC_SOFT_LIMIT_ENABLED ;
									doAxisConfig = true;
								}

								PEv2_digin_Home_Offset(i) = PEv2_stepgen_HOME_OFFSET(i) * PEv2_stepgen_STEP_SCALE(i); // Home position offset

								if (PEv2_stepgen_HOME_SEARCH_VEL(i) > 0 && PEv2_stepgen_STEPGEN_MAXVEL(i) > 0)
								{
									PEv2_HomingSpeed(i) = abs(PEv2_stepgen_HOME_SEARCH_VEL(i) * 100 / PEv2_stepgen_STEPGEN_MAXVEL(i));		 // Homing speed per axis (in %)
									PEv2_HomingReturnSpeed(i) = abs(PEv2_stepgen_HOME_LATCH_VEL(i) * 100 / PEv2_stepgen_HOME_SEARCH_VEL(i)); // Homing return speed per axis (in % of the homing speed)
								}
								else
								{
									PEv2_HomingSpeed(i) = 30;
									PEv2_HomingReturnSpeed(i) = 50;
								}
								// Convert parameters... assume little-endian format
								if (dev->PEv2.MaxSpeed[i] != (PEv2_MaxSpeed(i)/1000) && PEv2_MaxSpeed(i) > 0)
								{
									dev->PEv2.MaxSpeed[i] = PEv2_MaxSpeed(i)/1000;
									doAxisConfig = true;
								}
								else if (PEv2_MaxSpeed(i) == 0 && dev->PEv2.MaxSpeed[i] == 0)
								{
									dev->PEv2.MaxSpeed[i] = 1000;
									doAxisConfig = true;
								}
								
								if (dev->PEv2.MaxAcceleration[i] != PEv2_MaxDecceleration(i)/1000000) //smallest positive value
								{
									dev->PEv2.MaxAcceleration[i] = PEv2_MaxDecceleration(i)/1000000;
									doAxisConfig = true;
								}
								
								if (dev->PEv2.MaxDecceleration[i] != PEv2_MaxDecceleration(i)/1000000)
								{
									dev->PEv2.MaxDecceleration[i] = PEv2_MaxDecceleration(i)/1000000;
									doAxisConfig = true;
								}
								
								if (dev->PEv2.SoftLimitMinimum[i] != PEv2_digin_SoftLimit_PosMin(i))
								{
									dev->PEv2.SoftLimitMinimum[i] = PEv2_digin_SoftLimit_PosMin(i);
									doAxisConfig = true;
								}

								if (dev->PEv2.SoftLimitMaximum[i] != PEv2_digin_SoftLimit_PosMax(i))
								{
									dev->PEv2.SoftLimitMaximum[i] = PEv2_digin_SoftLimit_PosMax(i);
									doAxisConfig = true;
								}

								if (dev->PEv2.HomeOffsets[i] != PEv2_digin_Home_Offset(i))
								{
									dev->PEv2.HomeOffsets[i] = PEv2_digin_Home_Offset(i);
									doAxisConfig = true;
								}

								if (dev->PEv2.HomingSpeed[i] != PEv2_HomingSpeed(i))
								{
									dev->PEv2.HomingSpeed[i] = PEv2_HomingSpeed(i);
									doAxisConfig = true;
								}

								if (dev->PEv2.HomingReturnSpeed[i] != PEv2_HomingReturnSpeed(i))
								{
									dev->PEv2.HomingReturnSpeed[i] = PEv2_HomingReturnSpeed(i);
									doAxisConfig = true;
								}
							}

							// Read the structure and set the bits accordingly
							/*
								PK_AC_ENABLED            = (1 << 0),       // 1 Axis enabled
								PK_AC_INVERTED           = (1 << 1),       // 2 Axis inverted
								PK_AC_INTERNAL_PLANNER   = (1 << 2),       // 4 Axis uses internal motion planner
								PK_AC_POSITION_MODE      = (1 << 3),       // 8 Internal motion planner for this axis is in position mode
								PK_AC_INVERTED_HOME      = (1 << 4),       // 16 Axis homing direction is inverted
								PK_AC_SOFT_LIMIT_ENABLED = (1 << 5),       // 32 Use soft-limits for this axis
								PK_AC_ENABLED_MASKED     = (1 << 7)        // 128 Use output enable pin masking
							*/
							// PEv2_stepgen_AxesConfig(i) = PK_AC_ENABLED_MASKED;
							if (PEv2_stepgen_STEPGEN_MAXVEL(i) != 0)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 0, true); // PK_AC_ENABLED ;
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 2, true); // PK_AC_INTERNAL_PLANNER;
							}

							if (posMode[i] == true)
							{
								AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 3, true); // PK_AC_POSITION_MODE;
								// posMode[i] = true;
							}

							/*
								PK_ASO_SWITCH_LIMIT_N        = (1 << 0),   // 1 Limit- switch
								PK_ASO_SWITCH_LIMIT_P        = (1 << 1),   // 2 Limit+ switch
								PK_ASO_SWITCH_HOME           = (1 << 2),   // 4 Home switch
								PK_ASO_SWITCH_COMBINED_LN_H  = (1 << 3),   // 8 Home switch is shared with Limit- switch
								PK_ASO_SWITCH_COMBINED_LP_H  = (1 << 4),   // 16 Home switch is shared with Limit+ switch
								PK_ASO_SWITCH_INVERT_LIMIT_N = (1 << 5),   // 32 Invert limit- switch polarity
								PK_ASO_SWITCH_INVERT_LIMIT_P = (1 << 6),   // 64 Invert limit+ switch polarity
								PK_ASO_SWITCH_INVERT_HOME    = (1 << 7)    // 128 Invert home switch polarity
							*/

							/*
							if (PEv2_digin_SoftLimit_PosMax(i) !=  PEv2_digin_SoftLimit_PosMin(i))
							{
							   // AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 3, true); // PK_AC_SOFT_LIMIT_ENABLED;
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 3, true); // PK_AC_SOFT_LIMIT_ENABLED;
							}*/

							if (PEv2_digin_Home_Pin(i) != 0)
							{
								// path if pin (not dedicated) is used for home switch
								// check if pin is parametrized in HAL
								int Home = PEv2_digin_Home_Pin(i);
								int LimP = PEv2_digin_LimitP_Pin(i);
								int LimM = PEv2_digin_LimitN_Pin(i);

								if (Home != LimM && Home != LimP)
								{
									if (dev->PEv2.PinHomeSwitch[i] != Home)
									{
										dev->PEv2.PinHomeSwitch[i] = Home;
										doAxisConfig = true;
									}
								}
								else if (Home == LimP)
								{
									// dev->PEv2.PinHomeSwitch[i]=0;
									AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 4, true); // 16 Home switch is shared with Limit+ switch
								}
								else if (Home == LimM)
								{
									// dev->PEv2.PinHomeSwitch(i)=0;
									AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 3, true); // 8 Home switch is shared with Limit- switch
								}
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 2, true); // | PK_ASO_SWITCH_HOME;
								if (dev->Pins[Home - 1].PinFunction != PK_PinCap_digitalInput)
								{
									dev->Pins[Home - 1].PinFunction = PK_PinCap_digitalInput;
									PK_SL_SetPinFunction(dev, Home - 1, PK_PinCap_digitalInput);
									setPinConfig = true;
								}
							}
							else
							{
								dev->PEv2.PinHomeSwitch[i] = 0;
							}

							if (PEv2_digin_Home_invert(i) == true)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 7, true); // PK_ASO_SWITCH_INVERT_HOME    = (1 << 7)    // 128 Invert home switch polarity
								doAxisConfig = true;
							}

							if (dev->PEv2.PinLimitMSwitch[i] != PEv2_digin_LimitN_Pin(i))
							{
								dev->PEv2.PinLimitMSwitch[i] = PEv2_digin_LimitN_Pin(i);
								doAxisConfig = true;
							}
							if (PEv2_digin_LimitN_invert(i) == true)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 5, true); // PK_ASO_SWITCH_INVERT_LIMIT_N = (1 << 5),   // 32 Invert limit- switch polarity
								doAxisConfig = true;
							}
							if (PEv2_digin_LimitP_invert(i) == true)
							{
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 6, true); // PK_ASO_SWITCH_INVERT_LIMIT_P = (1 << 6),   // 64 Invert limit+ switch polarity
								doAxisConfig = true;
							}

							if (PEv2_digin_LimitN_Pin(i) != 0)
							{																	   // check if pin is parametrized in HAL
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 0, true); // | PK_ASO_SWITCH_LIMIT_N;

								if (dev->Pins[PEv2_digin_LimitN_Pin(i) - 1].PinFunction != PK_PinCap_digitalInput)
								{
									dev->Pins[PEv2_digin_LimitN_Pin(i) - 1].PinFunction = PK_PinCap_digitalInput;
									PK_SL_SetPinFunction(dev, PEv2_digin_LimitN_Pin(i) - 1, PK_PinCap_digitalInput);
									setPinConfig = true;
								}
							}

							if (dev->PEv2.PinLimitPSwitch[i] != PEv2_digin_LimitP_Pin(i))
							{
								dev->PEv2.PinLimitPSwitch[i] = PEv2_digin_LimitP_Pin(i);
								doAxisConfig = true;
							}

							if (PEv2_digin_LimitP_Pin(i) != 0)
							{																	   // check if pin is parametrized in HAL
								AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 1, true); // | PK_ASO_SWITCH_LIMIT_P;

								if (dev->Pins[PEv2_digin_LimitP_Pin(i) - 1].PinFunction != PK_PinCap_digitalInput)
								{
									dev->Pins[PEv2_digin_LimitP_Pin(i) - 1].PinFunction = PK_PinCap_digitalInput;
									PK_SL_SetPinFunction(dev, PEv2_digin_LimitP_Pin(i) - 1, PK_PinCap_digitalInput);
									setPinConfig = true;
								}
							}

							if (dev->PEv2.HomingSpeed[i] != PEv2_HomingSpeed(i))
							{
								dev->PEv2.HomingSpeed[i] = PEv2_HomingSpeed(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.HomingReturnSpeed[i] != PEv2_HomingReturnSpeed(i))
							{
								dev->PEv2.HomingReturnSpeed[i] = PEv2_HomingReturnSpeed(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.MPGjogEncoder[i] != PEv2_MPGjogEncoder(i))
							{
								dev->PEv2.MPGjogEncoder[i] = PEv2_MPGjogEncoder(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.MPGjogMultiplier[i] != PEv2_MPGjogMultiplier(i))
							{
								dev->PEv2.MPGjogMultiplier[i] = PEv2_MPGjogMultiplier(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.AxisEnableOutputPins[i] != PEv2_digout_AxisEnable_Pin(i))
							{
								dev->PEv2.AxisEnableOutputPins[i] = PEv2_digout_AxisEnable_Pin(i);
								doAxisConfig = true;
							}

							if (PEv2_digout_AxisEnable_Pin(i) != 0)
							{ // check if pin is parametrized in HAL
								if (dev->Pins[PEv2_digout_AxisEnable_Pin(i) - 1].PinFunction != PK_PinCap_digitalOutput)
								{
									dev->Pins[PEv2_digout_AxisEnable_Pin(i) - 1].PinFunction = PK_PinCap_digitalOutput;
									PK_SL_SetPinFunction(dev, PEv2_digout_AxisEnable_Pin(i) - 1, PK_PinCap_digitalOutput);
									setPinConfig = true;
								}
								Pins_DigitalValueSet_ignore[PEv2_digout_AxisEnable_Pin(i) - 1] = true;
							}

							if (dev->PEv2.InvertAxisEnable[i] != PEv2_digout_AxisEnable_invert(i))
							{
								dev->PEv2.InvertAxisEnable[i] = PEv2_digout_AxisEnable_invert(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.FilterLimitMSwitch[i] != PEv2_digin_LimitN_Filter(i))
							{
								dev->PEv2.FilterLimitMSwitch[i] = PEv2_digin_LimitN_Filter(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.FilterLimitPSwitch[i] != PEv2_digin_LimitP_Filter(i))
							{
								dev->PEv2.FilterLimitPSwitch[i] = PEv2_digin_LimitP_Filter(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.FilterHomeSwitch[i] != PEv2_digin_Home_Filter(i))
							{
								dev->PEv2.FilterHomeSwitch[i] = PEv2_digin_Home_Filter(i);
								doAxisConfig = true;
							}
							/*
							   param rw bit PEv2.#.HomeAlg.OnHome.Stop[8] "";
							   param rw bit PEv2.#.HomeAlg.OnHome.ArmEncoder[8] "";
							   param rw bit PEv2.#.HomeAlg.OnHome.RevDirection[8] "";
							   param rw bit PEv2.#.HomeAlg.OnHome.ReducedSpeed[8] "";
							   param rw bit PEv2.#.HomeAlg.OutHome.Stop[8] "";
							   param rw bit PEv2.#.HomeAlg.OutHome.ArmEncoder[8] "";
							   param rw bit PEv2.#.HomeAlg.OutHome.RevDirection[8] "";
							   param rw bit PEv2.#.HomeAlg.OutHome.ReducedSpeed[8] "";
							*/
							int HomingAlgorithm = 0;
							if (PEv2_HomeAlg_OnHome_Stop(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OnHomeStop;
							}
							if (PEv2_HomeAlg_OnHome_ArmEncoder(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OnHomeArmEncoder;
							}
							if (PEv2_HomeAlg_OnHome_RevDirection(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OnHomeReverseDirection;
							}
							if (PEv2_HomeAlg_OnHome_ReducedSpeed(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OnHomeReducedSpeed;
							}
							if (PEv2_HomeAlg_OutHome_Stop(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OutHomeStop;
							}
							if (PEv2_HomeAlg_OutHome_ArmEncoder(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OutHomeArmEncoder;
							}
							if (PEv2_HomeAlg_OutHome_RevDirection(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OutHomeReverseDirection;
							}
							if (PEv2_HomeAlg_OutHome_ReducedSpeed(i) != 0)
							{
								HomingAlgorithm |= PK_PEv2Homing_OutHomeReducedSpeed;
							}
							if (PEv2_HomingAlgorithm(i) != HomingAlgorithm)
							{
								PEv2_HomingAlgorithm(i) = HomingAlgorithm;
							}
							if (dev->PEv2.HomingAlgorithm[i] != HomingAlgorithm)
							{
								dev->PEv2.HomingAlgorithm[i] = HomingAlgorithm;
								doAxisConfig = true;
							}

							// MPG 1x mode here
							if (dev->PEv2.HomeBackOffDistance[i] != PEv2_HomeBackOffDistance(i))
							{
								dev->PEv2.HomeBackOffDistance[i] = PEv2_HomeBackOffDistance(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.MPGjogDivider[i] != PEv2_MPGjogDivider(i))
							{
								dev->PEv2.MPGjogDivider[i] = PEv2_MPGjogDivider(i);
								doAxisConfig = true;
							}

							if (dev->PEv2.AxesConfig[i] != AxesConfig[i])
							{
								dev->PEv2.AxesConfig[i] = AxesConfig[i];
								doAxisConfig = true;
							}

							// PEv2_AxesConfig(i) =AxesConfig[i]; Readonly!
							// PEv2_AxesSwitchConfig(i)=AxesSwitchConfig[i];
							if (dev->PEv2.AxesSwitchConfig[i] != AxesSwitchConfig[i])
							{
								dev->PEv2.AxesSwitchConfig[i] = AxesSwitchConfig[i];
								doAxisConfig = true;
							}

							// dev->PEv2.AxesConfig[i] = 0;
							// dev->PEv2.AxesSwitchConfig[i] =0;
							if (doAxisConfig == true)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_AxisConfigurationSet(%d)\n", __FILE__, __FUNCTION__, i);
								dev->PEv2.param1 = i;
								if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK)
								{
									usleep(sleepdur);
									dev->PEv2.param1 = i;
									if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK)
									{
										usleep(sleepdur);
									}
								}
							}
						}
						else
						{
							dev->PEv2.param1 = i;
							if (PK_PEv2_AxisConfigurationGet(dev) == PK_OK)
							{
								// Read the structure
								// PEv2_AxesConfig(i) = dev->PEv2.AxesConfig[i]; readonly
								// PEv2_AxesSwitchConfig(i)  = dev->PEv2.AxesSwitchConfig[i];

								// PEv2_digin_Home_Pin(i) = dev->PEv2.PinHomeSwitch[i];
								// PEv2_digin_LimitN_Pin(i) = dev->PEv2.PinLimitMSwitch[i];
								// PEv2_digin_LimitP_Pin(i) = dev->PEv2.PinLimitPSwitch[i];

								PEv2_HomingSpeed(i) = dev->PEv2.HomingSpeed[i];
								PEv2_HomingReturnSpeed(i) = dev->PEv2.HomingReturnSpeed[i];

								PEv2_MPGjogEncoder(i) = dev->PEv2.MPGjogEncoder[i];

								// Convert parameters... assume little-endian format
								PEv2_MaxSpeed(i) = dev->PEv2.MaxSpeed[i];
								PEv2_MaxAcceleration(i) = dev->PEv2.MaxAcceleration[i];
								PEv2_MaxDecceleration(i) = dev->PEv2.MaxDecceleration[i];

								PEv2_digin_SoftLimit_PosMin(i) = dev->PEv2.SoftLimitMinimum[i];
								PEv2_digin_SoftLimit_PosMax(i) = dev->PEv2.SoftLimitMaximum[i];

								PEv2_MPGjogMultiplier(i) = dev->PEv2.MPGjogMultiplier[i];

								// PEv2_digout_AxisEnable_Pin(i) = dev->PEv2.AxisEnableOutputPins[i];
								PEv2_digout_AxisEnable_invert(i) = dev->PEv2.InvertAxisEnable[i];

								PEv2_digin_LimitN_Filter(i) = dev->PEv2.FilterLimitMSwitch[i];
								PEv2_digin_LimitP_Filter(i) = dev->PEv2.FilterLimitPSwitch[i];
								PEv2_digin_Home_Filter(i) = dev->PEv2.FilterHomeSwitch[i];

								PEv2_HomingAlgorithm(i) = dev->PEv2.HomingAlgorithm[i];
								// MPG 1x mode here
								PEv2_HomeBackOffDistance(i) = dev->PEv2.HomeBackOffDistance[i];
								PEv2_MPGjogDivider(i) = dev->PEv2.MPGjogDivider[i];
								usleep(sleepdur);
							}
						}
					}
					// dev->PEv2.param1 = 0;
					if (PK_PEv2_StatusGet(dev) == PK_OK)
					{
						PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
						PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
						PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;
						// PEv2_stepgen_PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
						PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
						// PEv2_stepgen_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
					}

					if (setPinConfig == true)
					{
						if (PK_PinConfigurationSet(dev) != PK_OK)
						{
							usleep(sleepdur);
							if (PK_PinConfigurationSet(dev) != PK_OK)
							{
								usleep(sleepdur);
							}
							else
							{
								setPinConfig = false;
							}
						}
						else
						{
							setPinConfig = false;
						}
					}
				}
			}
			else
			{
				alive = 0;
				usleep(sleepdur * 50);
			}
		}
		}
	}

	exit(0);
};

EXTRA_SETUP()
{
	int wait_ms = 5000;
	const char *ini_path = getenv("INI_FILE_NAME");
	FILE *fp = fopen(ini_path, "r");
	if (fp){
		iniFindInt(fp, "DEVICE_ID", "POKEYS", &device_id);
		iniFindInt(fp, "COMM_TIMEOUT", "POKEYS", &timeout_ms);
		
	}




	rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: extra_arg=%s device_id=%i \n", __FILE__, __FUNCTION__, extra_arg,device_id);

	// usleep(wait_ms);  // wait for the HAL to start up
	for (i = 0; i < retry; i++)
	{
		if (dev == NULL)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: TryConnectToDevice(0)\n", __FILE__, __FUNCTION__);
			dev = TryConnectToDevice(device_id);
		}
		if (dev != NULL)
		{
			rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: Connected\n", __FILE__, __FUNCTION__);
			break;
		}
	}

	if (dev == NULL)
	{
		rtapi_print_msg(RTAPI_MSG_ERR, "PoKeys: %s:%s: could not connect to device\n", __FILE__, __FUNCTION__);
		
	}
//	PKEncoder_init(comp_id, dev);
	rtapi_print("");
	// devSerial = extra_arg;
	return 0;
}

EXTRA_CLEANUP()
{
	if (dev != NULL)
	{
		PK_DisconnectDevice(dev);
	}
}

static int __comp_get_data_size(void) { return 0; }

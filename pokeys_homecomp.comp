component pokeys_homecomp "homing module template";

description """
Example of a homing module buildable with halcompile.
Demonstrates required code for #includes, function definitions, etc.

If \\fBHOMING_BASE\\fR is #defined and points to a valid homing.c file,
an example of a customized homing module is built.  This module
creates input hal pins joint.n.request-custom-homing that enable an
alternate joint homing state machine for requested joints.  A hal output
pin joint.N.is_custom-homing verifies selection"

The customized homing module utilizes many of the base homing api
routines from homing.c without modification but augments other base
functions to add support for custom hal pins and custom joint homing
state machines.  A user-built module will likely replace additional
api functions or augment them with other customizations.

If \\fBHOMING_BASE\\fR Is not #defined, an  actual homing scheme is
\\fBnot\\fR implemented but all necessary functions are included as
skeleton code.   (All joints are effectively homed at all times and
cannot be unhomed).

See the source code file: src/emc/motion/homing.c for the baseline
implementation that includes all functions for the default \\fBhomemod\\fR
module.

To avoid updates that overwrite homecomp.comp, best practice is
to rename the file and its component name (example:
\\fBuser_homecomp.comp, user_homecomp\\fR).

The (renamed) component can be built and installed with
halcompile and then substituted for the default homing module
(\\fBhomemod\\fR) using:\n
  $ linuxcnc \\fB-m user_homecomp\\fR someconfig.ini\n
or by inifile setting: \\fB[EMCMOT]HOMEMOD=user_homecomp\\fR

\\fBNote:\\fRIf using a deb install:\n
1) halcompile is provided by the package linuxcnc-dev\n
2) This source file for BRANCHNAME (master,2.9,etc) is downloadable from github:\n
https://github.com/LinuxCNC/linuxcnc/blob/BRANCHNAME/src/hal/components/homecomp.comp
""";

pin out bit is_module=1; //one pin is required to use halcompile)

license "GPL";
author "Dewey Garrett";
option homemod;
option extra_setup;
;;

/* To incorporate default homing.c file from a local git src tree:
** enable #define HOMING_BASE set to the path to the current homing.c file.
** (Note: CUSTOM_HOMEMODULE precludes duplicate api symbols)
** (Edit myname as required for valid path)
*/

// #define HOMING_BASE /home/myname/linuxcnc-dev/src/emc/motion/homing.c

#define STR(s) #s
#define XSTR(s) STR(s)

#include "motion.h"
#include "homing.h"
#include <stdlib.h>

static char *home_parms;
RTAPI_MP_STRING(home_parms, "Example home parms");

// EXTRA_SETUP is executed before rtapi_app_main()
EXTRA_SETUP()
{
    if (!home_parms)
    {
        home_parms = "no_home_parms";
    }
    rtapi_print("@@@%s:%s: home_parms=%s\n", __FILE__, __FUNCTION__, home_parms);
#ifndef HOMING_BASE
    rtapi_print("\n!!!%s: Skeleton Homing Module\n\n", __FILE__);
#else
    rtapi_print("\n!!!%s: HOMING_BASE=%s\n"
                "!!!Customize using hal pin(s): joint.N.request-custom-homing\n",
                __FILE__, XSTR(HOMING_BASE));
#endif

    return 0;
}

//=====================================================================
#ifdef HOMING_BASE // { begin CUSTOM example
#define USE_HOMING_BASE XSTR(HOMING_BASE)

// NOTE: CUSTOM_HOMEMODULE: disables duplicate symbols sourced from homing.c
#define CUSTOM_HOMEMODULE
#include USE_HOMING_BASE

typedef struct
{
    bool request_custom_homing;
    bool is_custom_homing;
} custom_home_local_data;

static custom_home_local_data customH[EMCMOT_MAX_JOINTS];

// data for per-joint custom-homing-specific hal pins:
typedef struct
{
    hal_bit_t *request_custom_homing; // input  requests custom homing
    hal_bit_t *is_custom_homing;      // output verifies custom homing
} custom_one_joint_home_data_t;

typedef struct
{
    custom_one_joint_home_data_t custom_jhd[EMCMOT_MAX_JOINTS];
} custom_all_joints_home_data_t;

static custom_all_joints_home_data_t *custom_joint_home_data = 0;

static int custom_makepins(int id, int njoints)
{
    int jno, retval;
    custom_one_joint_home_data_t *addr;

    custom_joint_home_data = hal_malloc(sizeof(custom_all_joints_home_data_t));
    if (custom_joint_home_data == 0)
    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: custom_all_joints_home_data_t malloc failed\n");
        return -1;
    }

    retval = 0;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(custom_joint_home_data->custom_jhd[jno]);

        retval += hal_pin_bit_newf(HAL_IN, &(addr->request_custom_homing), id,
                                   "joint.%d.request-custom-homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->is_custom_homing), id,
                                   "joint.%d.is-custom-homing", jno);
    }
    return retval;
} // custom_makepins()

static void custom_read_homing_in_pins(int njoints)
{
    int jno;
    custom_one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(custom_joint_home_data->custom_jhd[jno]);
        customH[jno].request_custom_homing = *(addr->request_custom_homing); // IN

        // echo for verification:
        customH[jno].is_custom_homing = customH[jno].request_custom_homing;
    }
}

static void custom_write_homing_out_pins(int njoints)
{
    int jno;
    custom_one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(custom_joint_home_data->custom_jhd[jno]);
        *(addr->is_custom_homing) = customH[jno].is_custom_homing; // OUT
    }
}

static int custom_1joint_state_machine(int joint_num)
{
    typedef enum
    {
        CUSTOM_IDLE = 0,
        CUSTOM_1 = 1,
        CUSTOM_2 = 2,
        CUSTOM_3 = 3,
        CUSTOM_4 = 4,
        CUSTOM_FINI = 5,
    } custom_home_state_t;

    static custom_home_state_t chomestate[EMCMOT_MAX_JOINTS] = {0};
    custom_home_state_t nextcstate;

#define C_SHOW \
    rtapi_print("H[%d].homed=%d,homing=%d,home_state=%d chomestate[%d]=%d next=%d\n", joint_num, H[joint_num].homed, H[joint_num].homing, H[joint_num].home_state, joint_num, chomestate[joint_num], nextcstate);

    if (H[joint_num].home_state == HOME_IDLE)
        return 0; // nothing to do

    if ((H[joint_num].home_state == HOME_START) && (chomestate[joint_num] == CUSTOM_IDLE))
    {
        H[joint_num].homing = 1;
        H[joint_num].homed = 0;
        chomestate[joint_num] = CUSTOM_1; // set first non-idle custom_home_state
    }
    // For this example, just walk thru custom_home_states with prints.
    // Note: remains in the base home_state: HOME_START for all custom_home_states.
    //       On completion, return to HOME_IDLE, CUSTOM_IDLE states.
    switch (chomestate[joint_num])
    {
    case CUSTOM_1:
        // Each CUSTOM_* state should do something and/or check something
        // and set nexstcstate according to the design goals.
        // Halpin variables can be read and/or set for next write.
        nextcstate = CUSTOM_2;
        C_SHOW;
        chomestate[joint_num] = nextcstate;
        break;
    case CUSTOM_2:
        nextcstate = CUSTOM_3;
        C_SHOW;
        chomestate[joint_num] = nextcstate;
        break;
    case CUSTOM_3:
        nextcstate = CUSTOM_4;
        C_SHOW;
        chomestate[joint_num] = nextcstate;
        break;
    case CUSTOM_4:
        nextcstate = CUSTOM_FINI;
        C_SHOW;
        chomestate[joint_num] = nextcstate;
        break;
    case CUSTOM_FINI:
        H[joint_num].homing = 0;
        H[joint_num].homed = 1;
        H[joint_num].home_state = HOME_IDLE;
        nextcstate = CUSTOM_IDLE;
        C_SHOW;
        chomestate[joint_num] = nextcstate;
        return 0; // finished custom_home_states
        break;
    case CUSTOM_IDLE:
    default:
        rtapi_print("Unhandled custom_home_state: %d\n", chomestate[joint_num]);
    }
    return 1; // return 1 if busy
#undef C_SHOW
} // custom_1joint_state_machine()

// api functions below augment base_*() functions with custom code
int homing_init(int id,
                double servo_period,
                int n_joints,
                int n_extrajoints,
                emcmot_joint_t *pjoints)
{
    int retval;
    retval = base_homing_init(id,
                              servo_period,
                              n_joints,
                              n_extrajoints,
                              pjoints);
    retval += custom_makepins(id, n_joints);
    return retval;
} // homing_init()

void read_homing_in_pins(int njoints)
{
    base_read_homing_in_pins(njoints);
    custom_read_homing_in_pins(njoints);
}

void write_homing_out_pins(int njoints)
{
    base_write_homing_out_pins(njoints);
    custom_write_homing_out_pins(njoints);
}

/* do_homing() is adapted from homing.c:base_do_homing() augmented
** with support for custom homing as specified on hal input pin:
** joint.n.request-custom-homing and echoed on hal output pin
** joint.n.is-custom-homing
*/
bool do_homing(void)
{
    int joint_num;
    int homing_flag = 0;
    bool beginning_allhomed = get_allhomed();

    do_homing_sequence();
    /* loop thru joints, treat each one individually */
    for (joint_num = 0; joint_num < all_joints; joint_num++)
    {
        if (!H[joint_num].joint_in_sequence)
        {
            continue;
        }
        if (!GET_JOINT_ACTIVE_FLAG(&joints[joint_num]))
        {
            continue;
        }

        if (customH[joint_num].is_custom_homing)
        {
            // CUSTOM joint homing state machine:
            homing_flag += custom_1joint_state_machine(joint_num);
        }
        else
        {
            // DEFAULT joint homing state machine:
            homing_flag += base_1joint_state_machine(joint_num);
        }
    }
    if (homing_flag > 0)
    { /* one or more joint is homing */
        homing_active = 1;
    }
    else
    { /* is a homing sequence in progress? */
        if (sequence_state == HOME_SEQUENCE_IDLE)
        {
            /* no, single joint only, we're done */
            homing_active = 0;
        }
    }
    // return 1 if homing completed this period
    if (!beginning_allhomed && get_allhomed())
    {
        homing_active = 0;
        return 1;
    }
    return 0;
}

//===============================================================================
// functions below use unmodified base_*() implementation
bool get_allhomed(void) { return base_get_allhomed(); }
bool get_homed(int jno) { return base_get_homed(jno); }
bool get_home_is_idle(int jno) { return base_get_home_is_idle(jno); }
bool get_home_is_synchronized(int jno) { return base_get_home_is_synchronized(jno); }
bool get_home_needs_unlock_first(int jno) { return base_get_home_needs_unlock_first(jno); }
int get_home_sequence(int jno) { return base_get_home_sequence(jno); }
bool get_homing(int jno) { return base_get_homing(jno); }
bool get_homing_at_index_search_wait(int jno) { return base_get_homing_at_index_search_wait(jno); }
bool get_homing_is_active(void) { return base_get_homing_is_active(); }
bool get_index_enable(int jno) { return base_get_index_enable(jno); }

void do_home_joint(int jno) { base_do_home_joint(jno); }
void do_cancel_homing(int jno) { base_do_cancel_homing(jno); }
void set_unhomed(int jno, motion_state_t motstate) { base_set_unhomed(jno, motstate); }
void set_joint_homing_params(int jno,
                             double offset,
                             double home,
                             double home_final_vel,
                             double home_search_vel,
                             double home_latch_vel,
                             int home_flags,
                             int home_sequence,
                             bool volatile_home)
{
    base_set_joint_homing_params(jno,
                                 offset,
                                 home,
                                 home_final_vel,
                                 home_search_vel,
                                 home_latch_vel,
                                 home_flags,
                                 home_sequence,
                                 volatile_home);
}
void update_joint_homing_params(int jno,
                                double offset,
                                double home,
                                int home_sequence)
{
    base_update_joint_homing_params(jno,
                                    offset,
                                    home,
                                    home_sequence);
}
//           end   CUSTOM example
//=====================================================================
#else // } { begin SKELETON example minimal api implementation
static emcmot_joint_t *joints;
static bool homing_active = 0;
static int all_joints = 0;
static int current_sequence = 0;

typedef enum
{
    HOME_SEQUENCE_IDLE = 0,
    HOME_SEQUENCE_START,
    HOME_SEQUENCE_DO_ONE_JOINT,
    HOME_SEQUENCE_DO_ONE_SEQUENCE,
    HOME_SEQUENCE_START_JOINTS,
    HOME_SEQUENCE_WAIT_JOINTS
} home_sequence_state_t;
static home_sequence_state_t sequence_state = HOME_SEQUENCE_IDLE;

typedef enum
{
    PK_PEAxisState_axSTOPPED = 0, // Axis is stopped
    PK_PEAxisState_axREADY = 1,   // Axis ready
    PK_PEAxisState_axRUNNING = 2, // Axis is running

    PK_PEAxisState_axHOMING_RESETTING = 8,   // Stopping the axis to reset the position counters
    PK_PEAxisState_axHOMING_BACKING_OFF = 9, // Backing off switch
    PK_PEAxisState_axHOME = 10,              // Axis is homed
    PK_PEAxisState_axHOMINGSTART = 11,       // Homing procedure is starting on axis
    PK_PEAxisState_axHOMINGSEARCH = 12,      // Homing procedure first step - going to home
    PK_PEAxisState_axHOMINGBACK = 13,        // Homing procedure second step - slow homing

    PK_PEAxisState_axPROBED = 14,      // Probing completed for this axis
    PK_PEAxisState_axPROBESTART = 15,  // Probing procedure is starting on axis
    PK_PEAxisState_axPROBESEARCH = 16, // Probing procedure - probing

    PK_PEAxisState_axERROR = 20, // Axis error
    PK_PEAxisState_axLIMIT = 30  // Axis limit tripped
} pokeys_home_state_t;

typedef enum
{
    PK_PEAxisCommand_axIDLE = 0,           // Axis  in IDLE
    PK_PEAxisCommand_axHOMINGSTART = 1,    // Start Homing procedure
    PK_PEAxisCommand_axHOMINGCANCEL = 2,   // Cancel Homing procedure
    PK_PEAxisCommand_axHOMINGFINALIZE = 3, // Finish Homing procedure
} pokeys_home_command_t;

typedef enum
{
    HOME_IDLE = 0,
    HOME_START,                 // 1
    HOME_UNLOCK,                // 2
    HOME_UNLOCK_WAIT,           // 3
    HOME_INITIAL_BACKOFF_START, // 4
    HOME_INITIAL_BACKOFF_WAIT,  // 5
    HOME_INITIAL_SEARCH_START,  // 6
    HOME_INITIAL_SEARCH_WAIT,   // 7
    HOME_SET_COARSE_POSITION,   // 8
    HOME_FINAL_BACKOFF_START,   // 9
    HOME_FINAL_BACKOFF_WAIT,    // 10
    HOME_RISE_SEARCH_START,     // 11
    HOME_RISE_SEARCH_WAIT,      // 12
    HOME_FALL_SEARCH_START,     // 13
    HOME_FALL_SEARCH_WAIT,      // 14
    HOME_SET_SWITCH_POSITION,   // 15
    HOME_INDEX_ONLY_START,      // 16
    HOME_INDEX_SEARCH_START,    // 17
    HOME_INDEX_SEARCH_WAIT,     // 18
    HOME_SET_INDEX_POSITION,    // 19
    HOME_FINAL_MOVE_START,      // 20
    HOME_FINAL_MOVE_WAIT,       // 21
    HOME_LOCK,                  // 22
    HOME_LOCK_WAIT,             // 23
    HOME_FINISHED,              // 24
    HOME_ABORT                  // 25
} local_home_state_t;

// data for per-joint homing-specific hal pins:
typedef struct
{
    hal_bit_t *home_sw;      // home switch input
    hal_bit_t *homing;       // joint is homing
    hal_bit_t *homed;        // joint was homed
    hal_bit_t *index_enable; // motmod sets: request reset on index
                             //        encoder clears: index arrived
    hal_s32_t *home_state;   // homing state machine state

    // Custom Pins for comunication with PoKeys
    hal_u32_t *PEv2_AxesState;   // State of pulse engine - see ePoKeysPEState
    hal_u32_t *PEv2_AxesCommand; // Commands to  pulse engine - see ePoKeysPECmd

} one_joint_home_data_t;

typedef struct
{
    // pin data for all joints
    bool home_sw;
    bool homing;
    bool homed;
    bool index_enable;
    local_home_state_t home_state;

    // Custom Pins for comunication with PoKeys
    pokeys_home_state_t PEv2_AxesState;
    pokeys_home_command_t PEv2_AxesCommand;

    // homeparams
    double offset;
    double home;
    double home_final_vel;
    double home_search_vel;
    double home_latch_vel;
    int home_flags;
    int home_sequence;
    bool volatile_home;

    bool home_is_synchronized;

    bool joint_in_sequence;
} home_local_data;

static home_local_data H[EMCMOT_MAX_JOINTS];

typedef struct
{
    one_joint_home_data_t jhd[EMCMOT_MAX_JOINTS];

} all_joints_home_data_t;

static all_joints_home_data_t *joint_home_data = 0;

typedef struct
{
    int home_sequence; // my sequence ID
    bool homing;
    bool homed;

    int joints_in_sequence;
    int joint_ids[EMCMOT_MAX_JOINTS];

    bool is_last;
    int next_sequence;

    local_home_state_t home_state;

} one_sequence_home_data_t;

typedef struct
{
    one_sequence_home_data_t shd[EMCMOT_MAX_JOINTS];
    int sequence_count;

    int min_sequence;
    int max_sequence;

    int current_sequence;

} all_sequences_home_data_t;

static all_sequences_home_data_t sequence_home_data;

static int makepins(int id, int njoints)
{
    // home_pins needed to work with configs expecting them:
    int jno, retval;
    one_joint_home_data_t *addr;

    joint_home_data = hal_malloc(sizeof(all_joints_home_data_t));
    if (joint_home_data == 0)
    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: all_joints_home_data_t malloc failed\n");
        return -1;
    }

    retval = 0;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(joint_home_data->jhd[jno]);

        retval += hal_pin_bit_newf(HAL_IN, &(addr->home_sw), id,
                                   "joint.%d.home-sw-in", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homing), id,
                                   "joint.%d.homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homed), id,
                                   "joint.%d.homed", jno);
        retval += hal_pin_s32_newf(HAL_OUT, &(addr->home_state), id,
                                   "joint.%d.home-state", jno);
        retval += hal_pin_bit_newf(HAL_IO, &(addr->index_enable), id,
                                   "joint.%d.index-enable", jno);

        // add custom hal pins here:
        retval += hal_pin_u32_newf(HAL_IN, &(addr->PEv2_AxesState), id,
                                   "joint.%d.PEv2.AxesState", jno);
        retval += hal_pin_u32_newf(HAL_OUT, &(addr->PEv2_AxesCommand), id,
                                   "joint.%d.PEv2.AxesCommand", jno);
        /*retval += hal_pin_s32_newf(HAL_IO, &(addr->home_sequence), id,
                                      "joint.%d.home_sequence", jno);*/
    }
    return retval;
}
// All (skeleton) functions required for homing api follow:
void homeMotFunctions(void (*pSetRotaryUnlock)(int, int), int (*pGetRotaryIsUnlocked)(int))
{
    return;
}

static void update_sequence_home_data(void)
{
    int min_sequence = abs(H[0].home_sequence);
    int max_sequence = abs(H[0].home_sequence);
    int sequence_count = 0;
    int current_sequence = 0;
    
    for(int jno = 0; jno < all_joints; jno++)
    {
        int seq = abs(H[jno].home_sequence);
        if (seq < min_sequence)
        {
            min_sequence = seq; // find min sequence    
        }
        if (seq > max_sequence)
        {
            max_sequence = seq; // find max sequence
        }
    }
    sequence_count = max_sequence - min_sequence + 1;
    rtapi_print_msg(RTAPI_MSG_DBG,"HOMING: update_sequence_home_data(min_sequence:%d  to max_sequence:%d)\n", min_sequence, max_sequence);
    sequence_home_data.min_sequence = min_sequence;
    sequence_home_data.max_sequence = max_sequence;
    sequence_home_data.sequence_count = sequence_count;

    for(int sno=min_sequence; sno<=max_sequence; sno++)
    {
        one_sequence_home_data_t saddr = (sequence_home_data.shd[sno]);
        sequence_home_data.shd[sno].home_sequence = sno;
        //saddr.homing = 0; should not interrupt homing
        //saddr.homed = 0;
        sequence_home_data.shd[sno].joints_in_sequence = 0;
        if(sno == max_sequence)
        {
            sequence_home_data.shd[sno].is_last = 1;
            sequence_home_data.shd[sno].next_sequence = 0;
        }
        else
        {
            sequence_home_data.shd[sno].is_last = 0;
            sequence_home_data.shd[sno].next_sequence = sno+1;
        }

        
        sequence_home_data.shd[sno].home_state = HOME_IDLE;

        for(int jno = 0; jno < all_joints; jno++)
        {
            if (abs(H[jno].home_sequence) == sno)
            {
                sequence_home_data.shd[sno].joint_ids[saddr.joints_in_sequence] = jno;
                sequence_home_data.shd[sno].joints_in_sequence++;
            }
        }

        rtapi_print_msg(RTAPI_MSG_DBG,"HOMING: update_sequence_home_data(%d) joints_in_sequence:%d\n", sno, sequence_home_data.shd[sno].joints_in_sequence);
    }
}


int homing_init(int id,
                double servo_period,
                int n_joints,
                int n_extrajoints,
                emcmot_joint_t *pjoints)
{
    joints = pjoints;
    all_joints = n_joints;
    return makepins(id, n_joints);

    // initialize jid[] and jhd[] data here
    for (int jno = 0; jno < EMCMOT_MAX_JOINTS; jno++)
    {

        H[jno].offset = 0;
        H[jno].home = 0;
        H[jno].home_final_vel = 0;
        H[jno].home_search_vel = 0;
        H[jno].home_latch_vel = 0;
        H[jno].home_flags = 0;
        H[jno].home_sequence = 0;
        H[jno].volatile_home = 1;

        one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
        H[jno].home_sw = 0;
        H[jno].homing = 0;
        H[jno].homed = 0;
        H[jno].home_state = HOME_IDLE;
        H[jno].index_enable = 0;
        H[jno].PEv2_AxesState = PK_PEAxisState_axSTOPPED;
        H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;

        one_sequence_home_data_t saddr = (sequence_home_data.shd[jno]);
        saddr.home_sequence = 0;
        saddr.homing = 0;
        saddr.homed = 0;
        saddr.joints_in_sequence = 0;
        saddr.is_last = 0;
        saddr.next_sequence = 0;
        saddr.home_state = HOME_IDLE;

    }
}

bool get_sequence_homed(int seq)
{
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    int joints_in_sequence = addr.joints_in_sequence;

    for (int jj = 0; jj < joints_in_sequence; jj++)
    {
        int jno = addr.joint_ids[jj];
        if (!H[jno].homed)
        {
            return 0;
        }
    }

    return 1;
}

bool get_sequence_homing(int seq)
{
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    int joints_in_sequence = addr.joints_in_sequence;

    for (int jj = 0; jj < joints_in_sequence; jj++)
    {
        int jno = addr.joint_ids[jj];
        if (H[jno].homing)
        {
            return 1;
        }
    }

    return 0;
}

int pokeys_1joint_state_machine(int joint_num){
    emcmot_joint_t *joint;
    double offset, tmp;
    int home_sw_active, homing_flag;
    bool immediate_state = 0;

    homing_flag = 0;
    joint = &joints[joint_num];
    home_sw_active = H[joint_num].home_sw;
    if (H[joint_num].home_state != HOME_IDLE)
    {
        homing_flag = 1; /* at least one joint is homing */
    }

    /* when a joint is homing, 'check_for_faults()' ignores its limit
       switches, so that this code can do the right thing with them. Once
       the homing process is finished, the 'check_for_faults()' resumes
       checking */

    /* homing state machine */

    /* Some portions of the homing sequence can run thru two or more
       states during a single servo period.  This is done using
       'immediate_state'.  If a state transition sets it true (non-zero),
       this 'do-while' will loop executing switch(home_state) immediately
       to run the new state code.  Otherwise, the loop will fall thru, and
       switch(home_state) runs only once per servo period. Do _not_ set
       'immediate_state' true unless you also change 'home_state', unless
       you want an infinite loop! */
    do    {
        immediate_state = 0;
        switch (H[joint_num].PEv2_AxesState)        {
        case PK_PEAxisState_axSTOPPED:
            /* Axis is stopped */
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d stopped\n", joint_num);
            H[joint_num].homing = 0;
            H[joint_num].homed = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axREADY:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d ready\n", joint_num);
            /* Axis ready */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axRUNNING:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d running\n", joint_num);
            /* Axis is running */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axHOMING_RESETTING:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing resetting\n", joint_num);
            /* Stopping the axis to reset the position counters */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_UNLOCK;
            H[joint_num].homed = 0;
            break;

        case PK_PEAxisState_axHOMING_BACKING_OFF:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing backing off\n", joint_num);
            /* Backing off switch */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_INITIAL_BACKOFF_WAIT;
            break;

        case PK_PEAxisState_axHOME:
            rtapi_print_msg(RTAPI_MSG_ERR, "HOMING: pokeys_1joint_state_machine joint %d homed\n", joint_num);
            /* Axis is homed */
            
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_FINISHED;
            H[joint_num].homed = 1;
            
            break;

        case PK_PEAxisState_axHOMINGSTART:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing start\n", joint_num);
            /* Homing procedure is starting on axis */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_START;
            break;

        case PK_PEAxisState_axHOMINGSEARCH:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing search\n", joint_num);
            /* Homing procedure first step - going to home */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_INITIAL_SEARCH_WAIT;
            break;

        case PK_PEAxisState_axHOMINGBACK:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing back\n", joint_num);
            /* Homing procedure second step - slow homing */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_FINAL_BACKOFF_START;
            break;

        case PK_PEAxisState_axPROBED:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d probed\n", joint_num);
            /* Probing completed for this axis */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axPROBESTART:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d probed start\n", joint_num);
            /* Probing procedure is starting on axis */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axPROBESEARCH:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d probe search\n", joint_num);
            /* Probing procedure - probing */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axERROR:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d error\n", joint_num);
            /* Axis error */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axLIMIT:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d limit\n", joint_num);
            /* Axis limit tripped */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        default:
            /* should never get here */
            rtapi_print_msg(RTAPI_MSG_DBG, "unknown state '%d' during homing j=%d",
                            H[joint_num].home_state, joint_num);
            H[joint_num].home_state = HOME_ABORT;
            immediate_state = 1;
            break;
        } /* end of switch(H[joint_num].home_state) */
    } while (immediate_state);

    return homing_flag;
} // pokeys_1joint_state_machine()


void do_home_sequence(int seq){
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    sequence_home_data.current_sequence = seq;

    int joints_in_sequence = addr.joints_in_sequence;

    current_sequence = seq;
    sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;

    for (int jj = 0; jj < joints_in_sequence; jj++)    {
        int jno = addr.joint_ids[jj];
        pokeys_1joint_state_machine(jno);

        H[jno].homed = 0;
        H[jno].homing = 1;
        H[jno].home_state = HOME_START;
        H[jno].joint_in_sequence = 1;
        
        int int_AxesState = H[jno].PEv2_AxesState;
        switch (int_AxesState)        {
            case PK_PEAxisState_axSTOPPED:
                H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                break;

            case PK_PEAxisState_axREADY:
                H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                break;

            default:
                break;
        }
    }
    return;
}

void check_home_sequence(int seq)
{
    if (sequence_state != HOME_SEQUENCE_DO_ONE_SEQUENCE)
    {
        return;
    }
     
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    int joints_in_sequence = addr.joints_in_sequence;

    if (addr.homed)
    {
        if (addr.is_last)
        {
            sequence_state = HOME_SEQUENCE_IDLE;
        }
        else
        {
            sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
            do_home_sequence(addr.next_sequence);
        }
        return;
    }
    else if (addr.homing)
    {
        if (get_sequence_homed(seq))
        {
            addr.homed = 1;
            addr.homing = 0;
            addr.home_state = HOME_FINISHED;
            if (addr.is_last)
            {
                sequence_state = HOME_SEQUENCE_IDLE;
            }
            else
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                do_home_sequence(addr.next_sequence);
            }
        }
        else if (get_sequence_homing(seq))
        {
            addr.homed = 0;
            addr.homing = 1;
            addr.home_state = HOME_START;
        }
        else
        {
            addr.homed = 0;
            addr.homing = 0;
            addr.home_state = HOME_IDLE;
        }
    }
}

bool get_allhomed()
{
    int ret = 1;
    for (int jno = 0; jno < EMCMOT_MAX_JOINTS; jno++)
    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: get_allhomed joint %d homed %d\n", jno, H[jno].homed);
        one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
        if (!*addr->homed)
        {
            ret = 0;
            break;
        }
        // usleep(100); // Add a small delay to prevent CPU hogging
    }
    return ret ? 1 : 0;
}
bool get_homed(int jno)
{
    return H[jno].homed ? 1 : 0;
}
bool get_home_is_idle(int jno)
{
    return H[jno].home_state == HOME_IDLE ? 1 : 0;
}
bool get_home_is_synchronized(int jno)
{
    return H[jno].home_is_synchronized ? 1 : 0;
}
bool get_home_needs_unlock_first(int jno)
{
    return (H[jno].home_flags & HOME_UNLOCK_FIRST) ? 1 : 0;
}
int get_home_sequence(int jno)
{
    return H[jno].home_sequence;
}
bool get_homing(int jno)
{
    one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
    return *addr->homing ? 1 : 0;
}

bool get_homing_at_index_search_wait(int jno) { return 0; }
bool get_homing_is_active()
{
    int ret = 0;
    /* for (int jno = 0; jno < EMCMOT_MAX_JOINTS; jno++) {
         one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);

         if (*addr->homing) {
             ret = 1;
             break;
         }
     }*/
    return ret;
}
bool get_index_enable(int jno)
{
    return H[jno].index_enable ? 1 : 0;
}
void read_homing_in_pins(int njoints)
{
    int jno;
    one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(joint_home_data->jhd[jno]);
        H[jno].home_sw = *(addr->home_sw);           // IN
        H[jno].index_enable = *(addr->index_enable); // IN

        H[jno].PEv2_AxesState = *(addr->PEv2_AxesState); // IN
    }
    return;
}

void write_homing_out_pins(int njoints)
{
    int jno;
    one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(joint_home_data->jhd[jno]);
        *(addr->homing) = H[jno].homing;                     // OUT
        *(addr->homed) = H[jno].homed;                       // OUT
        *(addr->home_state) = H[jno].home_state;             // OUT
        *(addr->PEv2_AxesCommand) = H[jno].PEv2_AxesCommand; // OUT
    }
    return;
}

void do_home_all(void)
{
    if (!get_homing_is_active())
    {
        sequence_state = HOME_SEQUENCE_START;
    }
    return;
} // do_home_all()

void do_home_joint(int jno){
    if (jno >= 0)    {
        // one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
        pokeys_1joint_state_machine(jno);
        int int_AxesState = H[jno].PEv2_AxesState;
        switch (int_AxesState)        {
        case PK_PEAxisState_axHOMING_RESETTING:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing resetting\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMING_BACKING_OFF:
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMINGSTART:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing start\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMINGSEARCH:
           rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing search\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMINGBACK:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing back\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOME:
            rtapi_print_msg(RTAPI_MSG_ERR, "HOMING:do_home_joint.PK_PEAxisState_axHOME do_home_joint joint %d homed (home_sequence %d)\n", jno,H[jno].home_sequence);
            
            // check if all joints in sequence are homed
            if (H[jno].home_sequence < 0)
            {

                int joints_in_sequence = 0;
                int homed_in_sequence = 0;
                int jj;
                for (jj = 0; jj < all_joints; jj++)
                {
                    if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                    {
                        joints_in_sequence++;
                        if (H[jj].PEv2_AxesState == PK_PEAxisState_axHOME)
                        {
                            homed_in_sequence++;
                        }
                    }
                }

                rtapi_print_msg(RTAPI_MSG_ERR, "HOMING:PK_PEAxisState_axHOME joint %d joints_in_sequence:%d  homed_in_sequence:%d \n",jno, joints_in_sequence,homed_in_sequence);
                if (joints_in_sequence == homed_in_sequence)
                {
                    //if all Joints of the Sequence show Hommed
                        for (jj = 0; jj < all_joints; jj++)
                        {

                            if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                            {
                                H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;
                            }
                        }
                        H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;

                }
            }
            else
            {
                H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;
            }
            break;
        case PK_PEAxisState_axSTOPPED:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d stopped\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
            H[jno].home_state = HOME_START;
            if (H[jno].home_sequence < 0)
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                int jj;
                for (jj = 0; jj < all_joints; jj++)
                {
                    if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                    {
                        H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                        H[jj].home_state = HOME_START;
                    }
                }
            }
            else
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_JOINT;
            }

            break;
        case PK_PEAxisState_axREADY:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d ready\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
            H[jno].home_state = HOME_START;
            if (H[jno].home_sequence < 0)
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                int jj;
                for (jj = 0; jj < all_joints; jj++)
                {
                    if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                    {
                        H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                        H[jj].home_state = HOME_START;
                    }
                }
            }
            else
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_JOINT;
            }

            break;

        default:
            break;
        }
    }
    else
    {
        // rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint number out of range\n");

        // triger homing for first sequence (index 0)

        //do_home_sequence(0);
        update_sequence_home_data();
        sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
        int jj;
        current_sequence = 0;
        int trigered = 0;
        for (jj = 0; jj < all_joints; jj++)
        {
            if (abs(H[jj].home_sequence) == abs(sequence_home_data.min_sequence))
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint %d in sequence %d\n", jj, sequence_home_data.min_sequence);
                H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                H[jno].home_state = HOME_START;
                trigered ++;
            }
            else
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint %d not in sequence %d\n", jj, sequence_home_data.min_sequence);
            }
            
        }

        if(trigered == 0)
        {
            rtapi_print_msg(RTAPI_MSG_WARN, "HOMING: no joints in sequence %d\n", sequence_home_data.shd[current_sequence].home_sequence);
        }
    }
    return;
}

// SEQUENCE management
static void do_homing_sequence(void) {
    int i, ii;
    int seen;
    emcmot_joint_t *joint;
    int sequence_is_set = 0;
    if(current_sequence <sequence_home_data.min_sequence || current_sequence >sequence_home_data.max_sequence)    {
        // no sequence set, use the first one
        current_sequence = sequence_home_data.min_sequence ;
    }
    one_sequence_home_data_t addr = (sequence_home_data.shd[current_sequence]);
    int joints_in_sequence = addr.joints_in_sequence;

    switch (sequence_state)
    {
    case HOME_SEQUENCE_IDLE:
        current_sequence = sequence_home_data.min_sequence;
        /* nothing to do */
        break;

    case HOME_SEQUENCE_DO_ONE_JOINT:
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence HOME_SEQUENCE_DO_ONE_JOINT\n");
        update_sequence_home_data();
        // Expect one joint with home_state==HOME_START
        int joints_in_sequence_DBG = 0;
        one_sequence_home_data_t addr_dbg ;
        for (i = 0; i < all_joints; i++)
        {
            //pokeys_1joint_state_machine(i);
            if (H[i].home_state == HOME_START)
            {
                H[i].joint_in_sequence = 1; // in sequence
                H[i].homed = 0;
                H[i].homing = 1;
                joints_in_sequence_DBG++;
                addr_dbg.joints_in_sequence=joints_in_sequence_DBG;
                addr_dbg.joint_ids[joints_in_sequence_DBG] = i;
                current_sequence = abs(H[i].home_sequence);
                addr = (sequence_home_data.shd[current_sequence]);
                joints_in_sequence = addr.joints_in_sequence; //count of all joints in sequence
            }
            else
            {
                H[i].joint_in_sequence = 0; // not in sequence
            }
        }
        sequence_is_set = 1;
        /*if (current_sequence ==0) 
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_DO_ONE_JOINT current_sequence = 0\n",current_sequence);
            current_sequence=sequence_home_data.min_sequence;
            addr = (sequence_home_data.shd[current_sequence]);
            joints_in_sequence = addr.joints_in_sequence; //count of all joints in sequence
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) use first HOME_SEQUENCE_DO_ONE_JOINT joints_in_sequence = %d, new current_sequence = %d\n",current_sequence,joints_in_sequence);
        }*/
        
        if (joints_in_sequence==0)
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_DO_ONE_JOINT joints_in_sequence = 0\n",current_sequence);
            update_sequence_home_data();
            //sequence_state = HOME_SEQUENCE_IDLE;
             addr = (sequence_home_data.shd[current_sequence]);
            joints_in_sequence = addr.joints_in_sequence; //count of all joints in sequence
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) after update HOME_SEQUENCE_DO_ONE_JOINT joints_in_sequence = %d \n",current_sequence,joints_in_sequence);
        

            break;
        }
        else
        {
            sequence_state = HOME_SEQUENCE_START;
        }
        // drop through----drop through----drop through----drop through
        
        break;

    case HOME_SEQUENCE_DO_ONE_SEQUENCE:
        // Expect multiple joints with home_state==HOME_START
        // specified by a negative sequence
        // Determine current_sequence and set H[i].joint_in_sequence
        // based on home_state[i] == HOME_START
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_DO_ONE_SEQUENCE joints_in_sequence = %d\n",current_sequence,joints_in_sequence);


        for (int jj = 0; jj < joints_in_sequence; jj++)
        {
            int jno = addr.joint_ids[jj];
            pokeys_1joint_state_machine(jno);
            H[jno].homed = 0;
            H[jno].homing = 1;
            H[jno].joint_in_sequence = 1;
            H[jno].home_state = HOME_START;
        }
      
        sequence_state = HOME_SEQUENCE_START;
        break;
        // drop through----drop through----drop through----drop through

    case HOME_SEQUENCE_START:
        // Request to home all joints or a single sequence
        sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START\n",current_sequence);
        for (int jj = 0; jj < joints_in_sequence; jj++)
        {
            int jno = addr.joint_ids[jj];
            pokeys_1joint_state_machine(jno);
            int int_AxesState = H[jno].PEv2_AxesState;
            switch (int_AxesState)
            {
                case PK_PEAxisState_axSTOPPED:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) joint %d stopped\n",current_sequence, jno);
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                    break;

                case PK_PEAxisState_axREADY:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) do_homing_sequence joint %d ready\n",current_sequence, jno);
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                    break;

                case PK_PEAxisState_axRUNNING:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) do_homing_sequence joint %d running\n",current_sequence, jno);
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                    break;

                case PK_PEAxisState_axERROR:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) do_homing_sequence joint %d error\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_IDLE;
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGCANCEL;
                    return;
                    break;

                default:
                    break;
            }
        }
 
        /* tell the world we're on the job */
        homing_active = 1;
        break;
        // drop through----drop through----drop through----drop through

    case HOME_SEQUENCE_START_JOINTS:
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START_JOINTS\n",current_sequence);
        seen = 0;
        /* start all joints whose sequence number matches H[i].home_sequence */
        for (i = 0; i < all_joints; i++)
        {
            joint = &joints[i];
            if (abs(H[i].home_sequence) == current_sequence)
            {
                if (!H[i].joint_in_sequence)
                    continue;
                /* start this joint */
                joint->free_tp.enable = 0;
                H[i].home_state = HOME_START;
                seen++;
            }
        }
        if (seen || current_sequence == 0)
        {
            sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
        }
        else
        {
            /* no joints have this sequence number, we're done */
            sequence_state = HOME_SEQUENCE_IDLE;
            /* tell the world */
            homing_active = 0;
        }
        break;

    case HOME_SEQUENCE_WAIT_JOINTS:
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joints_in_sequence: %d\n",current_sequence,joints_in_sequence);
        seen = 0;

        int homed_count = 0;

        for (int jj = 0; jj < joints_in_sequence; jj++)        {
            int jno = addr.joint_ids[jj];
            pokeys_1joint_state_machine(jno);
            int int_AxesState = H[jno].PEv2_AxesState;
            switch (int_AxesState)            {
                case PK_PEAxisState_axSTOPPED:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) joint %d PK_PEAxisState_axSTOPPED\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_START_JOINTS; //back to start
                    break;

                case PK_PEAxisState_axREADY:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) joint %d PK_PEAxisState_axREADY\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_START_JOINTS; //back to start
                    break;

                case PK_PEAxisState_axRUNNING:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axRUNNING\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_START_JOINTS; //back to start
                    break;

                case PK_PEAxisState_axHOMING_RESETTING:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axHOMING_RESETTING\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axHOMING_BACKING_OFF:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axHOMING_BACKING_OFF\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;
                
                case PK_PEAxisState_axHOME:
                    
                    if(H[jno].homed == 0)
                    {
                    rtapi_print_msg(RTAPI_MSG_ERR, "HOMING:  do_homing_sequence(%d) do_homing_sequence joint %d PK_PEAxisState_axHOME no flags set yet\n",current_sequence, jno);
                        H[jno].homed = 1;
                        H[jno].homing = 0;
                        H[jno].home_state = HOME_FINISHED;
                    }
                    else{
                    rtapi_print_msg(RTAPI_MSG_ERR, "HOMING:  do_homing_sequence(%d) do_homing_sequence joint %d PK_PEAxisState_axHOME\n",current_sequence, jno);
                        homed_count++;
                    }
                    
                    break;

                case PK_PEAxisState_axHOMINGSTART:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axHOMINGSTART\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axHOMINGSEARCH:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axHOMINGSEARCH\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axHOMINGBACK:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axHOMINGBACK\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axERROR:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d PK_PEAxisState_axERROR\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_IDLE;
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGCANCEL;
                    break;

                default:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) joint %d unknown state '%d'\n",current_sequence, jno, int_AxesState);
                    break;
            }
        }
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS homed_count:%d joints_in_sequence:%d\n",current_sequence,homed_count,joints_in_sequence);
        if (homed_count == joints_in_sequence)
        {
            if (addr.is_last)
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: last do_homing_sequence(%d) finished\n", current_sequence);
                sequence_state = HOME_SEQUENCE_IDLE;
                homing_active = 0;
            }
            else
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) finished continue with sequence(%d) \n", current_sequence,addr.next_sequence);
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                current_sequence = addr.next_sequence;
            }
        }
        break;

    default:
        /* should never get here */
        rtapi_print_msg(RTAPI_MSG_DBG, "unknown state '%d' during homing sequence",
                        sequence_state);
        sequence_state = HOME_SEQUENCE_IDLE;
        homing_active = 0;
        break;
    }
    return;
} // do_homing_sequence()


bool do_homing(void)
{
    int joint_num;
    int homing_flag = 0;
    bool beginning_allhomed = get_allhomed();

    
    if (sequence_state != HOME_SEQUENCE_IDLE)
    {
       // check_home_sequence(current_sequence);
       do_homing_sequence();
    }
    

    /* loop thru joints, treat each one individually */
    for (joint_num = 0; joint_num < all_joints; joint_num++)
    {
        if (!H[joint_num].joint_in_sequence)
        {
            continue;
        }
        if (!GET_JOINT_ACTIVE_FLAG(&joints[joint_num]))
        {
            continue;
        }


        homing_flag += pokeys_1joint_state_machine(joint_num);
    }
    // return 1 if homing completed this period
    if (!beginning_allhomed && get_allhomed())
    {
        homing_active = 0;
        return 1;
    }
    return 0;
}

void set_unhomed(int jno, motion_state_t motstate)
{
    // one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
    H[jno].homed = 0;
    return;
}
void do_cancel_homing(int jno)
{
    // one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGCANCEL;
    return;
}

void set_joint_homing_params(int jno,
                             double offset,
                             double home,
                             double home_final_vel,
                             double home_search_vel,
                             double home_latch_vel,
                             int home_flags,
                             int home_sequence,
                             bool volatile_home)
{
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: set_joint_homing_params(%d) offset:%f home:%f home_final_vel:%f home_search_vel:%f home_latch_vel:%f home_flags:%d home_sequence:%d volatile_home:%d\n", jno, offset, home, home_final_vel, home_search_vel, home_latch_vel, home_flags, home_sequence, volatile_home);
    H[jno].offset = offset;
    H[jno].home = home;
    H[jno].home_final_vel = home_final_vel;
    H[jno].home_search_vel = home_search_vel;
    H[jno].home_latch_vel = home_latch_vel;
    H[jno].home_flags = home_flags;
    H[jno].home_sequence = home_sequence;
    H[jno].volatile_home = volatile_home;

    update_sequence_home_data();
    return;
}
void update_joint_homing_params(int jno,
                                double offset,
                                double home,
                                int home_sequence)
{
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: update_joint_homing_params(%d) offset:%f home:%f home_sequence:%d\n", jno, offset, home, home_sequence);
    H[jno].offset = offset;
    H[jno].home = home;
    H[jno].home_sequence = home_sequence;

    update_sequence_home_data();

    return;
}

#endif // } end SKELETON example minimal api implementation
//=====================================================================

// all home functions for homing api
EXPORT_SYMBOL(homeMotFunctions);

EXPORT_SYMBOL(homing_init);
EXPORT_SYMBOL(do_homing);
EXPORT_SYMBOL(get_allhomed);
EXPORT_SYMBOL(get_homed);
EXPORT_SYMBOL(get_home_is_idle);
EXPORT_SYMBOL(get_home_is_synchronized);
EXPORT_SYMBOL(get_home_needs_unlock_first);
EXPORT_SYMBOL(get_home_sequence);
EXPORT_SYMBOL(get_homing);
EXPORT_SYMBOL(get_homing_at_index_search_wait);
EXPORT_SYMBOL(get_homing_is_active);
EXPORT_SYMBOL(get_index_enable);
EXPORT_SYMBOL(read_homing_in_pins);
EXPORT_SYMBOL(do_home_joint);
EXPORT_SYMBOL(do_home_all);
EXPORT_SYMBOL(do_cancel_homing);
EXPORT_SYMBOL(set_unhomed);
EXPORT_SYMBOL(set_joint_homing_params);
EXPORT_SYMBOL(update_joint_homing_params);
EXPORT_SYMBOL(write_homing_out_pins);

#undef XSTR
#undef STR
#undef HOMING_BASE
#undef USE_HOMING_BASE
#undef CUSTOM_HOMEMODULE
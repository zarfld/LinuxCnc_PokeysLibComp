component pokeys_homecomp "homing module template";

description """
Example of a homing module buildable with halcompile.
Demonstrates required code for #includes, function definitions, etc.

If \\fBHOMING_BASE\\fR is #defined and points to a valid homing.c file,
an example of a customized homing module is built.  This module
creates input hal pins joint.n.request-custom-homing that enable an
alternate joint homing state machine for requested joints.  A hal output
pin joint.N.is_custom-homing verifies selection"

The customized homing module utilizes many of the base homing api
routines from homing.c without modification but augments other base
functions to add support for custom hal pins and custom joint homing
state machines.  A user-built module will likely replace additional
api functions or augment them with other customizations.

If \\fBHOMING_BASE\\fR Is not #defined, an  actual homing scheme is
\\fBnot\\fR implemented but all necessary functions are included as
skeleton code.   (All joints are effectively homed at all times and
cannot be unhomed).

See the source code file: src/emc/motion/homing.c for the baseline
implementation that includes all functions for the default \\fBhomemod\\fR
module.

To avoid updates that overwrite homecomp.comp, best practice is
to rename the file and its component name (example:
\\fBuser_homecomp.comp, user_homecomp\\fR).

The (renamed) component can be built and installed with
halcompile and then substituted for the default homing module
(\\fBhomemod\\fR) using:\n
  $ linuxcnc \\fB-m user_homecomp\\fR someconfig.ini\n
or by inifile setting: \\fB[EMCMOT]HOMEMOD=user_homecomp\\fR

\\fBNote:\\fRIf using a deb install:\n
1) halcompile is provided by the package linuxcnc-dev\n
2) This source file for BRANCHNAME (master,2.9,etc) is downloadable from github:\n
https://github.com/LinuxCNC/linuxcnc/blob/BRANCHNAME/src/hal/components/homecomp.comp
""";

pin out bit is_module=1; //one pin is required to use halcompile)

license "GPL";
author "Dewey Garrett";
option homemod;
option extra_setup;
;;

/* To incorporate default homing.c file from a local git src tree:
** enable #define HOMING_BASE set to the path to the current homing.c file.
** (Note: CUSTOM_HOMEMODULE precludes duplicate api symbols)
** (Edit myname as required for valid path)
*/

// #define HOMING_BASE /home/myname/linuxcnc-dev/src/emc/motion/homing.c

#define STR(s) #s
#define XSTR(s) STR(s)

#include "motion.h"
#include "homing.h"
#include <stdlib.h>

static char *home_parms;
RTAPI_MP_STRING(home_parms, "Example home parms");

// EXTRA_SETUP is executed before rtapi_app_main()
EXTRA_SETUP()
{
    if (!home_parms)
    {
        home_parms = "no_home_parms";
    }
    rtapi_print("@@@%s:%s: home_parms=%s\n", __FILE__, __FUNCTION__, home_parms);
#ifndef HOMING_BASE
    rtapi_print("\n!!!%s: Skeleton Homing Module\n\n", __FILE__);
#else
    rtapi_print("\n!!!%s: HOMING_BASE=%s\n"
                "!!!Customize using hal pin(s): joint.N.request-custom-homing\n",
                __FILE__, XSTR(HOMING_BASE));
#endif

    return 0;
}

//=====================================================================
// All (skeleton) functions required for homing api follow:
static emcmot_joint_t *joints;
static bool homing_active = 0;
static bool homing_active_old = 0;
static int all_joints = 0;
static int current_sequence = 0;

typedef enum
{
    HOME_SEQUENCE_IDLE = 0,
    HOME_SEQUENCE_START,
    HOME_SEQUENCE_DO_ONE_JOINT,
    HOME_SEQUENCE_DO_ONE_SEQUENCE,
    HOME_SEQUENCE_START_JOINTS,
    HOME_SEQUENCE_WAIT_JOINTS
} home_sequence_state_t;
static home_sequence_state_t sequence_state = HOME_SEQUENCE_IDLE;

typedef enum
{
    PK_PEAxisState_axSTOPPED = 0, // Axis is stopped
    PK_PEAxisState_axREADY = 1,   // Axis ready
    PK_PEAxisState_axRUNNING = 2, // Axis is running

    PK_PEAxisState_axHOMING_RESETTING = 8,   // Stopping the axis to reset the position counters
    PK_PEAxisState_axHOMING_BACKING_OFF = 9, // Backing off switch
    PK_PEAxisState_axHOME = 10,              // Axis is homed
    PK_PEAxisState_axHOMINGSTART = 11,       // Homing procedure is starting on axis
    PK_PEAxisState_axHOMINGSEARCH = 12,      // Homing procedure first step - going to home
    PK_PEAxisState_axHOMINGBACK = 13,        // Homing procedure second step - slow homing

    PK_PEAxisState_axPROBED = 14,      // Probing completed for this axis
    PK_PEAxisState_axPROBESTART = 15,  // Probing procedure is starting on axis
    PK_PEAxisState_axPROBESEARCH = 16, // Probing procedure - probing

    PK_PEAxisState_axERROR = 20, // Axis error
    PK_PEAxisState_axLIMIT = 30  // Axis limit tripped
} pokeys_home_state_t;

typedef enum
{
    PK_PEAxisCommand_axIDLE = 0,           // Axis  in IDLE
    PK_PEAxisCommand_axHOMINGSTART = 1,    // Start Homing procedure
    PK_PEAxisCommand_axHOMINGCANCEL = 2,   // Cancel Homing procedure
    PK_PEAxisCommand_axHOMINGFINALIZE = 3, // Finish Homing procedure
} pokeys_home_command_t;

typedef enum
{
    HOME_IDLE = 0,
    HOME_START,                 // 1
    HOME_UNLOCK,                // 2
    HOME_UNLOCK_WAIT,           // 3
    HOME_INITIAL_BACKOFF_START, // 4
    HOME_INITIAL_BACKOFF_WAIT,  // 5
    HOME_INITIAL_SEARCH_START,  // 6
    HOME_INITIAL_SEARCH_WAIT,   // 7
    HOME_SET_COARSE_POSITION,   // 8
    HOME_FINAL_BACKOFF_START,   // 9
    HOME_FINAL_BACKOFF_WAIT,    // 10
    HOME_RISE_SEARCH_START,     // 11
    HOME_RISE_SEARCH_WAIT,      // 12
    HOME_FALL_SEARCH_START,     // 13
    HOME_FALL_SEARCH_WAIT,      // 14
    HOME_SET_SWITCH_POSITION,   // 15
    HOME_INDEX_ONLY_START,      // 16
    HOME_INDEX_SEARCH_START,    // 17
    HOME_INDEX_SEARCH_WAIT,     // 18
    HOME_SET_INDEX_POSITION,    // 19
    HOME_FINAL_MOVE_START,      // 20
    HOME_FINAL_MOVE_WAIT,       // 21
    HOME_LOCK,                  // 22
    HOME_LOCK_WAIT,             // 23
    HOME_FINISHED,              // 24
    HOME_ABORT                  // 25
} local_home_state_t;

// data for per-joint homing-specific hal pins:
typedef struct
{
    hal_bit_t *home_sw;      // home switch input
    hal_bit_t *homing;       // joint is homing
    hal_bit_t *homed;        // joint was homed
    hal_bit_t *index_enable; // motmod sets: request reset on index
                             //        encoder clears: index arrived
    hal_s32_t *home_state;   // homing state machine state

    // Custom Pins for comunication with PoKeys
    hal_u32_t *PEv2_AxesState;   // State of pulse engine - see ePoKeysPEState
    hal_u32_t *PEv2_AxesCommand; // Commands to  pulse engine - see ePoKeysPECmd

} one_joint_home_data_t;

typedef struct
{
    // pin data for all joints
    bool home_sw;
    bool homing;
    bool homed;
    bool index_enable;
    local_home_state_t home_state;

    // Custom Pins for comunication with PoKeys
    pokeys_home_state_t PEv2_AxesState;
    pokeys_home_command_t PEv2_AxesCommand;

    // homeparams
    double offset;
    double home;
    double home_final_vel;
    double home_search_vel;
    double home_latch_vel;
    int home_flags;
    int home_sequence;
    bool volatile_home;

    bool home_is_synchronized;

    bool joint_in_sequence;
} home_local_data;

static home_local_data H[EMCMOT_MAX_JOINTS];

typedef struct
{
    one_joint_home_data_t jhd[EMCMOT_MAX_JOINTS];

} all_joints_home_data_t;

static all_joints_home_data_t *joint_home_data = 0;

typedef struct
{
    int home_sequence; // my sequence ID
    bool homing;
    bool homed;

    int joints_in_sequence;
    int joint_ids[EMCMOT_MAX_JOINTS];

    bool is_last;
    int next_sequence;

    local_home_state_t home_state;

} one_sequence_home_data_t;

typedef struct
{
    one_sequence_home_data_t shd[EMCMOT_MAX_JOINTS];
    int sequence_count;

    int min_sequence;
    int max_sequence;

    int current_sequence;

} all_sequences_home_data_t;

static all_sequences_home_data_t sequence_home_data;
static bool allhomed = 0;
static int makepins(int id, int njoints)
{
    // home_pins needed to work with configs expecting them:
    int jno, retval;
    one_joint_home_data_t *addr;

    joint_home_data = hal_malloc(sizeof(all_joints_home_data_t));
    if (joint_home_data == 0)
    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: all_joints_home_data_t malloc failed\n");
        return -1;
    }

    retval = 0;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(joint_home_data->jhd[jno]);

        retval += hal_pin_bit_newf(HAL_IN, &(addr->home_sw), id,
                                   "joint.%d.home-sw-in", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homing), id,
                                   "joint.%d.homing", jno);
        retval += hal_pin_bit_newf(HAL_OUT, &(addr->homed), id,
                                   "joint.%d.homed", jno);
        retval += hal_pin_s32_newf(HAL_OUT, &(addr->home_state), id,
                                   "joint.%d.home-state", jno);
        retval += hal_pin_bit_newf(HAL_IO, &(addr->index_enable), id,
                                   "joint.%d.index-enable", jno);

        // add custom hal pins here:
        retval += hal_pin_u32_newf(HAL_IN, &(addr->PEv2_AxesState), id,
                                   "joint.%d.PEv2.AxesState", jno);
        retval += hal_pin_u32_newf(HAL_OUT, &(addr->PEv2_AxesCommand), id,
                                   "joint.%d.PEv2.AxesCommand", jno);
        /*retval += hal_pin_s32_newf(HAL_IO, &(addr->home_sequence), id,
                                      "joint.%d.home_sequence", jno);*/
    }
    return retval;
}
// All (skeleton) functions required for homing api follow:
void homeMotFunctions(void (*pSetRotaryUnlock)(int, int), int (*pGetRotaryIsUnlocked)(int))
{
    return;
}

static void update_sequence_home_data(void)
{
    int min_sequence = abs(H[0].home_sequence);
    int max_sequence = abs(H[0].home_sequence);
    int sequence_count = 0;
    int current_sequence = 0;
    
    for(int jno = 0; jno < all_joints; jno++)
    {
        int seq = abs(H[jno].home_sequence);
        if (seq < min_sequence)
        {
            min_sequence = seq; // find min sequence    
        }
        if (seq > max_sequence)
        {
            max_sequence = seq; // find max sequence
        }
    }
    sequence_count = max_sequence - min_sequence + 1;
    rtapi_print_msg(RTAPI_MSG_DBG,"HOMING: update_sequence_home_data(min_sequence:%d  to max_sequence:%d)\n", min_sequence, max_sequence);
    sequence_home_data.min_sequence = min_sequence;
    sequence_home_data.max_sequence = max_sequence;
    sequence_home_data.sequence_count = sequence_count;

    for(int sno=min_sequence; sno<=max_sequence; sno++)
    {
        one_sequence_home_data_t saddr = (sequence_home_data.shd[sno]);
        sequence_home_data.shd[sno].home_sequence = sno;
        //saddr.homing = 0; should not interrupt homing
        //saddr.homed = 0;
        sequence_home_data.shd[sno].joints_in_sequence = 0;
        if(sno == max_sequence)
        {
            sequence_home_data.shd[sno].is_last = 1;
            sequence_home_data.shd[sno].next_sequence = 0;
        }
        else
        {
            sequence_home_data.shd[sno].is_last = 0;
            sequence_home_data.shd[sno].next_sequence = sno+1;
        }

        
        sequence_home_data.shd[sno].home_state = HOME_IDLE;

        for(int jno = 0; jno < all_joints; jno++)
        {
            if (abs(H[jno].home_sequence) == sno)
            {
                sequence_home_data.shd[sno].joint_ids[saddr.joints_in_sequence] = jno;
                sequence_home_data.shd[sno].joints_in_sequence++;
            }
        }

        rtapi_print_msg(RTAPI_MSG_DBG,"HOMING: update_sequence_home_data(%d) joints_in_sequence:%d\n", sno, sequence_home_data.shd[sno].joints_in_sequence);
    }
}


int homing_init(int id,
                double servo_period,
                int n_joints,
                int n_extrajoints,
                emcmot_joint_t *pjoints)
{
    joints = pjoints;
    all_joints = n_joints;
    return makepins(id, n_joints);

    // initialize jid[] and jhd[] data here
    for (int jno = 0; jno < EMCMOT_MAX_JOINTS; jno++)
    {

        H[jno].offset = 0;
        H[jno].home = 0;
        H[jno].home_final_vel = 0;
        H[jno].home_search_vel = 0;
        H[jno].home_latch_vel = 0;
        H[jno].home_flags = 0;
        H[jno].home_sequence = 0;
        H[jno].volatile_home = 1;

        one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
        H[jno].home_sw = 0;
        H[jno].homing = 0;
        H[jno].homed = 0;
        H[jno].home_state = HOME_IDLE;
        H[jno].index_enable = 0;
        H[jno].PEv2_AxesState = PK_PEAxisState_axSTOPPED;
        H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;

        one_sequence_home_data_t saddr = (sequence_home_data.shd[jno]);
        saddr.home_sequence = 0;
        saddr.homing = 0;
        saddr.homed = 0;
        saddr.joints_in_sequence = 0;
        saddr.is_last = 0;
        saddr.next_sequence = 0;
        saddr.home_state = HOME_IDLE;

    }
}

bool get_sequence_homed(int seq)
{
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    int joints_in_sequence = addr.joints_in_sequence;

    for (int jj = 0; jj < joints_in_sequence; jj++)
    {
        int jno = addr.joint_ids[jj];
        if (!H[jno].homed)
        {
            return 0;
        }
    }
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: get_sequence_homed(%d) TRUE\n", seq);
    return 1;
}

bool get_sequence_homing(int seq)
{
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    int joints_in_sequence = addr.joints_in_sequence;

    for (int jj = 0; jj < joints_in_sequence; jj++)
    {
        int jno = addr.joint_ids[jj];
        if (H[jno].homing)
        {
            return 1;
        }
    }

    return 0;
}

int pokeys_1joint_state_machine(int joint_num){
    emcmot_joint_t *joint;
    double offset, tmp;
    int home_sw_active, homing_flag;
    bool immediate_state = 0;

    homing_flag = 0;
    joint = &joints[joint_num];
    home_sw_active = H[joint_num].home_sw;
    /*if (H[joint_num].home_state != HOME_IDLE)
    {
        homing_flag = 1; // at least one joint is homing 
    }*/

    /* when a joint is homing, 'check_for_faults()' ignores its limit
       switches, so that this code can do the right thing with them. Once
       the homing process is finished, the 'check_for_faults()' resumes
       checking */

    /* homing state machine */

    /* Some portions of the homing sequence can run thru two or more
       states during a single servo period.  This is done using
       'immediate_state'.  If a state transition sets it true (non-zero),
       this 'do-while' will loop executing switch(home_state) immediately
       to run the new state code.  Otherwise, the loop will fall thru, and
       switch(home_state) runs only once per servo period. Do _not_ set
       'immediate_state' true unless you also change 'home_state', unless
       you want an infinite loop! */
    do    {
        immediate_state = 0;
        switch (H[joint_num].PEv2_AxesState)        {
        case PK_PEAxisState_axSTOPPED:
            /* Axis is stopped */
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d stopped\n", joint_num);
            H[joint_num].homing = 0;
            H[joint_num].homed = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axREADY:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d ready\n", joint_num);
            /* Axis ready */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axRUNNING:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d running\n", joint_num);
            /* Axis is running */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axHOMING_RESETTING:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing resetting\n", joint_num);
            /* Stopping the axis to reset the position counters */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_UNLOCK;
            H[joint_num].homed = 0;
            homing_flag = 1;
            break;

        case PK_PEAxisState_axHOMING_BACKING_OFF:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing backing off\n", joint_num);
            /* Backing off switch */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_INITIAL_BACKOFF_WAIT;
            homing_flag = 1;
            break;

        case PK_PEAxisState_axHOME:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homed\n", joint_num);
            /* Axis is homed */
            int joints_in_sequence = 0;
            int homed_in_sequence = 0;
            int jj;
            for (jj = 0; jj < all_joints; jj++)
            {
                if (abs(H[jj].home_sequence) == abs(H[joint_num].home_sequence))
                {
                    joints_in_sequence++;
                    if (H[jj].PEv2_AxesState == PK_PEAxisState_axHOME)
                    {
                        homed_in_sequence++;
                    }
                }
            }

            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:PK_PEAxisState_axHOME joint %d joints_in_sequence:%d  homed_in_sequence:%d \n",joint_num, joints_in_sequence,homed_in_sequence);
            if (joints_in_sequence == homed_in_sequence)
            {
                //if all Joints of the Sequence show Hommed
                for (jj = 0; jj < all_joints; jj++)
                {

                    if (abs(H[jj].home_sequence) == abs(H[joint_num].home_sequence))
                    {
                        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:do_home_joint.PK_PEAxisState_axHOME joint %d homed (home_sequence %d)\n", jj,H[joint_num].home_sequence);
                        //H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;
                        H[jj].home_state = HOME_FINISHED;
                        H[jj].homing = 0;
                        H[jj].homed = 1;
                    }
                }
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:do_home_joint.PK_PEAxisState_axHOME joint %d homed (home_sequence %d)\n", joint_num,H[joint_num].home_sequence);
                //H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;
                H[joint_num].home_state = HOME_FINISHED;
                H[joint_num].homing = 0;
                H[joint_num].homed = 1;

            }
           
            break;

        case PK_PEAxisState_axHOMINGSTART:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing start\n", joint_num);
            /* Homing procedure is starting on axis */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_START;
            homing_flag = 1;
            break;

        case PK_PEAxisState_axHOMINGSEARCH:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing search\n", joint_num);
            /* Homing procedure first step - going to home */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_INITIAL_SEARCH_WAIT;
            homing_flag = 1;
            break;

        case PK_PEAxisState_axHOMINGBACK:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d homing back\n", joint_num);
            /* Homing procedure second step - slow homing */
            H[joint_num].homing = 1;
            H[joint_num].home_state = HOME_FINAL_BACKOFF_START;
            homing_flag = 1;
            break;

        case PK_PEAxisState_axPROBED:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d probed\n", joint_num);
            /* Probing completed for this axis */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
           
            break;

        case PK_PEAxisState_axPROBESTART:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d probed start\n", joint_num);
            /* Probing procedure is starting on axis */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axPROBESEARCH:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d probe search\n", joint_num);
            /* Probing procedure - probing */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axERROR:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d error\n", joint_num);
            /* Axis error */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        case PK_PEAxisState_axLIMIT:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine joint %d limit\n", joint_num);
            /* Axis limit tripped */
            H[joint_num].homing = 0;
            H[joint_num].home_state = HOME_IDLE;
            break;

        default:
            /* should never get here */
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: pokeys_1joint_state_machine unknown state '%d' during homing j=%d", H[joint_num].home_state, joint_num);
            H[joint_num].home_state = HOME_ABORT;
           // immediate_state = 1;
            break;
        } /* end of switch(H[joint_num].home_state) */
    } while (immediate_state);

    return homing_flag;
} // pokeys_1joint_state_machine()


void do_home_sequence(int seq){
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    sequence_home_data.current_sequence = seq;

    int joints_in_sequence = addr.joints_in_sequence;

    current_sequence = seq;
    sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;

    for (int jj = 0; jj < joints_in_sequence; jj++)    {
        int jno = addr.joint_ids[jj];
        pokeys_1joint_state_machine(jno);

        H[jno].homed = 0;
        H[jno].homing = 1;
        H[jno].home_state = HOME_START;
        H[jno].joint_in_sequence = 1;
        
        int int_AxesState = H[jno].PEv2_AxesState;
        switch (int_AxesState)        {
            case PK_PEAxisState_axSTOPPED:
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_sequence joint %d stopped\n", jno);
                H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                break;

            case PK_PEAxisState_axREADY:
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_sequence joint %d ready\n", jno);
                H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                break;

            default:
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_sequence joint %d unknown state %d\n", jno, int_AxesState);
                break;
        }
    }
    return;
}

void check_home_sequence(int seq){
    if (sequence_state != HOME_SEQUENCE_DO_ONE_SEQUENCE)    {
        return;
    }
     
    one_sequence_home_data_t addr = (sequence_home_data.shd[seq]);
    int joints_in_sequence = addr.joints_in_sequence;

    if (addr.homed)    {
        if (addr.is_last)        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: check_home_sequence sequence %d homed - finished\n", seq);
            sequence_state = HOME_SEQUENCE_IDLE;
        }
        else        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: check_home_sequence sequence %d homed - next sequ.\n", seq);
            sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
            do_home_sequence(addr.next_sequence);
        }
        return;
    }
    else if (addr.homing)
    {
        if (get_sequence_homed(seq))
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: check_home_sequence sequence %d homed\n", seq);
            //addr.homed = 1;
            //addr.homing = 0;
            addr.home_state = HOME_FINISHED;
            if (addr.is_last)
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: check_home_sequence sequence %d sequence_state = HOME_SEQUENCE_IDLE\n", seq);
                sequence_state = HOME_SEQUENCE_IDLE;
            }
            else
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                do_home_sequence(addr.next_sequence);
            }
        }
        else if (get_sequence_homing(seq))
        {
            addr.homed = 0;
            addr.homing = 1;
            addr.home_state = HOME_START;
        }
        else
        {
            addr.homed = 0;
            addr.homing = 0;
            addr.home_state = HOME_IDLE;
        }
    }
}

bool get_allhomed()
{
   /* int ret = 1;
    for (int jno = 0; jno < EMCMOT_MAX_JOINTS; jno++)
    {
        
        one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
        if (!*addr->homed)
        {
            ret = 0;
            break;
        }
        //usleep(10); // Add a small delay to prevent CPU hogging
    }
    if(ret==1){
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: get_allhomed homed %d\n", ret);
    }*/
    return allhomed;
    //return ret ? 1 : 0;
}
bool get_homed(int jno)
{
    if(H[jno].homed==1){
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: get_homed homed %d\n", H[jno].homed);
    }
    return H[jno].homed ? 1 : 0;
}
bool get_home_is_idle(int jno)
{
    return H[jno].home_state == HOME_IDLE ? 1 : 0;
}
bool get_home_is_synchronized(int jno)
{
    return H[jno].home_is_synchronized ? 1 : 0;
}
bool get_home_needs_unlock_first(int jno)
{
    return (H[jno].home_flags & HOME_UNLOCK_FIRST) ? 1 : 0;
}
int get_home_sequence(int jno)
{
    return H[jno].home_sequence;
}
bool get_homing(int jno)
{
    one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);

    return *addr->homing ? 1 : 0;
}

bool get_homing_at_index_search_wait(int jno) { return 0; }
bool get_homing_is_active()
{
    if (homing_active != homing_active_old)
    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: get_homing_is_active ==  %d\n", homing_active);
        homing_active_old = homing_active;
    }
    return homing_active;
}
bool get_index_enable(int jno)
{
    return H[jno].index_enable ? 1 : 0;
}
void read_homing_in_pins(int njoints)
{
    int jno;
    int org_state;
    one_joint_home_data_t *addr;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(joint_home_data->jhd[jno]);
        H[jno].home_sw = *(addr->home_sw);           // IN
        H[jno].index_enable = *(addr->index_enable); // IN
        org_state = H[jno].PEv2_AxesState;
        H[jno].PEv2_AxesState = *(addr->PEv2_AxesState); // IN

        if (H[jno].PEv2_AxesState != org_state)
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: read_homing_in_pins joint %d state changed :%d\n", jno, H[jno].PEv2_AxesState);
        }
    }
    return;
}

void write_homing_out_pins(int njoints)
{
    int jno;
    one_joint_home_data_t *addr;
    int org_cmd;
    for (jno = 0; jno < njoints; jno++)
    {
        addr = &(joint_home_data->jhd[jno]);
        *(addr->homing) = H[jno].homing;                     // OUT
        *(addr->homed) = H[jno].homed;                       // OUT
        *(addr->home_state) = H[jno].home_state;             // OUT
        org_cmd = *(addr->PEv2_AxesCommand);
        *(addr->PEv2_AxesCommand) = H[jno].PEv2_AxesCommand; // OUT
        if (org_cmd != H[jno].PEv2_AxesCommand)
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: write_homing_out_pins joint %d command changed :%d\n", jno, H[jno].PEv2_AxesCommand);
        }
    }
  //  rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: write_homing_out_pins\n");
    return;
}

void do_home_all(void)
{
    if (!get_homing_is_active())
    {
        sequence_state = HOME_SEQUENCE_START;
    }
    return;
} // do_home_all()

void do_home_joint(int jno){
    if (jno >= 0)    {
        // one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
        pokeys_1joint_state_machine(jno);
        int int_AxesState = H[jno].PEv2_AxesState;
        switch (int_AxesState)        {
        case PK_PEAxisState_axHOMING_RESETTING:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing resetting PK_PEAxisCommand_axIDLE\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMING_BACKING_OFF:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing backing off PK_PEAxisCommand_axIDLE\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMINGSTART:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing start - PK_PEAxisCommand_axIDLE\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMINGSEARCH:
           rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing search - PK_PEAxisCommand_axIDLE\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOMINGBACK:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d homing back - PK_PEAxisCommand_axIDLE\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axIDLE;
            break;
        case PK_PEAxisState_axHOME:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:do_home_joint.PK_PEAxisState_axHOME do_home_joint joint %d homed (home_sequence %d)\n", jno,H[jno].home_sequence);
            
            // check if all joints in sequence are homed
            if (H[jno].home_sequence < 0)
            {

                int joints_in_sequence = 0;
                int homed_in_sequence = 0;
                int jj;
                for (jj = 0; jj < all_joints; jj++)
                {
                    if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                    {
                        joints_in_sequence++;
                        if (H[jj].PEv2_AxesState == PK_PEAxisState_axHOME)
                        {
                            homed_in_sequence++;
                        }
                    }
                }

                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:PK_PEAxisState_axHOME joint %d joints_in_sequence:%d  homed_in_sequence:%d \n",jno, joints_in_sequence,homed_in_sequence);
                if (joints_in_sequence == homed_in_sequence)
                {
                    //if all Joints of the Sequence show Hommed
                        for (jj = 0; jj < all_joints; jj++)
                        {

                            if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                            {
                                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:do_home_joint.PK_PEAxisState_axHOME joint %d homed (home_sequence %d)\n", jj,H[jno].home_sequence);
                                H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;
                            }
                        }
                        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:do_home_joint.PK_PEAxisState_axHOME joint %d homed (home_sequence %d)\n", jno,H[jno].home_sequence);
                        H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;

                }
            }
            else
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:do_home_joint.PK_PEAxisState_axHOME joint %d homed (home_sequence %d)\n", jno,H[jno].home_sequence);
                H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGFINALIZE;
            }
            break;
        case PK_PEAxisState_axSTOPPED:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d stopped\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
            H[jno].home_state = HOME_START;
            if (H[jno].home_sequence < 0)
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                int jj;
                for (jj = 0; jj < all_joints; jj++)
                {
                    if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                    {
                        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint %d in sequence %d PK_PEAxisCommand_axHOMINGSTART\n", jj, H[jno].home_sequence);
                        H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                        H[jj].home_state = HOME_START;
                    }
                }
            }
            else
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_JOINT;
            }

            break;
        case PK_PEAxisState_axREADY:
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint %d ready PK_PEAxisCommand_axHOMINGSTART\n", jno);
            H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
            H[jno].home_state = HOME_START;
            if (H[jno].home_sequence < 0)
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                int jj;
                for (jj = 0; jj < all_joints; jj++)
                {
                    if (abs(H[jj].home_sequence) == abs(H[jno].home_sequence))
                    {
                        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint %d in sequence %d PK_PEAxisCommand_axHOMINGSTART\n", jj, H[jj].home_sequence);
                        H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                        H[jj].home_state = HOME_START;
                    }
                }
            }
            else
            {
                sequence_state = HOME_SEQUENCE_DO_ONE_JOINT;
            }

            break;

        default:
            break;
        }
    }
    else
    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_home_joint joint number %d out of range\n", jno);

        // triger homing for first sequence (index 0)

        //do_home_sequence(0);
        update_sequence_home_data();
        sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
        int jj;
        current_sequence = 0;
        int trigered = 0;
        for (jj = 0; jj < all_joints; jj++)
        {
            if (abs(H[jj].home_sequence) == abs(sequence_home_data.min_sequence))
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint %d in sequence %d PK_PEAxisCommand_axHOMINGSTART\n", jj, sequence_home_data.min_sequence);
                H[jj].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                H[jno].home_state = HOME_START;
                trigered ++;
            }
            else
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: joint %d not in sequence %d\n", jj, sequence_home_data.min_sequence);
            }
            
        }

        if(trigered == 0)
        {
            rtapi_print_msg(RTAPI_MSG_WARN, "HOMING: no joints in sequence %d\n", sequence_home_data.shd[current_sequence].home_sequence);
        }
    }
    return;
}


/* 'do_homing_sequence()' decides what, if anything, needs to be done
    related to multi-joint homing.

*/
static void do_homing_sequence(void) {
    int i, ii;
    int seen;
    emcmot_joint_t *joint;
    int sequence_is_set = 0;
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:>do_homing_sequence(%d) sequence_state = %d\n",current_sequence,sequence_state);
    if(current_sequence <sequence_home_data.min_sequence || current_sequence >sequence_home_data.max_sequence)    {
        // no sequence set, use the first one
        current_sequence = sequence_home_data.min_sequence ;
    }
    one_sequence_home_data_t addr = (sequence_home_data.shd[current_sequence]);
    int joints_in_sequence = addr.joints_in_sequence;
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) joints_in_sequence = %d\n",current_sequence,joints_in_sequence);
    switch (sequence_state)    {
    case HOME_SEQUENCE_IDLE:
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence HOME_SEQUENCE_IDLE\n");
        current_sequence = sequence_home_data.min_sequence;
        /* nothing to do */
        break;

    case HOME_SEQUENCE_DO_ONE_JOINT:
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence HOME_SEQUENCE_DO_ONE_JOINT\n");
        update_sequence_home_data();
        // Expect one joint with home_state==HOME_START
        int joints_in_sequence_DBG = 0;
        one_sequence_home_data_t addr_dbg ;
        for (i = 0; i < all_joints; i++)
        {
            //pokeys_1joint_state_machine(i);
            if (H[i].home_state == HOME_START)
            {
                H[i].joint_in_sequence = 1; // in sequence
                H[i].homed = 0;
                H[i].homing = 1;
                joints_in_sequence_DBG++;
                addr_dbg.joints_in_sequence=joints_in_sequence_DBG;
                addr_dbg.joint_ids[joints_in_sequence_DBG] = i;
                current_sequence = abs(H[i].home_sequence);
                addr = (sequence_home_data.shd[current_sequence]);
                joints_in_sequence = addr.joints_in_sequence; //count of all joints in sequence
            }
            else
            {
                H[i].joint_in_sequence = 0; // not in sequence
            }
        }
        sequence_is_set = 1;
        /*if (current_sequence ==0) 
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_DO_ONE_JOINT current_sequence = 0\n",current_sequence);
            current_sequence=sequence_home_data.min_sequence;
            addr = (sequence_home_data.shd[current_sequence]);
            joints_in_sequence = addr.joints_in_sequence; //count of all joints in sequence
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) use first HOME_SEQUENCE_DO_ONE_JOINT joints_in_sequence = %d, new current_sequence = %d\n",current_sequence,joints_in_sequence);
        }*/
        
        if (joints_in_sequence==0)
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_DO_ONE_JOINT joints_in_sequence = 0\n",current_sequence);
            update_sequence_home_data();
            //sequence_state = HOME_SEQUENCE_IDLE;
             addr = (sequence_home_data.shd[current_sequence]);
            joints_in_sequence = addr.joints_in_sequence; //count of all joints in sequence
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) after update HOME_SEQUENCE_DO_ONE_JOINT joints_in_sequence = %d \n",current_sequence,joints_in_sequence);
        

            break;
        }
        else
        {
            sequence_state = HOME_SEQUENCE_START;
        }
        // drop through----drop through----drop through----drop through
        
        break;

    case HOME_SEQUENCE_DO_ONE_SEQUENCE:
        // Expect multiple joints with home_state==HOME_START
        // specified by a negative sequence
        // Determine current_sequence and set H[i].joint_in_sequence
        // based on home_state[i] == HOME_START
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_DO_ONE_SEQUENCE joints_in_sequence = %d\n",current_sequence,joints_in_sequence);


        for (int jj = 0; jj < joints_in_sequence; jj++)
        {
            int jno = addr.joint_ids[jj];
            pokeys_1joint_state_machine(jno);
            H[jno].homed = 0;
            H[jno].homing = 1;
            H[jno].joint_in_sequence = 1;
            H[jno].home_state = HOME_START;
        }
      
        sequence_state = HOME_SEQUENCE_START;
        break;
        // drop through----drop through----drop through----drop through

    case HOME_SEQUENCE_START:
        // Request to home all joints or a single sequence
        sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
        allhomed = 0;
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START\n",current_sequence);
        for (int jj = 0; jj < joints_in_sequence; jj++)
        {
            int jno = addr.joint_ids[jj];
            pokeys_1joint_state_machine(jno);
            int int_AxesState = H[jno].PEv2_AxesState;
            switch (int_AxesState)
            {
                case PK_PEAxisState_axSTOPPED:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START joint %d stopped PK_PEAxisCommand_axHOMINGSTART\n",current_sequence, jno);
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                    break;

                case PK_PEAxisState_axREADY:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START joint %d ready PK_PEAxisCommand_axHOMINGSTART\n",current_sequence, jno);
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                    break;

                case PK_PEAxisState_axRUNNING:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START joint %d running PK_PEAxisCommand_axHOMINGSTART\n",current_sequence, jno);
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGSTART;
                    break;

                case PK_PEAxisState_axERROR:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START joint %d error PK_PEAxisCommand_axHOMINGCANCEL\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_IDLE;
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGCANCEL;
                    return;
                    break;

                default:
                    break;
            }
        }
 
        /* tell the world we're on the job */
        homing_active = 1;
        break;
        // drop through----drop through----drop through----drop through

    case HOME_SEQUENCE_START_JOINTS:
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START_JOINTS\n",current_sequence);
        seen = 0;
        allhomed = 0;
        /* start all joints whose sequence number matches H[i].home_sequence */
        for (i = 0; i < all_joints; i++)
        {
            joint = &joints[i];
            if (abs(H[i].home_sequence) == current_sequence)
            {
                if (!H[i].joint_in_sequence)
                    continue;
                /* start this joint */
                joint->free_tp.enable = 0;
                H[i].home_state = HOME_START;
                seen++;
            }
        }
        if (seen || current_sequence == 0)
        {
            sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
        }
        else
        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_START_JOINTS no joints in sequence %d\n",current_sequence,current_sequence);
            /* no joints have this sequence number, we're done */
            sequence_state = HOME_SEQUENCE_IDLE;
            /* tell the world */
            homing_active = 0;
        }
        break;

    case HOME_SEQUENCE_WAIT_JOINTS:
       // rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joints_in_sequence: %d \n",current_sequence,joints_in_sequence);
        seen = 0;

        int homed_count = 0;

        for (int jj = 0; jj < joints_in_sequence; jj++)        {
            int jno = addr.joint_ids[jj];
            //pokeys_1joint_state_machine(jno);
            int int_AxesState = H[jno].PEv2_AxesState;
           // rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d AxesState %d\n",current_sequence, jno, int_AxesState);
            switch (int_AxesState)            {
                case PK_PEAxisState_axSTOPPED:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axSTOPPED\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_START_JOINTS; //back to start
                    break;

                case PK_PEAxisState_axREADY:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axREADY\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_START_JOINTS; //back to start
                    break;

                case PK_PEAxisState_axRUNNING:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axRUNNING\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_START_JOINTS; //back to start
                    break;

                case PK_PEAxisState_axHOMING_RESETTING:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axHOMING_RESETTING\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axHOMING_BACKING_OFF:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axHOMING_BACKING_OFF\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;
                
                case PK_PEAxisState_axHOME:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axHOME\n",current_sequence, jno);
                    if(H[jno].homed == 1)
                    {
                        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axHOME flags set ok\n",current_sequence, jno);
                   //     homed_count++;
                    }
                    homed_count++;
                    break;

                case PK_PEAxisState_axHOMINGSTART:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axHOMINGSTART\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axHOMINGSEARCH:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d PK_PEAxisState_axHOMINGSEARCH\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axHOMINGBACK:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d HOME_SEQUENCE_WAIT_JOINTS PK_PEAxisState_axHOMINGBACK\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_WAIT_JOINTS;
                    break;

                case PK_PEAxisState_axERROR:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:  do_homing_sequence(%d) joint %d HOME_SEQUENCE_WAIT_JOINTS PK_PEAxisState_axERROR\n",current_sequence, jno);
                    sequence_state = HOME_SEQUENCE_IDLE;
                    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGCANCEL;
                    break;

                default:
                    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS joint %d unknown state '%d'\n",current_sequence, jno, int_AxesState);
                    break;
            }
        }
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS homed_count:%d joints_in_sequence:%d \n",current_sequence,homed_count,joints_in_sequence);
        if (homed_count == joints_in_sequence)
        {
            if (addr.is_last)
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS last finished\n", current_sequence);
                // is set  in bool do_homing(void) based on pokeys_1joint_state_machine(joint_num)
                //sequence_state = HOME_SEQUENCE_IDLE;
               // homing_active = 0; is set  in bool do_homing(void)
               allhomed = 1;
            }
            else
            {
                rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) HOME_SEQUENCE_WAIT_JOINTS finished continue with sequence(%d) \n", current_sequence,addr.next_sequence);
                sequence_state = HOME_SEQUENCE_DO_ONE_SEQUENCE;
                current_sequence = addr.next_sequence;
            }
        }
        break;

    default:
        /* should never get here */
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing_sequence(%d) unknown state '%d' during homing sequence", current_sequence, sequence_state);
        sequence_state = HOME_SEQUENCE_IDLE;
        homing_active = 0;
        break;
    }
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING:<do_homing_sequence(%d) sequence_state %d\n", current_sequence, sequence_state);
    return;
} // do_homing_sequence()

/* 'do_homing()' looks at the home_state field of each joint struct
    to decide what, if anything, needs to be done related to homing
    the joint.  Homing is implemented as a state machine, the exact
    sequence of states depends on the machine configuration.  It
    can be as simple as immediately setting the current position to
    zero, or a it can be a multi-step process (find switch, set
    approximate zero, back off switch, find index, set final zero,
    rapid to home position), or anywhere in between.
*/
bool do_homing(void){
    int joint_num;
    int homing_flag = 0;
    int active_joints = 0;
    bool beginning_allhomed = get_allhomed();

    
    if (sequence_state != HOME_SEQUENCE_IDLE)    {
       // check_home_sequence(current_sequence);
       rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing sequence_state %d  -  trigger do_homing_sequence()\n", sequence_state);
       do_homing_sequence();
    }
    

    /* loop thru joints, treat each one individually */
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing loop thru joints, treat each one individually\n");
    for (joint_num = 0; joint_num < all_joints; joint_num++)    {
        if (!H[joint_num].joint_in_sequence)        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing joint %d not in sequence\n", joint_num);
            continue;
        }
        if (!GET_JOINT_ACTIVE_FLAG(&joints[joint_num]))        {
            rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing joint %d not active\n", joint_num);
            continue;
        }
        active_joints++;
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing joint %d - pokeys_1joint_state_machine\n", joint_num);
        homing_flag += pokeys_1joint_state_machine(joint_num);
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing joint: %d homing_flag: %d \n", joint_num, homing_flag);
    }
    // return 1 if homing completed this period

    
    bool end_allhomed = get_allhomed();
    if (beginning_allhomed == 0 && end_allhomed == 1 && homing_flag == 0)    {
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing homing completed\n");
        homing_active = 0;
        sequence_state = HOME_SEQUENCE_IDLE;
        return true;
    }
    else{
        rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_homing homing_flag %d\n", homing_flag);
    }
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: beginning_allhomed: %d / end_allhomed: %d  homing_active: %d \n", beginning_allhomed, end_allhomed, homing_active);
    return false;
}

void set_unhomed(int jno, motion_state_t motstate){
    // one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
    H[jno].homed = 0;
    return;
}
void do_cancel_homing(int jno){
    // one_joint_home_data_t *addr = &(joint_home_data->jhd[jno]);
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: do_cancel_homing(%d)\n", jno);
    H[jno].PEv2_AxesCommand = PK_PEAxisCommand_axHOMINGCANCEL;
    return;
}

void set_joint_homing_params(int jno,
                             double offset,
                             double home,
                             double home_final_vel,
                             double home_search_vel,
                             double home_latch_vel,
                             int home_flags,
                             int home_sequence,
                             bool volatile_home)
{
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: set_joint_homing_params(%d) offset:%f home:%f home_final_vel:%f home_search_vel:%f home_latch_vel:%f home_flags:%d home_sequence:%d volatile_home:%d\n", jno, offset, home, home_final_vel, home_search_vel, home_latch_vel, home_flags, home_sequence, volatile_home);
    H[jno].offset = offset;
    H[jno].home = home;
    H[jno].home_final_vel = home_final_vel;
    H[jno].home_search_vel = home_search_vel;
    H[jno].home_latch_vel = home_latch_vel;
    H[jno].home_flags = home_flags;
    H[jno].home_sequence = home_sequence;
    H[jno].volatile_home = volatile_home;

    update_sequence_home_data();
    return;
}
void update_joint_homing_params(int jno,
                                double offset,
                                double home,
                                int home_sequence)
{
    rtapi_print_msg(RTAPI_MSG_DBG, "HOMING: update_joint_homing_params(%d) offset:%f home:%f home_sequence:%d\n", jno, offset, home, home_sequence);
    H[jno].offset = offset;
    H[jno].home = home;
    H[jno].home_sequence = home_sequence;

    update_sequence_home_data();

    return;
}



// all home functions for homing api
EXPORT_SYMBOL(homeMotFunctions);

EXPORT_SYMBOL(homing_init);
EXPORT_SYMBOL(do_homing);
EXPORT_SYMBOL(get_allhomed);
EXPORT_SYMBOL(get_homed);
EXPORT_SYMBOL(get_home_is_idle);
EXPORT_SYMBOL(get_home_is_synchronized);
EXPORT_SYMBOL(get_home_needs_unlock_first);
EXPORT_SYMBOL(get_home_sequence);
EXPORT_SYMBOL(get_homing);
EXPORT_SYMBOL(get_homing_at_index_search_wait);
EXPORT_SYMBOL(get_homing_is_active);
EXPORT_SYMBOL(get_index_enable);
EXPORT_SYMBOL(read_homing_in_pins);
EXPORT_SYMBOL(do_home_joint);
EXPORT_SYMBOL(do_home_all);
EXPORT_SYMBOL(do_cancel_homing);
EXPORT_SYMBOL(set_unhomed);
EXPORT_SYMBOL(set_joint_homing_params);
EXPORT_SYMBOL(update_joint_homing_params);
EXPORT_SYMBOL(write_homing_out_pins);

#undef XSTR
#undef STR
#undef HOMING_BASE
#undef USE_HOMING_BASE
#undef CUSTOM_HOMEMODULE
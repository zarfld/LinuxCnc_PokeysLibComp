component pokeys "PoKeys IO driver, by Mit Zot";

option userspace yes;

pin out unsigned enum_usb_dev;
pin out unsigned enum_fusb_dev;
pin out unsigned enum_udp_dev;

pin out bit err;
pin out bit connected;
pin in unsigned devSerial;
pin out bit alive;

pin in bit machine_is_on;



// PoKeys device information
pin out unsigned info.PinCount;                        // Number of pins, physically on the device
pin out unsigned info.PWMCount;                        // Number of pins that support PWM output
pin out unsigned info.BasicEncoderCount;               // Number of basic encoders
pin out unsigned info.EncodersCount;                   // Number of encoder slots available
pin out unsigned info.FastEncoders;                    // Number of fast encoders supported
pin out unsigned info.UltraFastEncoders;               // Number of available ultra fast encoders
pin out unsigned info.PWMinternalFrequency;             // Main PWM peripheral clock
pin out unsigned info.AnalogInputs;                    // Number of available analog inputs
pin out unsigned info.KeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
pin out unsigned info.TriggeredKeyMapping;             // Device supports triggered key mapping
pin out unsigned info.KeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
pin out unsigned info.DigitalCounters;                 // Device supports digital counters
pin out unsigned info.JoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
pin out unsigned info.JoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
pin out unsigned info.Macros;                          // Device supports customizable macro sequences
pin out unsigned info.MatrixKeyboard;                  // Device supports matrix keyboard
pin out unsigned info.MatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
pin out unsigned info.LCD;                             // Device supports alphanumeric LCD display
pin out unsigned info.MatrixLED;                       // Device supports matrix LED display
pin out unsigned info.ConnectionSignal;                // Device supports connection signal output
pin out unsigned info.PoExtBus;                        // Device supports PoExtBus digital outputs
pin out unsigned info.PoNET;                           // Device supports PoNET bus devices
pin out unsigned info.AnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
pin out unsigned info.InitOutputsStart;                // Device supports initializing outputs at startup
pin out unsigned info.protI2C;                         // Device supports I2C bus (master)
pin out unsigned info.prot1wire;                       // Device supports 1-wire bus (master)
pin out unsigned info.AdditionalOptions;               // Device supports additional options with activation keys
pin out unsigned info.LoadStatus;                      // Device supports reporting load status
pin out unsigned info.CustomDeviceName;                // Device supports specifying custom device names
pin out unsigned info.PoTLog27support;                 // Device supports PoTLog27 firmware
pin out unsigned info.SensorList;                      // Device supports sensor lists
pin out unsigned info.WebInterface;                    // Device supports web interface
pin out unsigned info.FailSafeSettings;                // Device supports fail-safe mode
pin out unsigned info.JoystickHATswitch;               // Device supports joystick HAT switch mapping
pin out unsigned info.PulseEngine;                     // Device supports Pulse engine
pin out unsigned info.PulseEnginev2;                   // Device supports Pulse engine v2
pin out unsigned info.EasySensors;                     // Device supports EasySensors

// Pulse engine v2 information
pin out unsigned PEv2.nrOfAxes;
pin out unsigned PEv2.maxPulseFrequency;
pin out unsigned PEv2.bufferDepth;
pin out unsigned PEv2.slotTiming;

//***********************************************************************
//[TRAJ] information in HAL-INI 
pin in s32 COORDINATES;
pin in s32 LINEAR_UNITS;
pin in s32 ANGULAR_UNITS;
pin in float CYCLE_TIME;
pin in float DEFAULT_LINEAR_VELOCITY;
pin in float MAX_LINEAR_VELOCITY;
//***********************************************************************

// Pulse engine v2 structure...
pin out unsigned PEv2.AxesState-# [8];				// Axis states (bit-mapped) - see ePK_PEAxisState
pin out unsigned PEv2.AxesConfig-# [8];				// Axis configuration - see ePK_PEv2.AxisConfig
pin in unsigned PEv2.AxesSwitchConfig-# [8];		// Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions

pin out u32 PEv2.InvertAxisEnable-# [8];		// Invert axis enable signal
pin out u32 PEv2.SoftLimitMaximum-# [8];		// Soft limit maximum position
pin out u32 PEv2.SoftLimitMinimum-# [8];		// Soft limit minimum position
pin out unsigned PEv2.HomingSpeed-# [8];			// Homing speed per axis (in %)
pin out unsigned PEv2.HomingReturnSpeed-# [8];		// Homing return speed per axis (in % of the homing speed)
pin out u32 PEv2.HomeOffsets-# [8];				// Home position offset
pin out unsigned PEv2.HomingAlgorithm-# [8];		// Homing algorithm configuration
pin in unsigned PEv2.FilterLimitMSwitch-# [8];		// Digital filter for limit- switch
pin in unsigned PEv2.FilterLimitPSwitch-# [8];		// Digital filter for limit+ switch
pin in unsigned PEv2.FilterHomeSwitch-# [8];		// Digital filter for home switch
pin out u32 PEv2.ProbePosition-# [8];			// Position where probe detected change
pin out u32 PEv2.ProbeMaxPosition-# [8];		// Maximum position to travel to until stopping and returning error

pin out u32 PEv2.CurrentPosition-# [8];			// Current position
pin out u32 PEv2.PositionSetup-# [8];			// Position to be set as current position
pin out u32 PEv2.ReferencePositionSpeed-# [8];	// Reference position or speed (position or pulses/s)
pin out float PEv2.MaxSpeed-# [8];					// Maximum axis speed (in pulses per ms)
pin out float PEv2.MaxAcceleration-# [8];			// Maximum axis acceleration (in pulses/ms/ms)
pin out float PEv2.MaxDecceleration-# [8];			// Maximum axis deceleration (in pulses/ms/ms)

pin in float PEv2.MaxSpeed_mm_per_sec-# [8];			// Maximum axis speed (mm/s)
pin in float PEv2.MaxAcceleration_mm_per_sec2-# [8];	// Maximum axis acceleration (in mm/s²)
pin in float PEv2.MaxDecceleration_mm_per_sec2-# [8];	// Maximum axis deceleration (in mm/s²)

	
pin in float PEv2.joint_vel_cmd-# [8];				
pin out float PEv2.joint_vel_fb-# [8];				
pin in float PEv2.joint_pos_cmd-# [8];				
pin out float PEv2.joint_pos_fb-# [8];				
    
//***********************************************************************
//[JOINT_n] information in HAL-INI 
pin in s32 TYPE-# [8];			//LINEAR / ANGULAR
pin in float PEv2.HOME-# [8];
pin in float PEv2.FERROR-# [8];
pin in float PEv2.MIN_FERROR-# [8];
pin in float PEv2.MAX_VELOCITY-# [8];
pin in float PEv2.MAX_ACCELERATION-# [8];
pin in float PEv2.STEPGEN_MAXVEL-# [8];
pin in float PEv2.STEPGEN_MAXACCEL-# [8];
//pin in float PEv2.P-# [8];
//pin in float PEv2.I-# [8];
//pin in float PEv2.D-# [8];
//pin in float PEv2.FF0-# [8];
//pin in float PEv2.FF1-# [8];
//pin in float PEv2.FF2-# [8];
//pin in float PEv2.BIAS-# [8];
pin in float PEv2.DEADBAND-# [8];
pin in float PEv2.MAX_OUTPUT-# [8];
pin in float PEv2.ENCODER_SCALE-# [8];
// these are in nanoseconds
pin in float PEv2.DIRSETUP-# [8];					// (ns)
pin in float PEv2.DIRHOLD-# [8];					// (ns)
pin in float PEv2.STEPLEN-# [8];					// (ns)
pin in float PEv2.STEPSPACE-# [8];					// (ns)
pin in float PEv2.STEP_SCALE-# [8];					// (pulses/mm)
pin in float PEv2.MIN_LIMIT-# [8];					// position (mm)
pin in float PEv2.MAX_LIMIT-# [8];					// position (mm)
pin in float PEv2.HOME_OFFSET-# [8];				// position (mm)
pin in float PEv2.HOME_SEARCH_VEL-# [8];			// position (mm)
pin in float PEv2.HOME_LATCH_VEL-# [8];				// position (mm)
pin in float PEv2.HOME_FINAL_VEL-# [8];				// position (mm)
pin in s32 PEv2.HOME_USE_INDEX-# [8];				// YES / NO
pin in s32 PEv2.HOME_IGNORE_LIMITS-# [8];			// YES / NO
//***********************************************************************

pin out u32 PEv2.MPGjogMultiplier-# [8];		// MPG jog multiplier value
pin out unsigned PEv2.MPGjogEncoder-# [8];			// MPG jog encoder ID

pin in unsigned PEv2.PinHomeSwitch-# [8];			// Home switch pin (0 for external dedicated input)
pin in unsigned PEv2.PinLimitMSwitch-# [8];			// Limit- switch pin (0 for external dedicated input)
pin in unsigned PEv2.PinLimitPSwitch-# [8];			// Limit+ switch pin (0 for external dedicated input)
pin in unsigned PEv2.AxisEnableOutputPins-# [8];		// Axis enabled output pin (0 for external dedicated output)

pin out bit PEv2.HomeSwitchStat-# [8];				// Home switch
pin out bit PEv2.LimitMSwitch-# [8];			// Limit- switch
pin out bit PEv2.LimitPSwitch-# [8];			// Limit+ switch
pin in bit PEv2.AxisEnableOutput-# [8];		// Axis enabled output
pin out bit PEv2.HomeSwitch;				// Home switch

pin out unsigned PEv2.HomeBackOffDistance-# [8];		// Back-off distance after homing
pin out unsigned PEv2.MPGjogDivider-# [8];			// Divider for the MPG jogging (enhanced encoder resolution)
pin out unsigned PEv2.PulseEngineEnabled;			// Pulse engine enabled status, also number of enabled axes
pin out unsigned PEv2.PulseGeneratorType;			// Pulse engine generator type (0: external, 1: internal 3ch)
pin out unsigned PEv2.ChargePumpEnabled;				// Charge pump output enabled
pin out unsigned PEv2.EmergencySwitchPolarity;		// Emergency switch polarity (set to 1 to invert)
pin out unsigned PEv2.PulseEngineActivated;			// Pulse engine activation status
pin out unsigned PEv2.LimitStatusP;					// Limit+ status (bit-mapped)
pin out unsigned PEv2.LimitStatusN;					// Limit- status (bit-mapped)
pin out unsigned PEv2.HomeStatus;					// Home status (bit-mapped)
pin out unsigned PEv2.ErrorInputStatus;				// Stepper motor driver error inputs status (bit-mapped)
pin out unsigned PEv2.MiscInputStatus;				// Miscelenous digital inputs...
pin out unsigned PEv2.LimitOverride;					// Limit override status
pin out unsigned PEv2.LimitOverrideSetup;			// Limit override configuration
pin out unsigned PEv2.PulseEngineState;				// State of pulse engine - see ePoKeysPEState
pin out unsigned PEv2.AxisEnabledMask;				// Bit-mapped ouput enabled mask

pin in unsigned PEv2.EmergencyInputPin;
pin out bit PEv2.EmergencyInput;
pin in unsigned PEv2.EmergencyOutputPin;				//added in component only for estop-out to reset estop (if 0 EmergencyInput will be reused)
pin in bit PEv2.EmergencyOutput;

pin out unsigned PEv2.param1;
pin out unsigned PEv2.param2;
pin out unsigned PEv2.param3;
pin out unsigned PEv2.AxisEnabledStatesMask;		// Bit-mapped states, where axis enabled and charge pump signals are active
pin out unsigned PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration
pin out unsigned PEv2.SoftLimitStatus;				// Bit-mapped soft-limit statuses per axes
pin out unsigned PEv2.ExternalRelayOutputs;			// External relay outputs
pin out unsigned PEv2.ExternalOCOutputs;			// External open-collector outputs
pin out unsigned PEv2.PulseEngineBufferSize;		// Buffer size information...
pin out unsigned PEv2.motionBufferEntriesAccepted;
pin out unsigned PEv2.newMotionBufferEntries;
pin out unsigned PEv2.HomingStartMaskSetup;			// Bit-mapped axes indexes to be homed
pin out unsigned PEv2.ProbeStartMaskSetup;			// Bit-mapped axis indexes for probing
pin in unsigned PEv2.ProbeInput;					// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
pin in unsigned PEv2.ProbeInputPolarity;			// Probe input polarity
pin out unsigned PEv2.ProbeStatus;					// Probe status (probe completion bit-mapped status)
//pin out unsigned PEv2.MotionBuffer[448];			// Motion buffer
pin out float PEv2.ProbeSpeed;						// Probe speed (ratio of the maximum speed)
pin out unsigned PEv2.BacklashWidth-# [8];			// half of real backlash width
pin out unsigned PEv2.BacklashRegister-# [8];		// current value of the backlash register
pin out unsigned PEv2.BacklashAcceleration-# [8];	// in pulses per ms^2
pin out unsigned PEv2.BacklashCompensationEnabled;

pin out unsigned rtc_sec;
pin out unsigned rtc_min;
pin out unsigned rtc_hour;
pin out unsigned rtc_dow;
pin out unsigned rtc_dom;
pin out unsigned rtc_tmp;
pin out unsigned rtc_doy;
pin out unsigned rtc_month;
pin out unsigned rtc_year;
pin out unsigned rtc_loopcount;
pin out unsigned pincap-# [55];
pin out unsigned rtc_lastmin;
pin out unsigned rtc_lastsec;
pin out unsigned rtc_loop_frequ;

pin out unsigned Pins_DigitalCounterValue-#[55];
pin out unsigned Pins_AnalogValue-#[55];
pin out unsigned Pins_PinFunction-#[55];
pin out unsigned Pins_CounterOptions-#[55];
pin out unsigned Pins_DigitalValueGet-#[55];
pin in unsigned Pins_DigitalValueSet-#[55];
pin out unsigned Pins_DigitalCounterAvailable-#[55];
pin out unsigned Pins_MappingType-#[55];
pin out unsigned Pins_KeyCodeMacroID-#[55];
pin out unsigned Pins_KeyModifier-#[55];
pin out unsigned Pins_downKeyCodeMacroID-#[55];
pin out unsigned Pins_downKeyModifier-#[55];
pin out unsigned Pins_upKeyCodeMacroID-#[55];
pin out unsigned Pins_upKeyModifier-#[55];
pin out unsigned Pins_preventUpdate-#[55];

pin out unsigned MatrixKB_matrixKBconfiguration;		// Matrix keyboard configuration (set to 1 to enable matrix keyboard support)
pin out unsigned MatrixKB_matrixKBwidth;				// Matrix keyboard width (number of columns)
pin out unsigned MatrixKB_matrixKBheight;				// Matrix keyboard height (number of rows)
pin out unsigned MatrixKB_matrixKBcolumnsPins-#[8];		// List of matrix keyboard column connections
pin out unsigned MatrixKB_matrixKBrowsPins-#[16];			// List of matrix keyboard row connections
pin out unsigned MatrixKB_matrixKBvalues-#[128];			// Current state of each matrix keyboard key (assumes fixed width of 8 columns)

pin out unsigned Encoders_encoderValue-#[26];       // Encoder current value
pin in unsigned Encoders_encoderOptions-#[26];      // Encoder options -    bit 0: enable encoder
													//                      bit 1: 4x sampling
													//                      bit 2: 2x sampling
													//                      bit 3: reserved
													//                      bit 4: direct key mapping for direction A
													//                      bit 5: mapped to macro for direction A
													//                      bit 6: direct key mapping for direction B
													//                      bit 7: mapped to macro for direction B
pin in unsigned Encoders_channelApin-#[26];         // Channel A encoder pin
pin in unsigned Encoders_channelBpin-#[26];         // Channel B encoder pin

pin out u32 EasySensors_sensorValue-#[10];            // Current sensor value
pin out unsigned EasySensors_sensorType-#[10];             // Type of the sensor
pin out unsigned EasySensors_sensorRefreshPeriod-#[10];    // Refresh period in 0.1s
pin out unsigned EasySensors_sensorFailsafeConfig-#[10];   // Failsafe configuration (bits 0-5: timeout in seconds, bit 6: invalid=0, bit 7: invalid=0x7FFFFFFF)
pin out unsigned EasySensors_sensorReadingID-#[10];        // Sensor reading selection (see Protocol description document for details)


license "GPL";

option extra_link_args "-lPoKeys";

;;

#include <unistd.h>   /* UNIX standard function definitions */
#include "PoKeysLib.h"

sPoKeysDevice * dev=0;
//Pk_Pins_Comp Pins;

int i=0;

void user_mainloop(void) 
{ 



    while(0xb){
       FOR_ALL_INSTS() {
	   rtc_loopcount++;
	 while(dev == NULL)
	 {
			
		 if (devSerial!=0 )
		 {
				rtc_loopcount=11;
				enum_usb_dev = PK_EnumerateUSBDevices();
				rtc_loopcount=12;
				if (enum_usb_dev != 0)
				{
				dev = PK_ConnectToDeviceWSerial(devSerial, 5000);  //waits for usb device
				}
				
				rtc_loopcount=13;
				if (dev == NULL)
				{
					rtc_loopcount=13;
					dev = PK_ConnectToDeviceWSerial_UDP(devSerial, 5000);  //waits for usb device
				}

		 }
		else
		{
			sPoKeysNetworkDeviceSummary * udp_devices;
			enum_usb_dev = PK_EnumerateUSBDevices();
			enum_fusb_dev = PK_EnumerateUSBDevices();
			//enum_udp_dev = PK_EnumerateNetworkDevices(udp_devices,180); // does not work - it hangs here

		}

		if(dev != NULL)
		{
			connected=1;
			bool setPkConfig = false;
			bool setPinConfig = false;
			 info.PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
			 info.PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
			 info.BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
			 info.EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
			 info.FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
			 info.UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
			 info.PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
			 info.AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
			 info.KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
			 info.TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
			 info.KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
			 info.DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
			 info.JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
			 info.JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
			 info.Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
			 info.MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
			 info.MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
			 info.LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
			 info.MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
			 info.ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
			 info.PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
			 info.PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
			 info.AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
			 info.InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
			 info.protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
			 info.prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
			 info.AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
			 info.LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
			 info.CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
			 info.PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
			 info.SensorList = dev->info.iSensorList;                      // Device supports sensor lists
			 info.WebInterface = dev->info.iWebInterface;                    // Device supports web interface
			 info.FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
			 info.JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
			 info.PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
			 info.PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
			 info.EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors

			 if (info.PulseEnginev2!=0)
			 {
				 PEv2.nrOfAxes=dev->PEv2.info.nrOfAxes;
				 PEv2.maxPulseFrequency=dev->PEv2.info.maxPulseFrequency;
				 PEv2.bufferDepth=dev->PEv2.info.bufferDepth;
				 PEv2.slotTiming=dev->PEv2.info.slotTiming;
				 bool setPeConfig = false;
				 dev->PEv2.EmergencyInputPin=PEv2.EmergencyInputPin;
				if (PEv2.EmergencyInputPin!=0)
				{	//check if pin is parametrized in HAL
					
					dev->Pins[PEv2.EmergencyInputPin-1].PinFunction = PK_PinCap_digitalInput;
					setPinConfig=true;
					setPeConfig=true;
				}
				if (PEv2.EmergencyOutputPin!=0)
				{	//check if pin is parametrized in HAL
						dev->Pins[PEv2.EmergencyOutputPin-1].PinFunction = PK_PinCap_digitalOutput;
						setPinConfig=true;
				}
				// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
				//check if pin is parametrized in HAL
				dev->PEv2.ProbeInput=PEv2.ProbeInput;
				//check if pin is parametrized in HAL
				dev->PEv2.ProbeInputPolarity=PEv2.ProbeInputPolarity;
				if (PEv2.ProbeInput!=0)
				{	//check if pin is parametrized in HAL
						dev->Pins[PEv2.ProbeInput-1].PinFunction = PK_PinCap_digitalInput;
						setPinConfig=true;
				}

				dev->PEv2.PulseEngineEnabled=8; //Enable 8 axes
				dev->PEv2.PulseEngineActivated=true;
				dev->PEv2.AxisEnabledStatesMask=0; //Disable axis power when not in Running state
				PK_PEv2.PulseEngineSetup(dev);
				
				for(i=0;i<PEv2.nrOfAxes;i++)
				{
					if(PEv2.STEP_SCALE(i)!=0)
					{
				
						if (PEv2.AxesConfig(i)!=PK_AC_POSITION_MODE)
						{
							dev->PEv2.ReferencePositionSpeed[i] = PEv2.joint_vel_cmd(i) * PEv2.STEP_SCALE(i);

							PEv2.joint_vel_fb(i) = dev->PEv2.PositionSetup[i] / PEv2.STEP_SCALE(i);
							PEv2.joint_pos_fb(i) = dev->PEv2.CurrentPosition[i] / PEv2.STEP_SCALE(i);
						}
						else
						{
							dev->PEv2.ReferencePositionSpeed[i] = PEv2.joint_pos_cmd(i) * PEv2.STEP_SCALE(i);
							PEv2.joint_vel_fb(i) = dev->PEv2.PositionSetup[i] / PEv2.STEP_SCALE(i);
							PEv2.joint_pos_fb(i) = dev->PEv2.CurrentPosition[i] / PEv2.STEP_SCALE(i);
						}

						dev->PEv2.MaxSpeed[i] = PEv2.STEPGEN_MAXVEL(i)* PEv2.STEP_SCALE(i)/1000;					// Maximum axis speed convert (mm/s) to (pulses per ms)
						dev->PEv2.MaxAcceleration[i] = PEv2.STEPGEN_MAXVEL(i)* PEv2.STEP_SCALE(i) /1000000;			// Maximum axis acceleration convert (mm/s²) to (in pulses/ms/ms)
						dev->PEv2.MaxDecceleration[i] = PEv2.STEPGEN_MAXVEL(i)* PEv2.STEP_SCALE(i) /1000000;			// Maximum axis deceleration convert (mm/s²) to (in pulses/ms/ms)

						dev->PEv2.SoftLimitMaximum[i] = PEv2.MAX_LIMIT(i)* PEv2.STEP_SCALE(i);		// Soft limit maximum position
						dev->PEv2.SoftLimitMinimum[i] = PEv2.MIN_LIMIT(i)* PEv2.STEP_SCALE(i);		// Soft limit minimum position
						dev->PEv2.HomeOffsets[i] = PEv2.HOME_OFFSET(i)* PEv2.STEP_SCALE(i);				// Home position offset

						dev->PEv2.HomingSpeed[i] = PEv2.HOME_SEARCH_VEL(i)*100/PEv2.MAX_VELOCITY(i) ;			// Homing speed per axis (in %)
						dev->PEv2.HomingReturnSpeed[i] = PEv2.HOME_LATCH_VEL(i)*100/PEv2.HOME_SEARCH_VEL(i);		// Homing return speed per axis (in % of the homing speed)

						dev->PEv2.AxesSwitchConfig[i]=PEv2.AxesSwitchConfig(i);
						dev->PEv2.FilterLimitMSwitch[i]= PEv2.FilterLimitMSwitch(i);		// Digital filter for limit- switch
						dev->PEv2.FilterLimitPSwitch[i]=PEv2.FilterLimitPSwitch(i);		// Digital filter for limit+ switch
						dev->PEv2.FilterHomeSwitch[i]=PEv2.FilterHomeSwitch(i);		// Digital filter for home switch

						// Limit- switch pin (0 for external dedicated input)
						dev->PEv2.PinLimitMSwitch[i]=PEv2.PinLimitMSwitch(i);

						// Limit+ switch pin (0 for external dedicated input)
						dev->PEv2.PinLimitPSwitch[i]=PEv2.PinLimitPSwitch(i);

						if (PEv2.PinLimitPSwitch(i)!=0)
						{	//check if pin is parametrized in HAL
						dev->Pins[PEv2.PinLimitPSwitch(i)-1].PinFunction = PK_PinCap_digitalInput;
						setPinConfig=true;
						}
						if (PEv2.PinLimitPSwitch(i)!=0)
						{	//check if pin is parametrized in HAL
						dev->Pins[PEv2.PinLimitPSwitch(i)-1].PinFunction = PK_PinCap_digitalInput;
						setPinConfig=true;
						}


						dev->PEv2.param1 = i;
						PK_PEv2.AxisConfigurationSet(dev);
					}
				}
				dev->PEv2.PulseEngineStateSetup = PK_PEState_peSTOPPED;
				PK_PEv2.PulseEngineStateSet(dev);

			 }
			 dev->DeviceData.DeviceLockStatus=1;
			 if (setPinConfig==true)
			 {
				PK_PinConfigurationSet(dev);
			 }
			 PK_SaveConfiguration(dev);
			 
		}
		else
		{
		connected=0;
		err=1;
		}
		usleep(40000);
	 }
	 alive=1; 

	 // RTC
	if (PK_RTCGet(dev) == PK_OK)
	{
		rtc_sec=dev->RTC.SEC;
		rtc_min=dev->RTC.MIN;
		rtc_hour=dev->RTC.HOUR;
		rtc_dow=dev->RTC.DOW;
		rtc_dom=dev->RTC.DOM;
		rtc_tmp=dev->RTC.tmp;
		rtc_doy=dev->RTC.DOY;
		rtc_month=dev->RTC.MONTH;
		rtc_year=dev->RTC.YEAR;

		if (rtc_lastsec!=rtc_sec)
		{
			rtc_loop_frequ=rtc_loopcount;
			rtc_loopcount=0;
			rtc_lastsec=rtc_sec;

				
		}
	}

	// PulseEnginev2
	if (info.PulseEnginev2!=0)
	{
	 if ((PK_PEv2.StatusGet(dev) == PK_OK) && (PK_PEv2.Status2Get(dev) == PK_OK))
	 {

	 // Pulse engine v2 structure...
		PEv2.PulseEngineEnabled=dev->PEv2.PulseEngineEnabled;			// Pulse engine enabled status, also number of enabled axes
		PEv2.PulseGeneratorType=dev->PEv2.PulseGeneratorType;			// Pulse engine generator type (0: external, 1: internal 3ch)
		PEv2.ChargePumpEnabled=dev->PEv2.ChargePumpEnabled;			// Charge pump output enabled
		PEv2.EmergencySwitchPolarity=dev->PEv2.EmergencySwitchPolarity;		// Emergency switch polarity (set to 1 to invert)
		PEv2.PulseEngineActivated=dev->PEv2.PulseEngineActivated;			// Pulse engine activation status
		PEv2.LimitStatusP=dev->PEv2.LimitStatusP;					// Limit+ status (bit-mapped)
		PEv2.LimitStatusN=dev->PEv2.LimitStatusN;					// Limit- status (bit-mapped)
		PEv2.HomeStatus=dev->PEv2.HomeStatus;					// Home status (bit-mapped)
		PEv2.ErrorInputStatus=dev->PEv2.ErrorInputStatus;				// Stepper motor driver error inputs status (bit-mapped)
		PEv2.MiscInputStatus=dev->PEv2.MiscInputStatus;				// Miscelenous digital inputs...
		PEv2.LimitOverride=dev->PEv2.LimitOverride;				// Limit override status
		PEv2.LimitOverrideSetup=dev->PEv2.LimitOverrideSetup;			// Limit override configuration
		PEv2.PulseEngineState=dev->PEv2.PulseEngineState;				// State of pulse engine - see ePoKeysPEState
		switch (PEv2.PulseEngineState)
		{
		    case PK_PEState_peSTOPPED:           // Pulse engine is stopped
				if(machine_is_on==true)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peRUNNING;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peINTERNAL:           // PEv1: Internal motion controller is in use, PEv2: not used
				break;
		    casePK_PEState_peBUFFER:           // PEv1: Buffered operation mode is in use, PEv2: not used
				break;
		    casePK_PEState_peRUNNING:           // Pulse engine is activated
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peJOGGING:          // Jogging mode enabled
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peSTOPPING:          // Pulse engine is stopping
				break;
		    casePK_PEState_peHOME:          // All axes are homed
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peHOMING:          // Axes homing is in progress
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_pePROBECOMPLETE:          // All axes are homed
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_pePROBE:          // Axes probing is in progress
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_pePROBEERROR:          // Error occured during probing
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peHYBRIDPROBE_STOPPING:
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peHYBRIDPROBE_COMPLETE:
				if(machine_is_on==false)
				{
					dev->PEv2.PulseEngineState = PK_PEState_peSTOPPED;
					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peSTOP_LIMIT:         // Pulse engine stopped due to limit reached
				err=true;
				break;
		    casePK_PEState_peSTOP_EMERGENCY:          // Pulse engine stopped due to emergency switch
				err=true;
				break;
		}


		PEv2.AxisEnabledMask=dev->PEv2.AxisEnabledMask;				// Bit-mapped ouput enabled mask

		if (dev->PEv2.EmergencyInputPin>0)
		{
			PEv2.EmergencyInput=dev->Pins[dev->PEv2.EmergencyInputPin-1].DigitalValueGet;
		}
		else
		{
			PEv2.EmergencyInput=false;
		}
		if (PEv2.EmergencyOutputPin!=0)
		{	//check if pin is parametrized in HAL
			dev->Pins[PEv2.EmergencyOutputPin].DigitalValueSet=PEv2.EmergencyOutput;
		}
		else
		{
			if (dev->PEv2.EmergencyInputPin>0)
			{
				if(dev->Pins[dev->PEv2.EmergencyInputPin-1].DigitalValueGet>0)
				{
					PEv2.EmergencyInput=true;
				}
				else
				{
					PEv2.EmergencyInput=PEv2.EmergencyOutput;
				}
			}
			else
			{
				PEv2.EmergencyInput=PEv2.EmergencyOutput;
			}
		}
		PEv2.param1=dev->PEv2.param1;
		PEv2.param2=dev->PEv2.param2;
		PEv2.param3=dev->PEv2.param3;
		PEv2.AxisEnabledStatesMask=dev->PEv2.AxisEnabledStatesMask;		// Bit-mapped states, where axis enabled and charge pump signals are active
		PEv2.PulseEngineStateSetup=dev->PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration
		PEv2.SoftLimitStatus=dev->PEv2.SoftLimitStatus;				// Bit-mapped soft-limit statuses per axes
		PEv2.ExternalRelayOutputs=dev->PEv2.ExternalRelayOutputs;			// External relay outputs
		PEv2.ExternalOCOutputs=dev->PEv2.ExternalOCOutputs;			// External open-collector outputs
		PEv2.PulseEngineBufferSize=dev->PEv2.PulseEngineBufferSize;		// Buffer size information...
		//PEv2.motionBufferEntriesAccepted=dev->PEv2.motionBufferEntriesAccepted;
		PEv2.newMotionBufferEntries=dev->PEv2.newMotionBufferEntries;
		PEv2.HomingStartMaskSetup=dev->PEv2.HomingStartMaskSetup;			// Bit-mapped axes indexes to be homed
		PEv2.ProbeStartMaskSetup=dev->PEv2.ProbeStartMaskSetup;			// Bit-mapped axis indexes for probing
		// writeonly PEv2.ProbeInputPolarity=dev->PEv2.ProbeInputPolarity;			// Probe input polarity
		PEv2.ProbeStatus=dev->PEv2.ProbeStatus;					// Probe status (probe completion bit-mapped status)
		//PEv2.MotionBuffer=dev->PEv2.MotionBuffer;			// Motion buffer
		PEv2.ProbeSpeed=dev->PEv2.ProbeSpeed;						// Probe speed (ratio of the maximum speed)
		PEv2.BacklashCompensationEnabled=dev->PEv2.BacklashCompensationEnabled;
	 }
	 if (PK_PEv2.AxisConfigurationGet(dev) == PK_OK)
	 {
			bool PEv2.move = false;

			for(i=0;i<PEv2.nrOfAxes;i++)
			{ 
				PEv2.AxesState(i)=dev->PEv2.AxesState[i];				// Axis states (bit-mapped) - see ePK_PEAxisState
				switch(PEv2.AxesState(i))
				{
					case PK_PEAxisState_axSTOPPED:        // Axis is stopped
						break ;
					case PK_PEAxisState_axREADY:        // Axis ready
						break ;
					case PK_PEAxisState_axRUNNING:        // Axis is running
						break ;
					case PK_PEAxisState_axHOMING_RESETTING:   // Stopping the axis to reset the position counters
						break ;
					case PK_PEAxisState_axHOMING_BACKING_OFF:   // Backing off switch
						break ;
					case PK_PEAxisState_axHOME:       // Axis is homed
					// PEv2.joint_
						break ;
					case PK_PEAxisState_axHOMINGSTART:       // Homing procedure is starting on axis
						break ;
					case PK_PEAxisState_axHOMINGSEARCH:       // Homing procedure first step - going to home
						break ;
					case PK_PEAxisState_axHOMINGBACK:       // Homing procedure second step - slow homing
						break ;
					case PK_PEAxisState_axPROBED:       // Probing completed for this axis
						break ;
					case PK_PEAxisState_axPROBESTART:       // Probing procedure is starting on axis
						break ;
					case PK_PEAxisState_axPROBESEARCH:       // Probing procedure - probing
						break ;
					case PK_PEAxisState_axERROR:       // Axis error
						break ;
					case PK_PEAxisState_axLIMIT:        // Axis limit tripped
						break ;
					default:
						break ;
				}


				PEv2.AxesConfig(i)=dev->PEv2.AxesConfig[i];				// Axis configuration - see ePK_PEv2_AxisConfig
				PEv2.InvertAxisEnable(i)=dev->PEv2.InvertAxisEnable[i];		// Invert axis enable signal
				PEv2.SoftLimitMaximum(i)=dev->PEv2.SoftLimitMaximum[i];		// Soft limit maximum position
				PEv2.SoftLimitMinimum(i)=dev->PEv2.SoftLimitMinimum[i];		// Soft limit minimum position
				PEv2.HomingSpeed(i)=dev->PEv2.HomingSpeed[i];			// Homing speed per axis (in %)
				PEv2.HomingReturnSpeed(i)=dev->PEv2.HomingReturnSpeed[i];		// Homing return speed per axis (in % of the homing speed)
				PEv2.HomeOffsets(i)=dev->PEv2.HomeOffsets[i];				// Home position offset
				PEv2.HomingAlgorithm(i)=dev->PEv2.HomingAlgorithm[i];		// Homing algorithm configuration

				PEv2.ProbePosition(i)=dev->PEv2.ProbePosition[i];			// Position where probe detected change
				PEv2.ProbeMaxPosition(i)=dev->PEv2.ProbeMaxPosition[i];		// Maximum position to travel to until stopping and returning error
				PEv2.MPGjogMultiplier(i)=dev->PEv2.MPGjogMultiplier[i];		// MPG jog multiplier value
				PEv2.MPGjogEncoder(i)=dev->PEv2.MPGjogEncoder[i];			// MPG jog encoder ID
				
				if(PEv2_STEP_SCALE(i)!=0)
				{
				
					if (PEv2_AxesConfig(i)!=PK_AC_POSITION_MODE)
					{
						// Velocity-Mode
						dev->PEv2.ReferencePositionSpeed[i] = PEv2.joint_vel_cmd(i) * PEv2.STEP_SCALE(i);
						
						// calculate actual velocity by position difference (time estimated by actual rtc_loop_frequ [Hz] / [1/sec] )
						PEv2.joint_vel_fb(i) = (PEv2_joint_pos_fb(i) - (dev->PEv2.CurrentPosition[i] / PEv2.STEP_SCALE(i)) )* rtc_loop_frequ;
						PEv2.joint_pos_fb(i) = dev->PEv2.CurrentPosition[i] / PEv2.STEP_SCALE(i);
						PEv2.move=true;
					}
					else
					{
						dev->PEv2.ReferencePositionSpeed[i] = PEv2.joint_pos_cmd(i) * PEv2.STEP_SCALE(i);
						PEv2.joint_vel_fb(i) = dev->PEv2.PositionSetup[i] / PEv2.STEP_SCALE(i);
						PEv2.joint_pos_fb(i) = dev->PEv2.CurrentPosition[i] / PEv2.STEP_SCALE(i);
						PEv2.move=true;
					}


					PEv2.MaxSpeed(i)=dev->PEv2.MaxSpeed[i];					// Maximum axis speed (in pulses per ms)
					PEv2.MaxAcceleration(i)=dev->PEv2.MaxAcceleration[i];			// Maximum axis acceleration (in pulses/ms/ms)
					PEv2.MaxDecceleration(i)=dev->PEv2.MaxDecceleration[i];			// Maximum axis deceleration (in pulses/ms/ms)
				}

				PEv2.CurrentPosition(i)=dev->PEv2.CurrentPosition[i];				// Current position
				PEv2.PositionSetup(i)=dev->PEv2.PositionSetup[i];					// Position to be set as current position
				PEv2.ReferencePositionSpeed(i)=dev->PEv2.ReferencePositionSpeed[i];	// Reference position or speed (position or pulses/s)
				PEv2.MaxSpeed(i)=dev->PEv2.MaxSpeed[i];								// Maximum axis speed (in pulses per ms)
				PEv2.MaxAcceleration(i)=dev->PEv2.MaxAcceleration[i];				// Maximum axis acceleration (in pulses/ms/ms)
				PEv2.MaxDecceleration(i)=dev->PEv2.MaxDecceleration[i];				// Maximum axis deceleration (in pulses/ms/ms)

				// Home switch pin (0 for external dedicated input)
				if (PEv2_PinHomeSwitch(i)!=0)
				{	//check if pin is parametrized in HAL
					dev->PEv2.PinHomeSwitch[i]=PEv2_PinHomeSwitch(i);
				}
				if (dev->PEv2.PinHomeSwitch[i]>0)
				{
					unsigned allStat =dev->PEv2.HomeStatus;					// Home status (bit-mapped)
					
					//unsigned PinId = dev->PEv2.PinHomeSwitch[i]
					PEv2.HomeSwitchStat(i)=(allStat & (1 << i)) != 0;
				}
				else
				{
					PEv2.HomeSwitchStat(i)=0;
				}

				

				if (dev->PEv2.PinLimitMSwitch[i]>0)
				{
					PEv2.LimitMSwitch(i)=dev->Pins[dev->PEv2.PinLimitMSwitch[i]-1].DigitalValueGet;
				}
				else
				{
					PEv2.LimitMSwitch(i)=0;
				}


				if (dev->PEv2.PinLimitPSwitch[i]>0)
				{
					PEv2.LimitPSwitch(i)=dev->Pins[dev->PEv2.PinLimitPSwitch[i]-1].DigitalValueGet;
				}
				else
				{
					PEv2.LimitPSwitch(i)=0;
				}

				//PEv2_AxisEnableOutputPins(i)=dev->PEv2.AxisEnableOutputPins[i];	// Axis enabled output pin (0 for external dedicated output)
				if (PEv2_AxisEnableOutputPins(i)!=0)
				{	//check if pin is parametrized in HAL
					dev->PEv2.AxisEnableOutputPins[i]=PEv2_AxisEnableOutputPins(i);
				}
				if (dev->PEv2.AxisEnableOutputPins[i]>0)
				{
					dev->Pins[dev->PEv2.PinLimitPSwitch[i]-1].DigitalValueSet=PEv2_AxisEnableOutput(i);
				}

				PEv2.HomeBackOffDistance(i)=dev->PEv2.HomeBackOffDistance[i];	// Back-off distance after homing
				PEv2.MPGjogDivider(i)=dev->PEv2.MPGjogDivider[i];			// Divider for the MPG jogging (enhanced encoder resolution)
				PEv2.BacklashWidth(i)=dev->PEv2.BacklashWidth[i];			// half of real backlash width
				PEv2.BacklashRegister(i)=dev->PEv2.BacklashRegister[i];		// current value of the backlash register
				PEv2.BacklashAcceleration(i)=dev->PEv2.BacklashAcceleration[i];	// in pulses per ms^2
			}
			if (PEv2_move==true)
			{
			PK_PEv2_PulseEngineMove(dev);
			}
	 }
	}

	if ((PK_DigitalIOGet(dev) == PK_OK) && (PK_AnalogIOGet(dev) == PK_OK) && (PK_PinConfigurationGet(dev) == PK_OK)){  //gets IO data and checks return value 
		err=0;
		sPoKeysPinData iPin;
		
		for(i=0;i<info.PinCount-1;i++)
		{
			Pins_DigitalCounterValue(i)=dev->Pins[i].DigitalCounterValue;
			Pins_AnalogValue(i)=dev->Pins[i].AnalogValue;
			Pins_PinFunction(i)=dev->Pins[i].PinFunction;
			Pins_CounterOptions(i)=dev->Pins[i].CounterOptions;
			Pins_DigitalValueGet(i)=dev->Pins[i].DigitalValueGet;
			dev->Pins[i].DigitalValueSet=Pins_DigitalValueSet(i);
			Pins_DigitalCounterAvailable(i)=dev->Pins[i].DigitalCounterAvailable;
			Pins_MappingType(i)=dev->Pins[i].MappingType;
			Pins_KeyCodeMacroID(i)=dev->Pins[i].KeyCodeMacroID;
			Pins_KeyModifier(i)=dev->Pins[i].KeyModifier;
			Pins_downKeyCodeMacroID(i)=dev->Pins[i].downKeyCodeMacroID;
			Pins_downKeyModifier(i)=dev->Pins[i].downKeyModifier;
			Pins_upKeyCodeMacroID(i)=dev->Pins[i].upKeyCodeMacroID;
			Pins_upKeyModifier(i)=dev->Pins[i].upKeyModifier;
			Pins_preventUpdate(i)=dev->Pins[i].preventUpdate;
		}
		PK_DigitalIOSet(dev);
	 }
     else
	 {             		  //on connection error
		PK_DisconnectDevice(dev);
		dev=NULL;  		  //tries to reconnect
		err=1;

	 }
	
	if (info.MatrixKeyboard!=0)
	{
		if (PK_MatrixKBStatusGet(dev) == PK_OK)
		{
			if (MatrixKB_matrixKBwidth>0 && MatrixKB_matrixKBheight>0)
			{
				for(i=0;i<128;i++)
				{
					MatrixKB_matrixKBvalues(i) = dev->matrixKB.matrixKBvalues[i]; 
				}
			}

		}

	}

	if (info.EasySensors!=0 && info.PinCount!=0)
	{
		if ((PK_EasySensorsSetupGet(dev) == PK_OK) && (PK_EasySensorsValueGetAll(dev) == PK_OK))
		{
			for(i=0;i<10;i++)
			{
				EasySensors_sensorValue(i)=dev->EasySensors[i].sensorValue;
				EasySensors_sensorType(i)=dev->EasySensors[i].sensorType;
				EasySensors_sensorRefreshPeriod(i)=dev->EasySensors[i].sensorRefreshPeriod;
				EasySensors_sensorFailsafeConfig(i)=dev->EasySensors[i].sensorFailsafeConfig;
				EasySensors_sensorReadingID(i)=dev->EasySensors[i].sensorReadingID;

			}		
		}

	}
	if (rtc_lastmin!=rtc_min)
	{

		rtc_lastmin=rtc_min;
		
		 info.PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
		 info.PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
		 info.BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
		 info.EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
		 info.FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
		 info.UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
		 info.PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
		 info.AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
		 info.KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
		 info.TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
		 info.KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
		 info.DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
		 info.JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
		 info.JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
		 info.Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
		 info.MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
		 info.MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
		 info.LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
		 info.MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
		 info.ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
		 info.PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
		 info.PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
		 info.AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
		 info.InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
		 info.protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
		 info.prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
		 info.AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
		 info.LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
		 info.CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
		 info.PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
		 info.SensorList = dev->info.iSensorList;                      // Device supports sensor lists
		 info.WebInterface = dev->info.iWebInterface;                    // Device supports web interface
		 info.FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
		 info.JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
		 info.PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
		 info.PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
		 info.EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors


		 if (info.PulseEnginev2!=0)
		 {
			 PEv2.nrOfAxes=dev->PEv2.info.nrOfAxes;
			 PEv2.maxPulseFrequency=dev->PEv2.info.maxPulseFrequency;
			 PEv2.bufferDepth=dev->PEv2.info.bufferDepth;
			 PEv2.slotTiming=dev->PEv2.info.slotTiming;
		 }

			if (info.MatrixKeyboard!=0)
			{
				if (PK_MatrixKBConfigurationGet(dev) == PK_OK)
				{

				MatrixKB_matrixKBconfiguration = dev->matrixKB.matrixKBconfiguration;
				MatrixKB_matrixKBwidth = dev->matrixKB.matrixKBwidth;
				MatrixKB_matrixKBheight = dev->matrixKB.matrixKBheight;
					for(i=0;i<MatrixKB_matrixKBwidth-1;i++)
					{
						MatrixKB_matrixKBcolumnsPins(i) = dev->matrixKB.matrixKBcolumnsPins[i]; 
					}
					for(i=0;i<MatrixKB_matrixKBheight-1;i++)
					{
						MatrixKB_matrixKBrowsPins(i) = dev->matrixKB.matrixKBrowsPins[i]; 
					}
				}

			}
	}
	alive=0;
	usleep(40000); 
        }
    }

    exit(0);
};


//public Class Pk_Pins_Comp
//Pk_Pin_Comp Pin-#[55];
//public Pk_Pins_Comp(){}
//End Clas


//public Class Pk_Pin_Comp
//pin out unsigned DigitalCounterValue;
//pin out unsigned AnalogValue;
//pin out unsigned PinFunction;
//pin out unsigned CounterOptions;
//pin out unsigned DigitalValueGet ;
//pin in unsigned DigitalValueSet ;
//pin out unsigned DigitalCounterAvailable ;
//pin out unsigned MappingType ;
//pin out unsigned KeyCodeMacroID ;
//pin out unsigned KeyModifier ;
//pin out unsigned downKeyCodeMacroID ;
//pin out unsigned downKeyModifier ;
//pin out unsigned upKeyCodeMacroID ;
//pin out unsigned upKeyModifier ;
//pin out unsigned preventUpdate ;
//End Clas
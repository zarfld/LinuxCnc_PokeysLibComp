component pokeys "(uSpace)PoKeys IO driver";



//#define PoNet

pin out unsigned enum_usb_dev;
pin out unsigned enum_fusb_dev;
pin out unsigned enum_udp_dev;
//pin in unsigned timeout_ms;
pin out s32 deb.out;

pin out s32 PEv2.deb.out;
pin out s32 PEv2.deb.estop;
pin out s32 PEv2.#.deb.axxisout[8];
pin out bit PEv2.#.deb.ishoming[8];
pin out bit PEv2.#.deb.inposition[8];
pin out bit PEv2.#.deb.PosMode[8];
pin out bit PEv2.#.deb.PosModeAct[8];
pin out s32 PEv2.#.deb.velmode_count[8];
pin out s32 PEv2.#.deb.posmode_count[8];

pin out bit PEv2.#.deb.doMove[8];
pin out float PEv2.#.deb.RefSpeed[8];
pin out float PEv2.#.deb.RefPos[8];
pin out float PEv2.#.deb.RefPosSpeed[8];

pin out unsigned adcout.#.deb.out[6];
pin out unsigned adcout.#.deb.setval[6];
pin out unsigned adcout.deb.outv;

pin out bit err;
pin out bit connected;
pin out bit connected.usb;
pin out bit connected.fusb;
pin out bit connected.udp;
pin out bit connected.net;
param rw unsigned devSerial "PoKeys device serial number";
//pin in unsigned devSerial;
pin out bit alive;

pin in bit machine_is_on;

// PoKeys device information
//sPoKeysDevice_Info info;
pin out unsigned info.PinCount;                        // Number of pins, physically on the device
pin out unsigned info.PWMCount;                        // Number of pins that support PWM output
pin out unsigned info.BasicEncoderCount;               // Number of basic encoders
pin out unsigned info.EncodersCount;                   // Number of encoder slots available
pin out unsigned info.FastEncoders;                    // Number of fast encoders supported
pin out unsigned info.UltraFastEncoders;               // Number of available ultra fast encoders
pin out unsigned info.PWMinternalFrequency;             // Main PWM peripheral clock
pin out unsigned info.AnalogInputs;                    // Number of available analog inputs
pin out unsigned info.KeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
pin out unsigned info.TriggeredKeyMapping;             // Device supports triggered key mapping
pin out unsigned info.KeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
pin out unsigned info.DigitalCounters;                 // Device supports digital counters
pin out unsigned info.JoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
pin out unsigned info.JoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
pin out unsigned info.Macros;                          // Device supports customizable macro sequences
pin out unsigned info.MatrixKeyboard;                  // Device supports matrix keyboard
pin out unsigned info.MatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
pin out unsigned info.LCD;                             // Device supports alphanumeric LCD display
pin out unsigned info.MatrixLED;                       // Device supports matrix LED display
pin out unsigned info.ConnectionSignal;                // Device supports connection signal output
pin out unsigned info.PoExtBus;                        // Device supports PoExtBus digital outputs
pin out unsigned info.PoNET;                           // Device supports PoNET bus devices
pin out unsigned info.AnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
pin out unsigned info.InitOutputsStart;                // Device supports initializing outputs at startup
pin out unsigned info.protI2C;                         // Device supports I2C bus (master)
pin out unsigned info.prot1wire;                       // Device supports 1-wire bus (master)
pin out unsigned info.AdditionalOptions;               // Device supports additional options with activation keys
pin out unsigned info.LoadStatus;                      // Device supports reporting load status
pin out unsigned info.CustomDeviceName;                // Device supports specifying custom device names
pin out unsigned info.PoTLog27support;                 // Device supports PoTLog27 firmware
pin out unsigned info.SensorList;                      // Device supports sensor lists
pin out unsigned info.WebInterface;                    // Device supports web interface
pin out unsigned info.FailSafeSettings;                // Device supports fail-safe mode
pin out unsigned info.JoystickHATswitch;               // Device supports joystick HAT switch mapping
pin out unsigned info.PulseEngine;                     // Device supports Pulse engine
pin out unsigned info.PulseEnginev2;                   // Device supports Pulse engine v2
pin out unsigned info.EasySensors;                     // Device supports EasySensors

//pin out unsigned PoExtBus.#.DataGet [10];   
pin out bit PoExtBus.#.digin.0.in [10];
pin out bit PoExtBus.#.digin.1.in[10];
pin out bit PoExtBus.#.digin.2.in[10];
pin out bit PoExtBus.#.digin.3.in[10];
pin out bit PoExtBus.#.digin.4.in[10];
pin out bit PoExtBus.#.digin.5.in[10];
pin out bit PoExtBus.#.digin.6.in[10];
pin out bit PoExtBus.#.digin.7.in[10];
pin out bit PoExtBus.#.digin.0.in-not[10];
pin out bit PoExtBus.#.digin.1.in-not[10];
pin out bit PoExtBus.#.digin.2.in-not[10];
pin out bit PoExtBus.#.digin.3.in-not[10];
pin out bit PoExtBus.#.digin.4.in-not[10];
pin out bit PoExtBus.#.digin.5.in-not[10];
pin out bit PoExtBus.#.digin.6.in-not[10];
pin out bit PoExtBus.#.digin.7.in-not[10];

//pin io unsigned PoExtBus.#.DataSet [10];                 
pin in bit PoExtBus.#.digout.0.out[10];
pin in bit PoExtBus.#.digout.1.out[10];
pin in bit PoExtBus.#.digout.2.out[10];
pin in bit PoExtBus.#.digout.3.out[10];
pin in bit PoExtBus.#.digout.4.out[10];
pin in bit PoExtBus.#.digout.5.out[10];
pin in bit PoExtBus.#.digout.6.out[10];
pin in bit PoExtBus.#.digout.7.out[10];
param rw bit PoExtBus.#.digout.0.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.1.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.2.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.3.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.4.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.5.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.6.invert[10] "If TRUE, out is inverted before writing to the hardware.";
param rw bit PoExtBus.#.digout.7.invert[10] "If TRUE, out is inverted before writing to the hardware.";

// Pulse engine v2 information
pin out unsigned PEv2.nrOfAxes;
pin out unsigned PEv2.maxPulseFrequency;
pin out unsigned PEv2.bufferDepth;
pin out unsigned PEv2.slotTiming;

//***********************************************************************

pin io bit PEv2.params.ApplyIniSettings;
//***********************************************************************

// Pulse engine v2 structure...
pin out unsigned PEv2.#.AxesState [8];				// Axis states (bit-mapped) - see ePK_PEAxisState
pin out unsigned PEv2.#.AxesConfig [8];				// Axis configuration - see ePK_PEv2_AxisConfig
pin in unsigned PEv2.#.AxesSwitchConfig [8];		// Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions
pin in unsigned PEv2.#.AxesCommand [8];		// Axis Command
param rw s32 PEv2.#.home_sequence[8] "home_sequence";

pin io u32 PEv2.#.SoftLimitMaximum [8];		// Soft limit maximum position
pin io u32 PEv2.#.SoftLimitMinimum [8];		// Soft limit minimum position
param rw unsigned PEv2.#.digin.SoftLimit.PosMin[8] "";
param rw unsigned PEv2.#.digin.SoftLimit.PosMax[8] "";

pin io unsigned PEv2.#.HomingSpeed [8];			// Homing speed per axis (in %)
pin io unsigned PEv2.#.HomingReturnSpeed [8];		// Homing return speed per axis (in % of the homing speed)
pin io unsigned PEv2.#.HomingAlgorithm[8];		// Homing algorithm configuration

pin io u32 PEv2.#.HomeOffsets [8];				// Home position offset
param rw unsigned PEv2.#.digin.Home.Offset[8] "";

pin io u32 PEv2.#.ProbePosition [8];			// Position where probe detected change
pin io u32 PEv2.#.ProbeMaxPosition [8];		// Maximum position to travel to until stopping and returning error

pin out s32 PEv2.#.CurrentPosition [8];			// Current position
pin io s32 PEv2.#.PositionSetup [8];			// Position to be set as current position
pin out u32 PEv2.#.ReferencePositionSpeed [8];	// Reference position or speed (position or pulses/s)

pin io float PEv2.#.MaxSpeed [8];					// Maximum axis speed (in pulses per ms)
pin io float PEv2.#.MaxAcceleration [8];			// Maximum axis acceleration (in pulses/ms/ms)
pin io float PEv2.#.MaxDecceleration [8];			// Maximum axis deceleration (in pulses/ms/ms)



//pin io float PEv2.#.MaxSpeed_mm_per_sec [8];			// Maximum axis speed (mm/s)
//pin io float PEv2.#.MaxAcceleration_mm_per_sec2 [8];	// Maximum axis acceleration (in mm/s�)
//pin io float PEv2.#.MaxDecceleration_mm_per_sec2 [8];	// Maximum axis deceleration (in mm/s�)

	
pin in float PEv2.#.joint-vel-cmd [8];				
//pin out float PEv2.#.joint-vel-fb [8];	 -> remove			
pin in float PEv2.#.joint-pos-cmd [8];				
pin out float PEv2.#.joint-pos-fb [8];				

//pin out bit PEv2.#.joint-in-homing[8];
//pin out bit PEv2.#.joint-in-homed[8];
pin in bit PEv2.#.joint-out-home[8];
pin in bit PEv2.#.joint-in-position[8];

//pin in bit joint.#.home-sw-in[8];
//pin in bit joint.#.homing[8];
//pin out bit joint.#.homed[8];
//pin out s32 joint.#.home-state[8];

pin in bit PEv2.#.joint-kb-jog-active[8];
pin in bit PEv2.#.joint-wheel-jog-active[8];

//***********************************************************************
//[JOINT_n] information in HAL-INI 
pin in s32 PEv2.#.stepgen.TYPE [8] "";			//LINEAR / ANGULAR
pin in float PEv2.#.stepgen.HOME [8] "";
pin in float PEv2.#.stepgen.STEPGEN_MAXVEL [8] "";
pin in float PEv2.#.stepgen.STEPGEN_MAXACCEL [8] "";
pin in  float PEv2.#.params.Feedback_Encoder_Id [8] "";
//pin in float PEv2.#.params.P [8];
//pin in float PEv2.#.params.I [8];
//pin in float PEv2.#.params.D [8];
//pin in float PEv2.#.params.FF0 [8];
//pin in float PEv2.#.params.FF1 [8];
//pin in float PEv2.#.params.FF2 [8];
//pin in float PEv2.#.params.BIAS [8];
pin in  float PEv2.#.stepgen.DEADBAND [8] "";
pin in float PEv2.#.stepgen.MAX-OUTPUT [8] "";
pin in  float PEv2.#.stepgen.ENCODER-SCALE [8] "";

// these are in nanoseconds
pin in  float PEv2.#.stepgen.STEP-SCALE[8] "";					// (pulses/mm)
pin in  float PEv2.#.stepgen.MIN-LIMIT[8]  "";					// position (mm)
pin in  float PEv2.#.stepgen.MAX-LIMIT[8]  "";					// position (mm)
pin in  float PEv2.#.stepgen.HOME-OFFSET[8]  "";				// position (mm)
pin in  float PEv2.#.stepgen.HOME-SEARCH_VEL[8]  "";			// position (mm)
pin in  float PEv2.#.stepgen.HOME-LATCH-VEL[8]  "";				// position (mm)
pin in  float PEv2.#.stepgen.HOME-FINAL-VEL[8]  "";				// position (mm)
pin in  s32 PEv2.#.stepgen.HOME-IGNORE-LIMITS[8]  "";			// YES / NO
//***********************************************************************

pin io u32 PEv2.#.MPGjogMultiplier [8];		// MPG jog multiplier value
pin io unsigned PEv2.#.MPGjogEncoder [8];			// MPG jog encoder ID
pin io unsigned PEv2.#.MPGjogDivider[8];			// Divider for the MPG jogging (enhanced encoder resolution)


//pin out unsigned PEv2.#.LimitStatusN[8];					// Limit- status (NOT bit-mapped)
pin out bit PEv2.#.digin.LimitN.in[8];
pin out bit PEv2.#.digin.LimitN.in-not[8];
pin out bit PEv2.#.digin.LimitN.DedicatedInput[8];
param rw unsigned PEv2.#.digin.LimitN.Pin [8] "Limit- switch pin (0 for external dedicated input)";			// Limit- switch pin (0 for external dedicated input)
param rw unsigned PEv2.#.digin.LimitN.Filter[8] "Digital filter for limit- switch";		// Digital filter for limit- switch
param rw bit PEv2.#.digin.LimitN.invert[8] "Invert limit-";

//pin out unsigned PEv2.#.LimitStatusP[8];					// Limit+ status (NOT bit-mapped)
pin out bit PEv2.#.digin.LimitP.in[8];
pin out bit PEv2.#.digin.LimitP.in-not[8];
pin out bit PEv2.#.digin.LimitP.DedicatedInput[8];
param rw unsigned PEv2.#.digin.LimitP.Pin[8] "Limit+ switch pin (0 for external dedicated input)";			// Limit+ switch pin (0 for external dedicated input)
param rw unsigned PEv2.#.digin.LimitP.Filter[8] "Digital filter for limit+ switch";		// Digital filter for limit+ switch
param rw bit PEv2.#.digin.LimitP.invert[8] "Invert limit+";


pin in bit PEv2.#.digout.AxisEnable.out[8];		// Axis enabled output
param rw unsigned PEv2.#.digout.AxisEnable.Pin[8] "Axis enabled output pin (0 for external dedicated output)";		// Axis enabled output pin (0 for external dedicated output)
param rw bit PEv2.#.digout.AxisEnable.invert[8] "Invert axis enable signal"	;	// Invert axis enable signal

//pin out bit PEv2.#.HomeSwitchStat[8];				// Home switch
//pin out bit PEv2.HomeSwitch;				// Home switch
//pin out unsigned PEv2.#.HomeStatus[8];
pin out bit PEv2.#.digin.Home.in[8];					// Home status (NOT bit-mapped)
pin out bit PEv2.#.digin.Home.in-not[8];					// inverted Home status (NOT bit-mapped)
pin out bit PEv2.#.digin.Home.DedicatedInput[8];
param rw unsigned PEv2.#.digin.Home.Pin[8] "Home switch pin (0 for external dedicated input)";			// Home switch pin (0 for external dedicated input)
param rw unsigned PEv2.#.digin.Home.Filter[8] "Digital filter for home-switch";
param rw bit PEv2.#.digin.Home.invert[8] "Invert home-switch";

//pin out bit PEv2.#.LimitMSwitch [8];			// Limit- switch
//pin out bit PEv2.#.LimitPSwitch [8];			// Limit+ switch


pin io unsigned PEv2.#.HomeBackOffDistance [8];		// Back-off distance after homing


pin io unsigned PEv2.PulseEngineEnabled;			// Pulse engine enabled status, also number of enabled axes
pin io unsigned PEv2.PulseGeneratorType;			// Pulse engine generator type (0: external, 1: internal 3ch)
pin in bit PEv2.PG_swap_stepdir;
pin io bit PEv2.PG_extended_io;

pin io unsigned PEv2.ChargePumpEnabled;				// Charge pump output enabled
pin out unsigned PEv2.PulseEngineActivated;			// Pulse engine activation status
pin out unsigned PEv2.PulseEngineState;				// State of pulse engine - see ePoKeysPEState

//pin out unsigned PEv2.ErrorInputStatus;				// Stepper motor driver error inputs status (bit-mapped)
pin out bit PEv2.#.digin.Error.in[8];				// Stepper motor driver error inputs status (NOT bit-mapped)
pin out bit PEv2.#.digin.Error.in-not[8];			// inverted Stepper motor driver error inputs status (NOT bit-mapped)

pin out unsigned PEv2.MiscInputStatus;				// Miscelenous digital inputs...
pin out bit PEv2.digin.Misc-#.in[8];				// Miscelenous digital inputs status (NOT bit-mapped)
pin out bit PEv2.digin.Misc-#.in-not[8];			// inverted Miscelenous digital inputs status (NOT bit-mapped)

pin io unsigned PEv2.LimitOverride;					// Limit override status
pin io unsigned PEv2.LimitOverrideSetup;			// Limit override configuration

pin out bit PEv2.digin.Probed.in;
pin out bit PEv2.#.digin.Probe.in[8];				// Stepper motor driver error inputs status (NOT bit-mapped)
pin out bit PEv2.#.digin.Probe.in-not[8];			// inverted Stepper motor driver error inputs status (NOT bit-mapped)

param rw unsigned PEv2.digin.Emergency.Pin "";
pin out bit PEv2.digin.Emergency.in;
pin out bit PEv2.digin.Emergency.in-not;
param rw unsigned PEv2.digin.Emergency.invert "Emergency switch polarity (set to 1 to invert)";		// Emergency switch polarity (set to 1 to invert)
param rw unsigned PEv2.digout.Emergency.Pin "added in component only for estop-out to reset estop (if 0 EmergencyInput will be reused)";				//added in component only for estop-out to reset estop (if 0 EmergencyInput will be reused)
pin in bit PEv2.digout.Emergency.out;


//pin io unsigned PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration  - No Pin needed
pin out unsigned PEv2.#.digin.SoftLimit.in[8] ;				// Bit-mapped soft-limit statuses per axes
/* 			PEv2_LimitNSwitch_DedicatedInput(i) =  Get_BitOfByte(bm_DedicatedLimitNInputs,i);
			PEv2_DedicatedLimitPInputs(i) =  Get_BitOfByte(bm_DedicatedLimitPInputs,i);
			PEv2_digin_Home_DedicatedInput(i) =  Get_BitOfByte(bm_DedicatedHomeInputs,i);
								PEv2_digin_AxisEnabled_in(i) = false;
					PEv2_AxisLimitOverride(i) = false;
			*/

pin io unsigned PEv2.AxisEnabledMask;				// Bit-mapped ouput enabled mask
pin io unsigned PEv2.AxisEnabledStatesMask;		// Bit-mapped states, where axis enabled and charge pump signals are active
pin in bit PEv2.#.digout.AxisEnabled.out[8];
pin out bit PEv2.#.digin.AxisEnabled.in[8] ;
pin out bit PEv2.#.digout.LimitOverride.out [8] ;

pin out unsigned PEv2.ExternalRelayOutputs;			// External relay outputs
pin out unsigned PEv2.ExternalOCOutputs;			// External open-collector outputs
pin in bit PEv2.digout.ExternalRelay-#.out[4];			// External relay outputs
pin in bit PEv2.digout.ExternalOC-#.out[4];			// External open-collector outputs

pin io unsigned PEv2.HomingStartMaskSetup;			// Bit-mapped axes indexes to be homed
pin io unsigned PEv2.ProbeStartMaskSetup;			// Bit-mapped axis indexes for probing

param rw unsigned PEv2.digin.Probe.Pin "Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)";					// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
param rw unsigned PEv2.digin.Probe.invert "Probe input polarity";			// Probe input polarity
pin out unsigned PEv2.ProbeStatus;					// Probe status (probe completion bit-mapped status)
pin io float PEv2.ProbeSpeed;						// Probe speed (ratio of the maximum speed)

pin io unsigned PEv2.#.BacklashWidth [8];			// half of real backlash width
pin io unsigned PEv2.#.BacklashRegister [8];		// current value of the backlash register
pin io unsigned PEv2.#.BacklashAcceleration [8];	// in pulses per ms^2
pin io unsigned PEv2.BacklashCompensationEnabled;

pin out unsigned rtc.sec;
pin out unsigned rtc.min;
pin out unsigned rtc.hour;
pin out unsigned rtc.dow;
pin out unsigned rtc.dom;
pin out unsigned rtc.tmp;
pin out unsigned rtc.doy;
pin out unsigned rtc.month;
pin out unsigned rtc.year;
pin out unsigned rtc.loopcount;


pin out unsigned rtc.lastmin;
pin out unsigned rtc.lastsec;
pin out unsigned rtc.loop_frequ;
pin in unsigned rtc.loop_frequ_demand;
pin in unsigned rtc.sec_ret;
pin out unsigned rtc.hal_latency;

//pin out unsigned Pins.#.PinFunction[55];

//pin out unsigned Pins.#.DigitalCounterAvailable[55];
//pin out unsigned Pins.#.DigitalCounterValue [55];
pin out unsigned counter.#.value[55];
//pin out unsigned Pins.#.CounterOptions[55];


//pin out unsigned Pins.#.AnalogValue [55];
pin out float adcin.#.value-raw[7];
pin out float adcin.#.value[7];
param rw float adcin.#.scale[7]  "The input voltage (or current) will be multiplied by scale before being output to value.";
param rw float adcin.#.offset[7] "This will be subtracted from the hardware input voltage (or current) after the scale multiplier has been applied.";
//param rw float adcin.#.bit_weight[7] "The value of one least significant bit (LSB). This is effectively the granularity of the input reading.";
//param rw float adcin.#.hw_offset[7] "The value present on the input when 0 volts is applied to the input pin(s).";

//pin out bit Pins.#.DigitalValueGet [55];
pin out bit digin.#.in[55];
pin out bit digin.#.in-not[55];

//pin in bit Pins.#.DigitalValueSet [55];
pin in bit digout.#.out[55];
param rw bit digout.#.invert[55] "If TRUE, out is inverted before writing to the hardware.";

pin out s32 encoder.#.count[29];
pin out float encoder.#.position[29];
pin out float encoder.#.velocity[29];
pin in bit encoder.#.reset[29];
pin in bit encoder.#.index-enable[29];
param rw float encoder.#.scale[29]  "The scale factor used to convert counts to position units. It is in “counts per position unit”";

pin in float adcout.#.value[6];
pin in bit adcout.#.enable[6];
param rw float adcout.#.offset[6]  "This will be added to the value before the hardware is updated";
param rw float adcout.#.scale[6]  "This should be set so that an input of 1 on the value pin will cause 1V";
param rw float adcout.#.high_limit[6]  "When calculating the value to output to the hardware, if value +offset is greater than high_limit, then high_limit will be used instead.";
param rw float adcout.#.low_limit[6]  "When calculating the value to output to the hardware, if value +offset is less than low_limit, then low_limit will be used instead";
param rw float adcout.#.max_v[6] "max v";
param r unsigned adcout.#.PinId[6] "max v";

param rw unsigned adcout.pwm.period  "PWM period, shared among all channels";
//pin out unsigned Pins.#.MappingType [55];
//pin out unsigned Pins.#.KeyCodeMacroID [55];
//pin out unsigned Pins.#.KeyModifier [55];
//pin out unsigned Pins.#.downKeyCodeMacroID [55];
//pin out unsigned Pins.#.downKeyModifier [55];
//pin out unsigned Pins.#.upKeyCodeMacroID [55];
//pin out unsigned Pins.#.upKeyModifier [55];
//pin out unsigned Pins.#.preventUpdate [55];

/*
pin out unsigned MatrixKB.matrixKBconfiguration;		// Matrix keyboard configuration (set to 1 to enable matrix keyboard support)
pin out unsigned MatrixKB.matrixKBwidth;				// Matrix keyboard width (number of columns)
pin out unsigned MatrixKB.matrixKBheight;				// Matrix keyboard height (number of rows)
pin out unsigned MatrixKB.matrixKBcolumnsPins.#[8];		// List of matrix keyboard column connections
pin out unsigned MatrixKB.matrixKBrowsPins.#[16];			// List of matrix keyboard row connections
//pin out unsigned MatrixKB.matrixKBvalues.#[128];			// Current state of each matrix keyboard key (assumes fixed width of 8 columns)
//pin out bit MatrixKB.matrixKBPins.#[128];			// matrixKBrowsPins
*/

pin out bit kbd48CNC.available;
pin io unsigned kbd48CNC.PoNetID;
pin io unsigned kbd48CNC.KeyBrightness;
pin io unsigned kbd48CNC.prevBrightness;
pin io unsigned kbd48CNC.lightValue;
//pin io unsigned kbd48CNC.#.ID [48];
pin in bit kbd48CNC.#.LED [48];
pin out bit kbd48CNC.#.Button [48];


//pin out unsigned Encoders.#.encoderValue [26];       // Encoder current value
//pin io unsigned Encoders.#.encoderOptions [26];      // Encoder options -    bit 0: enable encoder
													//                      bit 1: 4x sampling
													//                      bit 2: 2x sampling
													//                      bit 3: reserved
													//                      bit 4: direct key mapping for direction A
													//                      bit 5: mapped to macro for direction A
													//                      bit 6: direct key mapping for direction B
													//                      bit 7: mapped to macro for direction B
//pin io unsigned Encoders.#.channelApin [26];         // Channel A encoder pin
//pin io unsigned Encoders.#.channelBpin [26];         // Channel B encoder pin

/*
pin out u32 EasySensors.#.sensorValue[16];            // Current sensor value
pin out unsigned EasySensors.#.sensorType[16];             // Type of the sensor
pin out unsigned EasySensors.#.sensorRefreshPeriod[16];    // Refresh period in 0.1s
pin out unsigned EasySensors.#.sensorFailsafeConfig[16];   // Failsafe configuration (bits 0-5: timeout in seconds, bit 6: invalid=0, bit 7: invalid=0x7FFFFFFF)
pin out unsigned EasySensors.#.sensorReadingID[16];        // Sensor reading selection (see Protocol description document for details)

*/


/*

pin io unsigned PoStep.EnablePoStepCommunication;
// Status
pin out unsigned PoStep.#.SupplyVoltage[8];
pin out unsigned PoStep.#.Temperature[8];
pin out unsigned PoStep.#.InputStatus[8];
pin out unsigned PoStep.#.DriverStatus[8];
pin out unsigned PoStep.#.FaultStatus[8];
pin out unsigned PoStep.#.UpdateState[8];

// Settings
pin io unsigned PoStep.#.DriverMode[8];
pin io unsigned PoStep.#.StepMode[8];
pin io unsigned PoStep.#.Current_FS[8];
pin io unsigned PoStep.#.Current_Idle[8];
pin io unsigned PoStep.#.Current_Overheat[8];
pin io unsigned PoStep.#.TemperatureLimit[8];

// Configuration
pin io unsigned PoStep.#.AddressI2C[8];
pin io unsigned PoStep.#.DriverType[8];
pin io unsigned PoStep.#.UpdateConfig[8];
*/

/*
pin io unsigned PWM.PWMperiod;
pin io unsigned PWM.#.PWMduty[6];
pin io unsigned PWM.#.PWMenabledChannels[6];
pin io unsigned PWM.#.PWMpinIDs[6];
*/


pin out unsigned PoNET.#.moduleID[16];
pin out unsigned PoNET.#.i2cAddress[16];
pin out unsigned PoNET.#.moduleType[16];
pin out unsigned PoNET.#.moduleSize[16];
pin out unsigned PoNET.#.moduleOptions[16];

pin io unsigned PoNET.PWMduty;
pin io unsigned PoNET.lightValue;
pin out unsigned PoNET.PoNETstatus;
pin out unsigned PoNET.DevCount;
pin out unsigned PoNET.#.statusIn[16];
pin in unsigned PoNET.#.statusOut[16];



/*
pin io unsigned MatrixLED.displayEnabled;                    // Display enabled byte - set to 1 to enable the display
pin io unsigned MatrixLED.rows;                              // Number of Matrix LED rows
pin io unsigned MatrixLED.columns;                           // Number of Matrix LED columns
pin io unsigned MatrixLED.RefreshFlag;                       // Flag for refreshing data - set to 1 to refresh the display
pin io unsigned MatrixLED.#.data[8];                           // Matrix LED buffer - one byte per row (assumes 8 columns)

*/

/*
pin io unsigned LCD.Configuration;                     // LCD configuration byte - 0: disabled, 1: enabled on primary pins, 2: enabled on secondary pins
pin io unsigned LCD.Rows;                              // Number of LCD module rows
pin io unsigned LCD.Columns;                           // Number of LCD module columns
pin io unsigned LCD.RowRefreshFlags;                   // Flag for refreshing data - bit 0: row 1, bit 1: row 2, bit 2: row 3, bit 3: row 4

pin io unsigned LCD.line1.# [20];                         // Line 1 buffer
pin io unsigned LCD.line2.# [20];                         // Line 2 buffer
pin io unsigned LCD.line3.# [20];                         // Line 3 buffer
pin io unsigned LCD.line4.# [20];                         // Line 4 buffer
*/

/*
pin out unsigned I2C.#.presentDevices [16];
pin out bit I2C.scanning ;
*/

license "GPL";
author "Dominik Zarfl";
//version "0.1.0";
option extra_link_args "-lPoKeys";
option extra_setup yes;
option userspace yes;
;;

#include <unistd.h>   /* UNIX standard function definitions */

//#include "<math.h>"
#include "PoKeysLib.h"
#include "rtapi.h"
//#include "rtapi_app.h"
#include "hal.h"
#include "stdio.h"

sPoKeysDevice * dev = NULL;
static int comp_id ;		/* component ID */
bool initEncodersDone = 0;
bool HAL_Machine_On = false;
bool setPkConfig = false;
bool setPinConfig = false;
bool I2C_isscanning = false;
bool secBlink = false;
unsigned Loop_Frequ =0;
uint8_t kbd48CNC_Counter[48];
uint8_t PoNet_Count=0;
bool posMode[8] ;
uint8_t  posCount[8];
uint8_t  velCount[8];
float last_joint_pos_cmd[8];
float last_joint_vel_cmd[8];
uint8_t rtc_latencycheck_set = 0;
int rtc_latencyCounter = 0;
//pin io unsigned PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration  - No Pin needed
uint8_t PEv2_PulseEngineStateSetup = 0;
uint8_t PulseEngineState = 0;
bool Pins_DigitalValueSet_ignore[55];




int i=0;



typedef struct
{
    uint8_t matrixKBconfiguration;             // Matrix keyboard configuration (set to 1 to enable matrix keyboard support)
    uint8_t matrixKBwidth;                     // Matrix keyboard width (number of columns)
    uint8_t matrixKBheight;                    // Matrix keyboard height (number of rows)
    uint8_t reserved[5];                       // placeholder
    uint8_t matrixKBcolumnsPins[8];            // List of matrix keyboard column connections
    uint8_t matrixKBrowsPins[16];              // List of matrix keyboard row connections
    uint8_t macroMappingOptions[128];          // Selects between direct key mapping and mapping to macro sequence for each key (assumes fixed width of 8 columns)
//    uint8_t keyMappingKeyCode[128];            // USB keyboard key code for each key (assumes fixed width of 8 columns), also down key code in triggered mapping mode
//    uint8_t keyMappingKeyModifier[128];        // USB keyboard key modifier, also down key modifier in triggered mapping mode (assumes fixed width of 8 columns)
//    uint8_t keyMappingTriggeredKey[128];       // Selects between normal direct key mapping and triggered key mapping for each key (assumes fixed width of 8 columns)
//    uint8_t keyMappingKeyCodeUp[128];          // USB keyboard up key code in triggered mapping mode (assumes fixed width of 8 columns)
//    uint8_t keyMappingKeyModifierUp[128];      // USB keyboard up key modifier in triggered mapping mode (assumes fixed width of 8 columns)
//    uint8_t matrixKBvalues[128];               // Current state of each matrix keyboard key (assumes fixed width of 8 columns)
//	bool matrixKBPins[128];               // extracted from matrixKBrowsPins

} PK_MatrixKB_Parameters;


/*
sPoKeysEasySensor EasySensors[16];
hal_pin_u32_t EasySensors_sensorValue[16];
hal_pin_u32_t EasySensors_sensorType[16];
hal_pin_u32_t EasySensors_sensorRefreshPeriod[16];
hal_pin_u32_t EasySensors_sensorFailsafeConfig[16];
hal_pin_u32_t EasySensors_sensorReadingID[16];
*/


sPoNETmodule PoNet[16];

uint8_t PoExtBus_DataSet[10];
uint8_t PoExtBus_DataGet[10];

unsigned int  sleepdur = 1000;
bool  use_sleepdur1 = true;
unsigned int  sleepdur1 = 1000;
unsigned int  sleepdur2 = 1000;
float StepScale[8];

bool DoPWM = false;
bool DoEncoders = false;

PK_MatrixKB_Parameters MatrixKB;

bool Get_BitOfByte(uint8_t in_Byte, int Bit_Id)
{
	return (in_Byte >> Bit_Id) & 0x01;
}

uint8_t Set_BitOfByte(uint8_t in_Byte, int Bit_Id, bool value)
{

	if (value == true)
	{
		in_Byte |= 1 << Bit_Id;
	}
	else
	{
		in_Byte &= ~(1 << Bit_Id);
	}
	return in_Byte;

}

uint8_t Merge_8BitsToByte(bool Bit_array[8])
{
  uint8_t sum = 0;
  for (int i = 0; i < 8; i++)
  {
//    sum += Bit_array[i] - '0';
//    sum<<=1;

	if (Bit_array[i]  == true)
	{
		sum |= 1 << i;
	}
	else
	{
		sum &= ~(1 << i);
	}

  }
  return sum;
}

int Update_PoNet()
{
	if(PK_PoNETGetPoNETStatus(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}
	if(PK_PoNETGetModuleSettings(dev) == PK_OK)
	{
		usleep(sleepdur); 	
	}
	return 0;
}



int Config_MatrixKB()
{

/* no setting
dev->matrixKB.matrixKBconfiguration = 1;
dev->matrixKB.matrixKBheight = 6;
dev->matrixKB.matrixKBwidth = 8;
PK_MatrixKBConfigurationSet(dev);
PK_MatrixKBConfigurationSet(dev);*/

	if(PK_MatrixKBConfigurationGet(dev) == PK_OK)
	{
			MatrixKB.matrixKBconfiguration = dev->matrixKB.matrixKBconfiguration;
			MatrixKB.matrixKBwidth = dev->matrixKB.matrixKBheight;
			MatrixKB.matrixKBheight = dev->matrixKB.matrixKBwidth;

			for (i = 0; i < 8; i++)
			{
				MatrixKB.matrixKBrowsPins[i] = dev->matrixKB.matrixKBrowsPins[i];
				MatrixKB.matrixKBrowsPins[8+i] = dev->matrixKB.matrixKBrowsPins[8 + i];

				MatrixKB.matrixKBcolumnsPins[i] = dev->matrixKB.matrixKBcolumnsPins[i];
			}

			for (i = 0; i < 128; i++)
			{
				MatrixKB.macroMappingOptions[i]  = dev->matrixKB.macroMappingOptions[i];
			}
			usleep(sleepdur); 

	}

	//PK_MatrixKBConfigurationSet
	return 0;
}

int Update_MatrixKB()
{
	if(PK_MatrixKBStatusGet(dev) == PK_OK)
	{
		for (i = 0; i < 128; i++)
		{
		//	MatrixKB.matrixKBvalues[i] = dev->matrixKB.matrixKBvalues[i];
		}
		usleep(sleepdur); 
	}
	if(PK_MatrixKBConfigurationGet(dev) == PK_OK)
	{
		int i =0;
		int h =0;
		int w =0;
		for (h = 0; h < MatrixKB.matrixKBheight; h++)
		{
			for (w = 0; w < MatrixKB.matrixKBwidth; w++)
			{
			//	MatrixKB.matrixKBPins[i] = Get_BitOfByte(MatrixKB.matrixKBrowsPins[h], w);
				i++;
			}
		}
		usleep(sleepdur); 
	}
	return 0;
}




/*int Config_LCD()
{
	if(PK_LCDConfigurationGet(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}

	//PK_LCDConfigurationSet
	// Change between modes PK_LCD_MODE_DIRECT and PK_LCD_MODE_BUFFERED
	// PK_LCDChangeMode(dev, PK_LCD_MODE_DIRECT);
	return 0;
}*/

int Update_LCD()
{
	if(PK_LCDUpdate(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}
	if(PK_LCDSetCustomCharacters(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}
	return 0;
}

/*
int Init_EasySensors()
{
	if(PK_EasySensorsSetupGet(dev) == PK_OK)
	{

		for (i = 0; i < dev->info.iEasySensors; i++)
		{
			pin out u32 EasySensors.%d.sensorValue [16];            // Current sensor value
			pin out unsigned EasySensors.%d.sensorType [16];             
			pin out unsigned EasySensors.%d.sensorRefreshPeriod [16];    
			pin out unsigned EasySensors.%d.sensorFailsafeConfig [16];  
			pin out unsigned EasySensors.%d.sensorReadingID [16];        // Sensor reading selection (see Protocol description document for details)


			char pinName[32];
			
			snprintf(pinName, sizeof(pinName), "EasySensors.%d.sensorValue", i);  // Current sensor value
			hal_pin_u32_new(pinName, HAL_IN,&EasySensors_sensorValue[i],comp_id);
			
			snprintf(pinName, sizeof(pinName), "EasySensors.%d.sensorType", i);  // Type of the sensor
			hal_pin_u32_new(pinName, HAL_IN,&EasySensors_sensorType[i],comp_id);
			
			snprintf(pinName, sizeof(pinName), "EasySensors.%d.sensorRefreshPeriod", i);  // Refresh period in 0.1s
			hal_pin_u32_new(pinName, HAL_IN,&EasySensors_sensorRefreshPeriod[i],comp_id);
			
			snprintf(pinName, sizeof(pinName), "EasySensors.%d.sensorFailsafeConfig", i);  // Failsafe configuration (bits 0-5: timeout in seconds, bit 6: invalid=0, bit 7: invalid=0x7FFFFFFF)
			hal_pin_u32_new(pinName, HAL_IN,&EasySensors_sensorFailsafeConfig[i],comp_id);
			
			snprintf(pinName, sizeof(pinName), "EasySensors.%d.sensorReadingID", i);  // Sensor reading selection (see Protocol description document for details)
			hal_pin_u32_new(pinName, HAL_IN,&EasySensors_sensorReadingID[i],comp_id);
			

		}
		usleep(sleepdur); 
	}

	//PK_EasySensorsSetupSet
	return 0;
}


int Config_EasySensors()
{
	if(PK_EasySensorsSetupGet(dev) == PK_OK)
	{
		for (i = 0; i < dev->info.iEasySensors; i++)
		{
			EasySensors[i] = dev->EasySensors[i];
		}
		usleep(sleepdur); 
	}

	//PK_EasySensorsSetupSet
	return 0;
}

int Update_EasySensors()
{
	if(PK_EasySensorsValueGetAll(dev) == PK_OK)
	{
		for (i = 0; i < dev->info.iEasySensors; i++)
		{
			EasySensors[i] = dev->EasySensors[i];
		}
		usleep(sleepdur); 
	}
	return 0;
}
*/




int Config_PoStep()
{
	if(PK_PoStep_ConfigurationGet(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}

	if(PK_PoStep_DriverConfigurationGet(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}

	//PK_PoStep_ConfigurationSet(dev)
	//PK_PoStep_DriverConfigurationSet(dev)
	return 0;
}

int Update_PoStep()
{
	if(PK_PoStep_StatusGet(dev) == PK_OK)
	{
		usleep(sleepdur); 
	}
	return 0;
}

static char* serial_number = "";	
//Not available in userspace code.
//RTAPI_MP_STRING(serial_number, "Device Serial Number") 

static int ConnectionType = 0; // 1..USB, 2..UDP, 3..Network, 4..fastUSB
//Not available in userspace code.
//RTAPI_MP_INT(ConnectionType, "Connection Type (1..USB, 2..UDP, 3..Network, 4..fastUSB)")

static char* IP = "0.0.0.0"; 
//Not available in userspace code.
//RTAPI_MP_STRING(IP, "IP Address")

static int timeout_ms = 5000;
//Not available in userspace code.
//RTAPI_MP_INT(timeout_ms, "Timeout in ms")

static int retry = 3;

int instance_number = 0;

sPoKeysDevice* TryConnectToDevice(uint32_t intSerial)
{
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: serial_number: %d\n", intSerial);
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: serial_number=%d\n", __FILE__, __FUNCTION__, intSerial);
	sPoKeysDevice* retDev = NULL;
	uint32_t i_Timeout = 1000;
	uint32_t enm_usb_dev = 0;
	uint32_t enm_fusb_dev = 0;
	uint32_t enm_udp_dev = 0;
	int32_t nDevs = 0;
	uint32_t lastConectionTypeTried = 0;

	if (timeout_ms > 0)
	{
		i_Timeout = timeout_ms;
	}
	if (intSerial != 0)
	{

		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: intSerial=%d\n", __FILE__, __FUNCTION__, intSerial);
		if (retDev == NULL)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateUSBDevices\n", __FILE__, __FUNCTION__);
			enm_usb_dev = PK_EnumerateUSBDevices();
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: enm_usb_dev :%d\n", __FILE__, __FUNCTION__, enm_usb_dev);
			if (enm_usb_dev != 0)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial(%d, %d)", __FILE__, __FUNCTION__, intSerial, i_Timeout);
				retDev = PK_ConnectToDeviceWSerial(intSerial, i_Timeout);  //waits for usb device
				lastConectionTypeTried = 1;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 1\n", __FILE__, __FUNCTION__);
			}
		}
		if (retDev == NULL)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d)", __FILE__, __FUNCTION__, intSerial, i_Timeout);
			retDev = PK_ConnectToDeviceWSerial_UDP(intSerial, i_Timeout);  //waits for udp device
			lastConectionTypeTried = 2;
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 2\n", __FILE__, __FUNCTION__);
		}
		if (retDev == NULL)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SearchNetworkDevices(net_devices, %d, %d)\n", __FILE__, __FUNCTION__, i_Timeout, intSerial);
			sPoKeysNetworkDeviceSummary* net_devices;
			int32_t nDevs = PK_SearchNetworkDevices(net_devices, i_Timeout, intSerial);
			if (nDevs != 0)
			{
				enm_udp_dev = nDevs;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices)\n", __FILE__, __FUNCTION__);
				retDev = PK_ConnectToNetworkDevice(net_devices);
				lastConectionTypeTried = 3;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
			}
			else
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateNetworkDevices(net_devices, %d)\n", __FILE__, __FUNCTION__, i_Timeout);
				//	nDevs = PK_EnumerateNetworkDevices(net_devices, i_Timeout); // does not work - it hangs here
				//deb_out = 1135;
				if (nDevs != 0)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: nDevs: %s\n", __FILE__, __FUNCTION__, nDevs);
					enm_udp_dev = nDevs;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(net_devices)\n", __FILE__, __FUNCTION__);
					retDev = PK_ConnectToNetworkDevice(net_devices);
					lastConectionTypeTried = 3;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
				}
			}
		}
	}
	else
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: udp_devices[16]\n", __FILE__, __FUNCTION__);
		sPoKeysNetworkDeviceSummary udp_devices[16];
		
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateUSBDevices()\n", __FILE__, __FUNCTION__);
		enm_usb_dev = PK_EnumerateUSBDevices();
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateUSBDevices()=%d\n", __FILE__, __FUNCTION__, enm_usb_dev);

		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateFastUSBDevices()\n", __FILE__, __FUNCTION__);
		//enm_fusb_dev = PK_EnumerateFastUSBDevices();
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateFastUSBDevices()=%d\n", __FILE__, __FUNCTION__, enm_fusb_dev);
		i_Timeout=1000;
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EnumerateNetworkDevices(udp_devices, %d)\n", __FILE__, __FUNCTION__, i_Timeout);
		int32_t nDevs = PK_EnumerateNetworkDevices(udp_devices, i_Timeout); // does not work - it hangs here
	//	rtapi_print("");
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: nDevs: %d\n", __FILE__, __FUNCTION__, nDevs);
		//enm_udp_dev = nDevs;
		
		if (nDevs != 0)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToNetworkDevice(udp_devices) - %d\n", __FILE__, __FUNCTION__, nDevs);
			for (int i = 0; i < 16; i++)
			{
				if (retDev == NULL)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: udp_devices[%d].SerialNumber: %d\n", __FILE__, __FUNCTION__, i, udp_devices[i].SerialNumber);
					if (udp_devices[i].SerialNumber != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDeviceWSerial_UDP(%d, %d)\n", __FILE__, __FUNCTION__, udp_devices[i].SerialNumber, i_Timeout);
						retDev = PK_ConnectToDeviceWSerial_UDP(udp_devices[i].SerialNumber, i_Timeout);  //waits for udp device
						lastConectionTypeTried = 2;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 2\n", __FILE__, __FUNCTION__);
					}
				}
				else
				{
					break;
				}
			}
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: lastConectionTypeTried = 3\n", __FILE__, __FUNCTION__);
		}
		if (enm_fusb_dev > 0)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDevice FastUSB\n", __FILE__, __FUNCTION__);
			for (int i = 0; i < enm_fusb_dev; i++)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDevice(%d)\n", __FILE__, __FUNCTION__, i);
				retDev = PK_ConnectToDevice(i);
			}
			lastConectionTypeTried = 4;
		}

		if (enm_usb_dev > 0)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDevice FastUSB\n", __FILE__, __FUNCTION__);
			for (int i = 0; i < enm_usb_dev; i++)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_ConnectToDevice(%d)\n", __FILE__, __FUNCTION__, i);
				retDev = PK_ConnectToDevice(i);
			}
			lastConectionTypeTried = 4;
		}
		//deb_out = 120;
	}
	if (retDev != NULL)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Connected to device\n", __FILE__, __FUNCTION__);
		//connected = 1;
		if (lastConectionTypeTried == 1)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: USB\n", __FILE__, __FUNCTION__);
			// cannot set pins outside of user_mainloop()
			//	connected_usb = 1;
			//	connected_fusb = 0;
			//	connected_udp = 0;
			//	connected_net = 0;
		}
		if (lastConectionTypeTried == 2)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: UDP\n", __FILE__, __FUNCTION__);
			// cannot set pins outside of user_mainloop()
			//	connected_usb = 0;
			//	connected_fusb = 0;
			//	connected_udp = 1;
			//	connected_net = 0;
		}
		if (lastConectionTypeTried == 3)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Network\n", __FILE__, __FUNCTION__);
			// cannot set pins outside of user_mainloop()
			//	connected_usb = 0;
			//	connected_fusb = 0;
			//	connected_udp = 0;
			//	connected_net = 1;
		}
		return retDev;
	}
	else
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: failed to connect to device\n", __FILE__, __FUNCTION__);
		//connected_usb = 0;
		//connected_fusb = 0;
		//connected_udp = 0;
		//connected_net = 0;
		//err = 1;
		return NULL;
	}
}

bool initdone = 0;

void user_mainloop(void) 
{ 

	rtapi_print("  \n");
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: user_mainloop started  \n", __FILE__, __FUNCTION__);
	rtapi_print("  \n");
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: trigger hal_init('pokeys'#')\n", __FILE__, __FUNCTION__);
	comp_id = hal_init("pokeys");
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: comp_id: %d\n", __FILE__, __FUNCTION__, comp_id);
	rtapi_print("  \n");
    while(0xb)
	{
		rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: while(0xb) \n", __FILE__, __FUNCTION__);

		FOR_ALL_INSTS() 
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: FOR_ALL_INSTS() \n", __FILE__, __FUNCTION__);
			rtc_loopcount++;
			HAL_Machine_On = machine_is_on;

			deb_out = 100;
			
            rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: initdone: %s\n", __FILE__, __FUNCTION__, initdone ? "true" : "false");
			while(dev == NULL | initdone !=1 )
			{
				Loop_Frequ = rtc_loop_frequ;
				uint32_t lastConectionTypeTried = 0;
				if (PEv2_digout_Emergency_out!=true)
				{
					usleep(sleepdur); 
				}
				
				if (dev == NULL)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: TryConnectToDevice %d \n", __FILE__, __FUNCTION__, devSerial);
					dev = TryConnectToDevice(devSerial);
					if (dev != NULL)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Connected to device\n", __FILE__, __FUNCTION__);
					}
				}

				if (dev != NULL)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev != NULL\n", __FILE__, __FUNCTION__);
					if (devSerial == 0)
					{
						
						devSerial = dev->DeviceData.SerialNumber;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: devSerial: %d\n", __FILE__, __FUNCTION__, devSerial);
					}
					switch (dev->connectionType)
					{
						case PK_DeviceType_USBDevice:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: USB\n", __FILE__, __FUNCTION__);
							connected_usb = 1;
							connected_fusb = 0;
							connected_udp = 0;
							connected_net = 0;
							break;
						case PK_DeviceType_FastUSBDevice:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: FastUSB\n", __FILE__, __FUNCTION__);
							connected_usb = 0;
							connected_fusb = 1;
							connected_udp = 0;
							connected_net = 0;
							break;
						case PK_DeviceType_NetworkDevice:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: NetworkDevice\n", __FILE__, __FUNCTION__);

							/*  PK_ConnectionParam_TCP = 0,
								PK_ConnectionParam_UDP = 1*/
							if (dev->connectionParam == 0)
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: TCP\n", __FILE__, __FUNCTION__);
								connected_usb = 0;
								connected_fusb = 0;
								connected_udp = 0;
								connected_net = 1;
							}
							else
							{
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: UDP\n", __FILE__, __FUNCTION__);
								connected_usb = 0;
								connected_fusb = 0;
								connected_udp = 1;
								connected_net = 0;
							}

							break;
					}


					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: initialize info pins\n", __FILE__, __FUNCTION__);
					
					info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
					info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
					info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
					info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
					info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
					info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
					info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
					info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of info_protI2Cavailable analog inputs
					info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
					info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
					info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
					info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
					info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
					info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
					info_Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
					info_MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
					info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
					info_LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
					info_MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
					info_ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
					info_PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
					info_PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
					info_AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
					info_InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
					info_protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
					info_prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
					info_AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
					info_LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
					info_CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
					info_PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
					info_SensorList = dev->info.iSensorList;                      // Device supports sensor lists
					info_WebInterface = dev->info.iWebInterface;                    // Device supports web interface
					info_FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
					info_JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
					info_PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
					info_PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
					info_EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors

					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Device info pins initialized\n", __FILE__, __FUNCTION__);
					switch (dev->DeviceData.DeviceTypeID)
					{
						case PK_DeviceID_PoKeys57CNC:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_PoKeys57CNC\n", __FILE__, __FUNCTION__);
							PEv2_PulseEngineEnabled = 8;
							PEv2_PG_extended_io = true;
							break;
						case PK_DeviceID_PoKeys57CNCdb25:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_PoKeys57CNCdb25\n", __FILE__, __FUNCTION__);
							PEv2_PG_extended_io = false;
							break;
						case PK_DeviceID_57U:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_57U\n", __FILE__, __FUNCTION__);
							PEv2_PG_extended_io = false;
							break;
						case PK_DeviceID_57E:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DeviceID_57E\n", __FILE__, __FUNCTION__);
							PEv2_PG_extended_io = false;
							break;
					}

					if (info_PoNET != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PoNET != 0\n", __FILE__, __FUNCTION__);
						PoNet_Count = 0;
						for (i = 0; i < 16; i++)
						{
							dev->PoNETmodule.moduleID = i;
							if (PK_PoNETGetModuleSettings(dev) == PK_OK)
							{
								//		PoNET_moduleID(i) = i;
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PoNET_moduleID(%d)\n", __FILE__, __FUNCTION__, i);
								PoNET_i2cAddress(i) = dev->PoNETmodule.i2cAddress;
								PoNET_moduleType(i) = dev->PoNETmodule.moduleType;
								PoNET_moduleSize(i) = dev->PoNETmodule.moduleSize;
								PoNET_moduleOptions(i) = dev->PoNETmodule.moduleOptions;
								if (dev->PoNETmodule.moduleType != 0)
								{
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PoNETmodule.moduleType(%d) = %d\n", __FILE__, __FUNCTION__, i, dev->PoNETmodule.moduleType);
									PoNet_Count++;
								}
								if (dev->PoNETmodule.moduleType == 0x10 && kbd48CNC_available == 0)
								{
									if ((dev->PoNETmodule.moduleOptions & (1 << 7)) != 0)
									{
										// kbd48CNC is also detected
										rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kb48CNC detected\n", __FILE__, __FUNCTION__);
										kbd48CNC_PoNetID = i;
											//dev->deviceConfig->iEnableKBD48CNC = 1;
										kbd48CNC_available = 1;
									}
								}
								usleep(sleepdur);
							}
							PoNET_DevCount = PoNet_Count;
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PoNet Count: %d\n", __FILE__, __FUNCTION__, PoNet_Count);
					}

					if (kbd48CNC_available != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kbd48CNC_available != 0\n", __FILE__, __FUNCTION__);
						for (i = 0; i < 48; i++)
						{
							int offset[] = { 15, 8, 7, 0 };
							int top = (i & 0xF0) + offset[(i / 4) % 4];
							int y = i % 4;
							int ID = top + y;
							if (((i / 4) % 2) == 0)
								ID = top - y;
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kb48CNC init done\n", __FILE__, __FUNCTION__);
					}


					/*			if (info_MatrixKeyboard!=0)
								{
									dev->matrixKB.matrixKBconfiguration = 1;
									Config_MatrixKB;

								}
					*/
					/*
								if (info_EasySensors!=0)
								{
									Config_EasySensors;
									for (i = 0; i < dev->info.iEasySensors; i++)
									{
										EasySensors_sensorValue(i) = EasySensors[i].sensorValue;            // Current sensor value
										EasySensors_sensorType(i)= EasySensors[i].sensorType;             // Type of the sensor
										EasySensors_sensorRefreshPeriod(i)= EasySensors[i].sensorRefreshPeriod;    // Refresh period in 0.1s
										EasySensors_sensorFailsafeConfig(i)= EasySensors[i].sensorFailsafeConfig;   // Failsafe configuration (bits 0-5: timeout in seconds, bit 6: invalid=0, bit 7: invalid=0x7FFFFFFF)
										EasySensors_sensorReadingID(i)= EasySensors[i].sensorReadingID;        // Sensor reading selection (see Protocol description document for details)
										usleep(sleepdur);
									}
								}
					*/


					if (info_protI2C != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_protI2C = %d \n", __FILE__, __FUNCTION__, info_protI2C);
						/* Pokeys Protokol Specification - page 65:  deprecated command, I2C bus is always activated

						uint8_t * i_activated;
						if (PK_I2SGetStatus(dev, i_activated) == PK_OK)
						{
							usleep(sleepdur);
						} */


						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_I2CBusScanStart\n", __FILE__, __FUNCTION__);
						if (PK_I2CBusScanStart(dev) == PK_OK)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_I2CBusScanStart - scan started\n", __FILE__, __FUNCTION__);
							I2C_isscanning = true;
							usleep(sleepdur);
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: I2C_isscanning = %d\n", __FILE__, __FUNCTION__, I2C_isscanning);
					}

					if (setPinConfig == true)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: setPinConfig = true\n", __FILE__, __FUNCTION__);
						if (PK_PinConfigurationSet(dev) == PK_OK)
						{
							usleep(sleepdur);
							setPinConfig = false;
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: setPinConfig -done\n", __FILE__, __FUNCTION__);
					}
					if (info_PoNET != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PoNET = %d\n", __FILE__, __FUNCTION__, info_PoNET);
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetPoNETStatus\n", __FILE__, __FUNCTION__);
						if (PK_PoNETGetPoNETStatus(dev) == PK_OK)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetPoNETStatus=OK\n", __FILE__, __FUNCTION__);
							for (i = 0; i < 16; i++)
							{

								dev->PoNETmodule.moduleID = i;
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleSettings( %d )\n", __FILE__, __FUNCTION__, i);
								if (PK_PoNETGetModuleSettings(dev) == PK_OK)
								{
									PoNet[i].moduleID = i;
									PoNet[i].i2cAddress = dev->PoNETmodule.i2cAddress;
									PoNet[i].moduleType = dev->PoNETmodule.moduleType;
									PoNet[i].moduleSize = dev->PoNETmodule.moduleSize;
									PoNet[i].moduleOptions = dev->PoNETmodule.moduleOptions;
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PoNet[%d].moduleID = %d\n", __FILE__, __FUNCTION__, i, PoNet[i].moduleID);
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PoNet[%d].i2cAddress = %d\n", __FILE__, __FUNCTION__, i, PoNet[i].i2cAddress);
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PoNet[%d].moduleType = %d\n", __FILE__, __FUNCTION__, i, PoNet[i].moduleType);
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PoNet[%d].moduleSize = %d\n", __FILE__, __FUNCTION__, i, PoNet[i].moduleSize);
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PoNet[%d].moduleOptions = %d\n", __FILE__, __FUNCTION__, i, PoNet[i].moduleOptions);
									usleep(sleepdur);
									//	memset(dev->PoNETmodule.statusOut, 0, 10);
								}
							}
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PoNet scan done\n", __FILE__, __FUNCTION__);
						usleep(sleepdur);
					}
					//dev->DeviceData.DeviceLockStatus=1;

					if (PEv2_params_ApplyIniSettings != 0 && info_PulseEnginev2 != 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SaveConfiguration - PEv2_params_ApplyIniSettings\n", __FILE__, __FUNCTION__);
						if (PK_SaveConfiguration(dev) != PK_OK)
						{
							usleep(sleepdur * 2);
							if (PK_SaveConfiguration(dev) != PK_OK)
							{
								usleep(sleepdur * 2);
							}
						}

					}
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Device info pins initialized\n", __FILE__, __FUNCTION__);
					initdone = 1;
				}

				usleep(sleepdur); 
			}
			alive=1; 
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: alive=1\n", __FILE__, __FUNCTION__);
			deb_out = 200;
			 // RTC
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_RTCGet(dev)\n", __FILE__, __FUNCTION__);
			if (PK_RTCGet(dev) == PK_OK)
			{
				deb_out = 210;
				rtc_sec=dev->RTC.SEC;
				rtc_min=dev->RTC.MIN;
				rtc_hour=dev->RTC.HOUR;
				rtc_dow=dev->RTC.DOW;
				rtc_dom=dev->RTC.DOM;
				rtc_tmp=dev->RTC.tmp;
				rtc_doy=dev->RTC.DOY;
				rtc_month=dev->RTC.MONTH;
				rtc_year=dev->RTC.YEAR;

				if (rtc_lastsec!=rtc_sec)
				{
					deb_out = 211;
					rtc_loop_frequ=rtc_loopcount;
					rtc_loopcount=0;
					rtc_lastsec=rtc_sec;

					if (secBlink)
					{
						secBlink = false;
					}
					else
					{
						secBlink = true;
					}

					//sleepdur
					if (rtc_loop_frequ>15)
					{
						if (rtc_loop_frequ_demand == 0)
						{
							sleepdur = sleepdur*rtc_loop_frequ/15;
						}
						else
						{
							sleepdur = sleepdur*rtc_loop_frequ/rtc_loop_frequ_demand;
						}
					}
					else
					{
						sleepdur=sleepdur/2;
					}
					if (sleepdur>1000000)
					{
						sleepdur=1000000;
					}
					if (sleepdur<50)
					{
						sleepdur=50;
					}

					if (rtc_latencycheck_set = -1)
					{
						rtc_latencyCounter=0;
						rtc_latencycheck_set=dev->RTC.SEC;
					}
				}
				// hope to get loopfrequency more stable - as on everyminute additional actions
				if (use_sleepdur1==false)
				{
					sleepdur2=sleepdur;
					sleepdur=sleepdur1;
					use_sleepdur1=true;
				}
				else
				{
					sleepdur1=sleepdur;
				}
				if (rtc_lastmin!=rtc_min)
				{ 
					use_sleepdur1=false;
					sleepdur1=sleepdur;
					sleepdur=sleepdur2;
				}

				if (rtc_sec_ret >= rtc_latencycheck_set && rtc_latencycheck_set>0 )
				{
					rtc_hal_latency = rtc_latencyCounter;
					rtc_latencycheck_set = -1;
				}
				else if (rtc_latencycheck_set >= -0)
				{
					rtc_latencyCounter ++;
				}
				deb_out = 212;
			}

			// PulseEnginev2
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PulseEnginev2 = %d\n", __FILE__, __FUNCTION__, info_PulseEnginev2);
			if (info_PulseEnginev2!=0)
			{
				uint8_t         bm_LimitStatusP;              // Limit+ status (bit-mapped)
				uint8_t         bm_LimitStatusN;              // Limit- status (bit-mapped)
				uint8_t         bm_HomeStatus;                // Home status (bit-mapped)
				uint8_t         bm_ErrorStatus;
				uint8_t         bm_ProbeStatus = dev->PEv2.ProbeStatus; //will be update in "PK_PEv2_ProbingFinish" or "PK_PEv2_ProbingFinishSimple"
				uint8_t			bm_DedicatedLimitNInputs;
				uint8_t			bm_DedicatedLimitPInputs;
				uint8_t			bm_DedicatedHomeInputs;

				if (bm_ProbeStatus != 0)
				{
					PEv2_digin_Probed_in = true;
				}
				else {
					PEv2_digin_Probed_in = false;
				}
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_StatusGet(dev)\n", __FILE__, __FUNCTION__);
				if(PK_PEv2_StatusGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_StatusGet(dev) = PK_OK\n", __FILE__, __FUNCTION__);
					// Engine info
					PEv2_nrOfAxes = dev->PEv2.info.nrOfAxes;
					PEv2_maxPulseFrequency = dev->PEv2.info.maxPulseFrequency;
					PEv2_bufferDepth = dev->PEv2.info.bufferDepth;
					PEv2_slotTiming = dev->PEv2.info.slotTiming;
					
					PEv2_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
					PEv2_LimitOverride = dev->PEv2.LimitOverride;
					
					// Basic engine states
					PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
					PEv2_PulseEngineActivated = dev->PEv2.PulseEngineActivated;
					
					PulseEngineState = dev->PEv2.PulseEngineState;
					PEv2_PulseEngineState = PulseEngineState;
					PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
					PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;

					// Switch states
					bm_LimitStatusP = dev->PEv2.LimitStatusP;              // Limit+ status (bit-mapped)
					bm_LimitStatusN = dev->PEv2.LimitStatusN;              // Limit- status (bit-mapped)
					bm_HomeStatus = dev->PEv2.HomeStatus;                // Home status (bit-mapped)
					if (PEv2_params_ApplyIniSettings == false) 
					{
						PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
					}
					

					// Other inputs
					bm_ErrorStatus = dev->PEv2.ErrorInputStatus;
					PEv2_MiscInputStatus = dev->PEv2.MiscInputStatus;

					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: HAL_Machine_On = %s\n", __FILE__, __FUNCTION__, HAL_Machine_On);
					if(HAL_Machine_On!=0)
					{
					/*
						PK_PEState_peSTOPPED        = 0,           // Pulse engine is stopped
						PK_PEState_peINTERNAL       = 1,           // PEv1: Internal motion controller is in use, PEv2: not used
						PK_PEState_peBUFFER         = 2,           // PEv1: Buffered operation mode is in use, PEv2: not used
						PK_PEState_peRUNNING        = 3,           // Pulse engine is activated

						PK_PEState_peJOGGING        = 10,          // Jogging mode enabled
						PK_PEState_peSTOPPING       = 11,          // Pulse engine is stopping

						PK_PEState_peHOME           = 20,          // All axes are homed
						PK_PEState_peHOMING         = 21,          // Axes homing is in progress

						PK_PEState_pePROBECOMPLETE  = 30,          // All axes are homed
						PK_PEState_pePROBE          = 31,          // Axes probing is in progress
						PK_PEState_pePROBEERROR     = 32,          // Error occured during probing

						PK_PEState_peHYBRIDPROBE_STOPPING = 40,
						PK_PEState_peHYBRIDPROBE_COMPLETE = 41,

						PK_PEState_peSTOP_LIMIT     = 100,         // Pulse engine stopped due to limit reached
						PK_PEState_peSTOP_EMERGENCY = 101          // Pulse engine stopped due to emergency switch
					*/
						PEv2_PulseEngineStateSetup = PK_PEState_peRUNNING;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_PulseEngineStateSetup = PK_PEState_peRUNNING\n", __FILE__, __FUNCTION__);
					}
					else
					{
						PEv2_PulseEngineStateSetup = PK_PEState_peSTOPPED;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_PulseEngineStateSetup = PK_PEState_peSTOPPED\n", __FILE__, __FUNCTION__);
					}
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PulseEngineState = %s\n", __FILE__, __FUNCTION__, PulseEngineState);
					switch (PulseEngineState)
					{
						case PK_PEState_peSTOPPED:           // Pulse engine is stopped
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOPPED\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peINTERNAL:           // PEv1: Internal motion controller is in use, PEv2: not used
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peINTERNAL\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peBUFFER:           // PEv1: Buffered operation mode is in use, PEv2: not used
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peBUFFER\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peRUNNING:           // Pulse engine is activated
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peRUNNING\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peJOGGING:          // Jogging mode enabled
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peJOGGING\n", __FILE__, __FUNCTION__);

							break;
						case PK_PEState_peSTOPPING:          // Pulse engine is stopping
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOPPING\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peHOME:          // All axes are homed
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHOME\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peHOMING:          // Axes homing is in progress
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHOMING\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_pePROBECOMPLETE:          // All axes are homed
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_pePROBECOMPLETE\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_pePROBE:          // Axes probing is in progress
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_pePROBE\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_pePROBEERROR:          // Error occured during probing
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_pePROBEERROR\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peHYBRIDPROBE_STOPPING:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHYBRIDPROBE_STOPPING\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peHYBRIDPROBE_COMPLETE:
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peHYBRIDPROBE_COMPLETE\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peSTOP_LIMIT:         // Pulse engine stopped due to limit reached
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOP_LIMIT\n", __FILE__, __FUNCTION__);
							break;
						case PK_PEState_peSTOP_EMERGENCY:          // Pulse engine stopped due to emergency switch
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEState_peSTOP_EMERGENCY\n", __FILE__, __FUNCTION__);
							PEv2_digin_Emergency_in = true;
							PEv2_digin_Emergency_in_not = false;
							PEv2_deb_estop = 10;
							break;
					}
					usleep(sleepdur); 
				}
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_Status2Get(dev)\n", __FILE__, __FUNCTION__);
				if(PK_PEv2_Status2Get(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEv2_Status2Get(dev) = PK_OK\n", __FILE__, __FUNCTION__);
					bm_DedicatedLimitNInputs = dev->PEv2.DedicatedLimitNInputs;
					bm_DedicatedLimitPInputs = dev->PEv2.DedicatedLimitPInputs;
					bm_DedicatedHomeInputs = dev->PEv2.DedicatedHomeInputs;
					usleep(sleepdur); 
				}

				bool doPositionSet = false;
				bool doMove = false;
				bool isMoving = false;
				bool doStateSet = false;
				bool doHomingStart = false;
				int HomingStartMaskSetup = 0;
				bool IsHoming[8];
				bool InPosition[8];
				bool POSITION_MODE_active[8];
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PEv2_nrOfAxes = %d\n", __FILE__, __FUNCTION__, PEv2_nrOfAxes);
				if (PEv2_nrOfAxes!=0)
				{
					uint8_t  bm_SoftLimitStatus = dev->PEv2.SoftLimitStatus;
					int tAxisEnabledMask = 0;
					
					int32_t intCurrentPosition[8];
					float PosFb[8];
					for (i = 0; i < PEv2_nrOfAxes; i++)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_Axis[%d] \n", __FILE__, __FUNCTION__, i);
						IsHoming[i] = false;
						InPosition[i] = false;

						uint8_t intAxesState = dev->PEv2.AxesState[i];
						PEv2_AxesState(i) = intAxesState;
						PEv2_deb_axxisout(i) = 200 + i;
						StepScale[i] = PEv2_stepgen_STEP_SCALE(i);
						PEv2_deb_axxisout(i) = 210 + i;
						// PEv2_CurrentPosition(i) = dev->PEv2.CurrentPosition[i];
						intCurrentPosition[i] = dev->PEv2.CurrentPosition[i];
						PEv2_deb_axxisout(i) = 220 + i;
						// calculate actual velocity by position difference (time estimated by actual rtc_loop_frequ [Hz] / [1/sec] )
						if (StepScale[i]!=0)
						{
							PEv2_deb_axxisout(i) = 230 + i;
							PosFb[i] = intCurrentPosition[i] / StepScale[i];
						}
						else
						{
							PEv2_deb_axxisout(i) = 240 + i;
							PosFb[i] = intCurrentPosition[i];
						}
						PEv2_deb_axxisout(i) = 250 + i;
						PEv2_joint_pos_fb(i) = PosFb[i];
						PEv2_deb_axxisout(i) = 260 + i;
						PEv2_CurrentPosition(i) = intCurrentPosition[i];
						PEv2_deb_axxisout(i) = 270 + i;
						
						PEv2_digin_Probe_in(i) = Get_BitOfByte(bm_ProbeStatus, i);

						PEv2_digin_LimitP_in(i) = Get_BitOfByte(bm_LimitStatusP,i);
						PEv2_digin_LimitP_in_not(i) = !Get_BitOfByte(bm_LimitStatusP, i);

						PEv2_digin_LimitN_in(i) = Get_BitOfByte(bm_LimitStatusN,i);
						PEv2_digin_LimitN_in_not(i) = !Get_BitOfByte(bm_LimitStatusN, i);

						PEv2_digin_Home_in(i) =  Get_BitOfByte(bm_HomeStatus,i);
						PEv2_digin_Home_in_not(i) = !Get_BitOfByte(bm_HomeStatus, i);

						PEv2_deb_axxisout(i) = 280 ;
						PEv2_digin_LimitN_DedicatedInput(i) =  Get_BitOfByte(bm_DedicatedLimitNInputs,i);
						PEv2_digin_LimitP_DedicatedInput(i) =  Get_BitOfByte(bm_DedicatedLimitPInputs,i);
						PEv2_digin_Home_DedicatedInput(i) =  Get_BitOfByte(bm_DedicatedHomeInputs,i);

						
						PEv2_digin_SoftLimit_in(i) = Get_BitOfByte(bm_SoftLimitStatus,i);
						PEv2_deb_axxisout(i) = 290 + i;
						
						/*
						PEv2.#.digin.Error.in[8]

						bm_ErrorStatus
						*/

						PEv2_digin_Error_in(i) = Get_BitOfByte(bm_ErrorStatus, i);
						PEv2_digin_Error_in_not(i) = !Get_BitOfByte(bm_ErrorStatus, i);
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: intAxesState = %s\n", __FILE__, __FUNCTION__, intAxesState);
						switch(intAxesState)
						{
							case PK_PEAxisState_axSTOPPED:        // Axis is stopped
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEAxisState_axSTOPPED\n", __FILE__, __FUNCTION__);
								IsHoming[i] = false;
								PEv2_deb_out = 310 + i;
								//PEv2_digin_AxisEnabled_in(i) = false;
								//PEv2_digin_LimitOverride_in(i) = false;

		
								break ;
							case PK_PEAxisState_axREADY:        // Axis ready
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEAxisState_axREADY\n", __FILE__, __FUNCTION__);
								IsHoming[i] = false;
								PEv2_deb_out = 320 + i;
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = false;
	
								break ;
							case PK_PEAxisState_axRUNNING:        // Axis is running
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PEAxisState_axRUNNING\n", __FILE__, __FUNCTION__);
								IsHoming[i] = false;
								PEv2_deb_out = 330 + i;
								break ;
							case PK_PEAxisState_axHOMING_RESETTING:   // Stopping the axis to reset the position counters
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMING_RESETTING\n", __FILE__, __FUNCTION__);
								//PEv2_digin_LimitOverride_in(i) = true;
								//PEv2_digin_AxisEnabled_in(i) = true;
								IsHoming[i] = true;
								PEv2_deb_out = 340 + i;
								break ;
							case PK_PEAxisState_axHOMING_BACKING_OFF:   // Backing off switch
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMING_BACKING_OFF\n", __FILE__, __FUNCTION__);
								IsHoming[i] = true;
								PEv2_deb_out = 340 + i;
								
								//PEv2_digin_LimitOverride_in(i) = true;
								//PEv2_digin_AxisEnabled_in(i) = true;
								break ;
							case PK_PEAxisState_axHOME:       // Axis is homed
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOME\n", __FILE__, __FUNCTION__);
								PEv2_deb_out = 340 + i;
								IsHoming[i] = false;
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = true;
							// PEv2_joint_
								break ;
							case PK_PEAxisState_axHOMINGSTART:       // Homing procedure is starting on axis
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMINGSTART\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = true;
								IsHoming[i] = true;
								PEv2_deb_out = 340 + i;
								break ;
							case PK_PEAxisState_axHOMINGSEARCH:       // Homing procedure first step - going to home
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMINGSEARCH\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = true;
								IsHoming[i] = true;
								PEv2_deb_out = 340 + i;
								break ;
							case PK_PEAxisState_axHOMINGBACK:       // Homing procedure second step - slow homing
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axHOMINGBACK\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = true;
								IsHoming[i] = true;
								PEv2_deb_out = 340 + i;
								break ;
							case PK_PEAxisState_axPROBED:       // Probing completed for this axis
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axPROBED\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = false;
								IsHoming[i] = false;
								PEv2_deb_out = 350 + i;
								break ;
							case PK_PEAxisState_axPROBESTART:       // Probing procedure is starting on axis
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axPROBESTART\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = false;
								IsHoming[i] = false;
								PEv2_deb_out = 350 + i;
								break ;
							case PK_PEAxisState_axPROBESEARCH:       // Probing procedure - probing
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axPROBESEARCH\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = false;
								IsHoming[i] = false;
								PEv2_deb_out = 350 + i;
								break ;
							case PK_PEAxisState_axERROR:       // Axis error
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axERROR\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = false;
								//PEv2_digin_LimitOverride_in(i) = false;
								IsHoming[i] = false;
								PEv2_deb_out = 360 + i;

								break ;
							case PK_PEAxisState_axLIMIT:        // Axis limit tripped
								rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PK_PEAxisState_axLIMIT\n", __FILE__, __FUNCTION__);
								//PEv2_digin_AxisEnabled_in(i) = true;
								//PEv2_digin_LimitOverride_in(i) = false;
								IsHoming[i] = false;
								PEv2_deb_out = 370 + i;
								break ;
							default:

								PEv2_deb_out = 380 + i;
								break ;
						}
						

						if (PEv2_AxesCommand(i)==PK_PEAxisState_axHOMINGSTART && IsHoming[i] == false)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Trigger HomingStart\n", __FILE__, __FUNCTION__);
							dev->PEv2.PulseEngineStateSetup = PK_PEAxisState_axHOMINGSTART;

							int MyHomeSequ, seq;
							MyHomeSequ = PEv2_home_sequence(i);

							//ensure that all axes with same Sequence start homing at the same time
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: ensure that all axes with same Sequence start homing at the same time\n", __FILE__, __FUNCTION__);
							for (seq = 0; seq < PEv2_nrOfAxes; seq++)
							{
								if (PEv2_home_sequence(i) == MyHomeSequ)
								{
									HomingStartMaskSetup = (1 << seq); // Home axis 1 only (bit 0)
									doHomingStart = true;
								}

							}
						}

						tAxisEnabledMask = Set_BitOfByte(tAxisEnabledMask,i,PEv2_digout_AxisEnabled_out(i));
						PEv2_LimitOverrideSetup = Set_BitOfByte(PEv2_LimitOverrideSetup ,i,PEv2_digout_LimitOverride_out(i));
						PEv2_deb_axxisout(i) = 2900 + i;
						POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
						PEv2_deb_axxisout(i) = 29000 + i;
						/*PEv2.#.joint-in-homing*/
						

						 //PEv2.#.joint-in-position
						
						if (PEv2_joint_in_position(i)!=0) {
							InPosition[i] = true;
						}
						else
						{
							InPosition[i] = false;
						}
						PEv2_deb_ishoming(i) = IsHoming[i];
						PEv2_deb_inposition(i) = InPosition[i];

						if (HAL_Machine_On==true)
						{
							PEv2_deb_out = 390 + i;
							posMode[i] = false;
							if (IsHoming[i]==false)
							{
								float VelCmd = PEv2_joint_vel_cmd(i);
								float PosCmd = PEv2_joint_pos_cmd(i);
								
								PEv2_deb_out = 400 + i;

			
								float ReferenceSpeed;
								float ReferencePosition;
								PEv2_deb_axxisout(i) = 1000;

								if (StepScale[i]!=0)
								{
									PEv2_deb_axxisout(i) = 1100 + i;
									ReferenceSpeed = VelCmd * StepScale[i];
									PEv2_deb_axxisout(i) = 1110 + i;
									ReferencePosition = PosCmd * StepScale[i];
									PEv2_deb_axxisout(i) = 1120 + i;

								}
								else
								{
									PEv2_deb_axxisout(i) = 1200 + i;
									ReferenceSpeed = VelCmd;
									PEv2_deb_axxisout(i) = 1210 + i;
									ReferencePosition = PosCmd;
									PEv2_deb_axxisout(i) = 1220 + i;

								}


								/*
								for the last short move before in-position is reached switch to positionmode for more precise positioning
								*/
								if ((InPosition[i] == true) && (dev->PEv2.CurrentPosition[i] != (int32_t)ReferencePosition)) {
									InPosition[i] = false;
								}
								if (InPosition[i]=false)
								{
									dev->PEv2.param1 = i;
									PK_PEv2_AxisConfigurationGet(dev);
									POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);

									dev->PEv2.param1 = i;
									PK_PEv2_AxisConfigurationGet(dev);
									POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
									
									
									if ((ReferenceSpeed = 0))
									{
										posMode[i] = true;

										dev->PEv2.param1 = i;
										PK_PEv2_AxisConfigurationGet(dev);
										POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);

										if ((POSITION_MODE_active[i] == false) )
										{
											posCount[i]++;
											// first ensure stopped Axis
											if (dev->PEv2.ReferencePositionSpeed[i] != 0)
											{
												dev->PEv2.ReferencePositionSpeed[i] = 0;
												PK_PEv2_PulseEngineMove(dev);
											}

											//then switch to Position Mode
											dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, true);
											dev->PEv2.param1 = i;

											if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK) {
												PK_PEv2_AxisConfigurationSet(dev);
											}
											
											
										}
										else 
										{
											posCount[i]+=1000;
										}
									}
									else
									{
										posCount[i] += 100000;
									}
								}
								else
								{
									//posMode[i] = false;
									dev->PEv2.param1 = i;
									PK_PEv2_AxisConfigurationGet(dev);
									POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
									
									if (POSITION_MODE_active[i]==true)
									{
										velCount[i]++;
										dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
										dev->PEv2.param1 = i;
										if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK) {
											PK_PEv2_AxisConfigurationSet(dev);
										}

										
										posMode[i] = false;

									}

								}

								dev->PEv2.param1 = i;
								PK_PEv2_AxisConfigurationGet(dev);
								POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
								dev->PEv2.param1 = i;
								PK_PEv2_AxisConfigurationGet(dev);
								POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
								PEv2_deb_posmode_count(i) = posCount[i];
								PEv2_deb_velmode_count(i) = velCount[i];
								PEv2_deb_axxisout(i) = 1300 + i;
								PEv2_deb_RefSpeed(i) = ReferenceSpeed;
								PEv2_deb_RefPos(i) = ReferencePosition;
								PEv2_deb_PosMode(i) = posMode[i];
								PEv2_deb_PosModeAct(i) = POSITION_MODE_active[i];

								if (POSITION_MODE_active[i]==true) 
								{
									PEv2_deb_axxisout(i) = 13100 + i;
									if (InPosition[i]==false)
									{
										if (last_joint_pos_cmd[i]!=PEv2_joint_pos_cmd(i))
										{
											PEv2_deb_axxisout(i) = 1310 + i;
											dev->PEv2.ReferencePositionSpeed[i] = (int32_t)ReferencePosition;
											PEv2_ReferencePositionSpeed(i) = (int)ReferencePosition;
											PEv2_deb_axxisout(i) = 1320 + i;
											last_joint_pos_cmd[i]=PEv2_joint_pos_cmd(i);
											if (dev->PEv2.AxesState[i]=PK_PEState_peRUNNING)
											{
												//PK_PEv2_PulseEngineMove(dev);
												doMove = true;
												PEv2_deb_axxisout(i) = 1330 + i;
											}
											else
											{
												PEv2_deb_axxisout(i) = 1340 + i;
											}
										}
									}
									else
									{

										PEv2_deb_axxisout(i) = 1600 + i;
										if (dev->PEv2.ReferencePositionSpeed[i]!=dev->PEv2.CurrentPosition[i]) 
										{
											PEv2_deb_axxisout(i) = 160 + i;
											dev->PEv2.AxesConfig[i]=Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
											dev->PEv2.param1 = i;
											PK_PEv2_AxisConfigurationSet(dev);

											dev->PEv2.ReferencePositionSpeed[i] = 0;
											PEv2_ReferencePositionSpeed(i) = 0;
											last_joint_vel_cmd[i] = 0;
											doMove = true;
											//PEv2_joint_pos_fb(i) = PEv2_joint_pos_cmd(i);
										}

										POSITION_MODE_active[i] = Get_BitOfByte(dev->PEv2.AxesConfig[i], 3);
										if (POSITION_MODE_active[i]=true)
										{
											dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
											dev->PEv2.param1 = i;
											PK_PEv2_AxisConfigurationSet(dev);
											PK_PEv2_AxisConfigurationSet(dev);

											//if (PK_PEv2_AxisConfigurationSet(dev) = PK_OK) 
											//{
												dev->PEv2.ReferencePositionSpeed[i] = 0;
												PEv2_ReferencePositionSpeed(i) = 0;
												last_joint_vel_cmd[i] = 0;
												doMove = true;
											//}
											/*else
											{
												dev->PEv2.AxesConfig[i] = Set_BitOfByte(dev->PEv2.AxesConfig[i], 3, false);
												dev->PEv2.param1 = i;
												PK_PEv2_AxisConfigurationSet(dev);
												dev->PEv2.ReferencePositionSpeed[i] = 0;
												PEv2_ReferencePositionSpeed(i) = 0;
												last_joint_vel_cmd[i] = 0;
												doMove = true;
											}*/
										}

									}

								}
								else
								{
									if (InPosition[i]!=true)
									{
										PEv2_deb_axxisout(i) = 14100 + i;
										if (last_joint_vel_cmd[i]!=PEv2_joint_vel_cmd(i))
										{
											PEv2_deb_axxisout(i) = 1410 + i;

											
											dev->PEv2.ReferencePositionSpeed[i] = (int32_t)ReferenceSpeed;
											PEv2_ReferencePositionSpeed(i) = (int)ReferenceSpeed;
											PEv2_deb_axxisout(i) = 1420 + i;
											last_joint_vel_cmd[i]=PEv2_joint_vel_cmd(i);
											if (dev->PEv2.AxesState[i] = PK_PEState_peRUNNING)
											{

													doMove = true;
													PEv2_deb_axxisout(i) = 1430 + i;
											}
											else
											{
												PEv2_deb_axxisout(i) = 1440 + i;
											}



										}
										else
										{
											PEv2_deb_axxisout(i) = 1450 + i;
										}
									}
									else
									{
										PEv2_deb_axxisout(i) = 1700 + i;
										//InPosition -> StopAxis
										if (dev->PEv2.ReferencePositionSpeed[i] != 0)
										{
											dev->PEv2.ReferencePositionSpeed[i] = 0;
											PEv2_ReferencePositionSpeed(i) = 0;
											last_joint_vel_cmd[i] = 0;
											doMove = true;
											//PEv2_joint_pos_fb(i) = PEv2_joint_pos_cmd(i);
										}
										
									}
								}

							}
							else
							{
								PEv2_deb_axxisout(i) = 2400 + i;
								//dev->PEv2.ReferencePositionSpeed[i]=0;
								switch (intAxesState)
								{
								case PK_PEAxisState_axHOMING_RESETTING:   // Stopping the axis to reset the position counters
									//PEv2_AxisLimitOverride(i) = true;
									//PEv2_digin_AxisEnabled_in(i) = true;
									break;
								case PK_PEAxisState_axHOMING_BACKING_OFF:   // Backing off switch
									//PEv2_AxisLimitOverride(i) = true;
									//PEv2_digin_AxisEnabled_in(i) = true;
									break;
								case PK_PEAxisState_axHOME:       // Axis is homed
									//PEv2_digin_AxisEnabled_in(i) = true;
									//PEv2_AxisLimitOverride(i) = true;
									// PEv2_joint_
									break;
								case PK_PEAxisState_axHOMINGSTART:       // Homing procedure is starting on axis
									//PEv2_digin_AxisEnabled_in(i) = true;
									//PEv2_AxisLimitOverride(i) = true;
									break;
								case PK_PEAxisState_axHOMINGSEARCH:       // Homing procedure first step - going to home
									//PEv2_digin_AxisEnabled_in(i) = true;
									//PEv2_AxisLimitOverride(i) = true;
									break;
								case PK_PEAxisState_axHOMINGBACK:       // Homing procedure second step - slow homing
									//PEv2_digin_AxisEnabled_in(i) = true;
									//PEv2_AxisLimitOverride(i) = true;
									break;

								default:
									//dev->PEv2.PulseEngineStateSetup = PK_PEAxisState_axHOMINGSTART;

									
									break;
								}
								PEv2_deb_axxisout(i) = 2410 + i;
							}

						}
						else
						{
							PEv2_deb_out = 3900 + i;
						}
					
						PEv2_deb_doMove(i) = doMove;
						PEv2_deb_RefPosSpeed(i) = dev->PEv2.ReferencePositionSpeed[i];
					}

					/*
					move is done later anyway					
					if (doMove = true)
					{

						PK_PEv2_PulseEngineMove(dev);
						PK_PEv2_PulseEngineMove(dev);
						PEv2_deb_out = 4100;
					}*/


					if (tAxisEnabledMask != dev->PEv2.AxisEnabledMask)
					{
						dev->PEv2.AxisEnabledMask = tAxisEnabledMask;
						doStateSet=true;
					}
					if (PEv2_LimitOverrideSetup != dev->PEv2.LimitOverrideSetup)
					{
						dev->PEv2.LimitOverrideSetup = PEv2_LimitOverrideSetup;
						doStateSet=true;
					}
				}


				if(PK_PEv2_ExternalOutputsGet(dev) == PK_OK)
				{
					PEv2_ExternalRelayOutputs= dev->PEv2.ExternalRelayOutputs;
					PEv2_ExternalOCOutputs= dev->PEv2.ExternalOCOutputs ;
				}
						

				if (PEv2_PG_extended_io != false)
				{
					/*
					pin out bit PEv2.ExternalRelayOutput.#[4];			// External relay outputs
					pin out bit PEv2.ExternalOCOutput.#[4];			// External open-collector outputs
					*/

					uint8_t ExternalRelayOutputs_set=  0;
					uint8_t ExternalOCOutputs_set=  0;


					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,7, PEv2_digout_ExternalRelay_out(0));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,0, PEv2_digout_ExternalRelay_out(1));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,2, PEv2_digout_ExternalRelay_out(2));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,1, PEv2_digout_ExternalRelay_out(3));

					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,3,PEv2_digout_ExternalOC_out(0));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,4,PEv2_digout_ExternalOC_out(1));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,5,PEv2_digout_ExternalOC_out(2));
					ExternalOCOutputs_set = Set_BitOfByte(ExternalOCOutputs_set ,6,PEv2_digout_ExternalOC_out(3));


					if (ExternalOCOutputs_set != dev->PEv2.ExternalOCOutputs)
					{
						dev->PEv2.ExternalOCOutputs = ExternalOCOutputs_set;
							PK_PEv2_ExternalOutputsSet(dev);
							PK_PEv2_ExternalOutputsSet(dev);
					}

					
				}
				if (PulseEngineState != PEv2_PulseEngineStateSetup )
				{
					dev->PEv2.PulseEngineStateSetup = PEv2_PulseEngineStateSetup;
					//dev->PEv2.AxisEnabledMask = PEv2_AxisEnabledMask;
					doStateSet=true;
				}
				else if (rtc_loopcount==0)
				{
					dev->PEv2.PulseEngineStateSetup = PEv2_PulseEngineStateSetup;
					//dev->PEv2.AxisEnabledMask = PEv2_AxisEnabledMask;
					doStateSet=true;
				}

				if (PEv2_LimitOverrideSetup != dev->PEv2.LimitOverrideSetup)
				{
					dev->PEv2.LimitOverrideSetup = PEv2_LimitOverrideSetup;
					doStateSet=true;
				}

				if (doStateSet == true)
				{
					if (PK_PEv2_PulseEngineStateSet(dev) != PK_OK)
					{
						usleep(sleepdur);
						if (PK_PEv2_PulseEngineStateSet(dev) != PK_OK)
						{
							usleep(sleepdur);
						}
					}
				}

				if (doMove==true)
					{
						PEv2_deb_out = 4000;
						if (PK_PEv2_PulseEngineMove(dev)!=PK_OK)
						{
							PEv2_deb_out = 4200;
							usleep(sleepdur);
							if (PK_PEv2_PulseEngineMove(dev)!=PK_OK)
							{
								usleep(sleepdur);
							}
						}
						else {
							PEv2_deb_out = 4500;
						}
					}
				if (doHomingStart==true)
					{
						PEv2_deb_out = 5000;
						if (dev->PEv2.HomingStartMaskSetup != HomingStartMaskSetup) {
							PEv2_deb_out = 5100;
							dev->PEv2.HomingStartMaskSetup = HomingStartMaskSetup;
						}
						//PK_PEv2_HomingStart(dev);

						if (PK_PEv2_HomingStart(dev) != PK_OK)
						{
							PEv2_deb_out = 5200;
							usleep(sleepdur);
							if (PK_PEv2_HomingStart(dev) != PK_OK)
							{
								usleep(sleepdur);
							}
						}
					}
			



				deb_out = 224;
			}
			
			bool PinConfigurationGet = false;
			bool DigitalIOGet = false;
			bool AnalogIOGet = false;
			bool AnalogIOSet = false;
			bool DigitalCounterGet = false;
			bool DigitalIOSet = false;
			bool EncoderValuesGet = false; 
			bool loopPins = false;
			bool doPwmConfig = false;
			/* 
			info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
			 info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
			 info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
			 info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
			 info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
			 info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
			 info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
			 info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of info_protI2Cavailable analog inputs
			 info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
			 info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
			 info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
			 info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters			*/
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PinCount = %d\n", __FILE__, __FUNCTION__, dev->info.iPinCount);
			if (dev->info.iPinCount > 0)
			{
				deb_out = 210;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PinConfigurationGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PinConfigurationGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PinConfigurationGet(dev) OK\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					PinConfigurationGet = true;
					deb_out = 211;
					loopPins = true;
				}
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_DigitalIOGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOGet(dev) OK\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					deb_out = 212;
					DigitalIOGet = true;
					loopPins = true;
				}
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_AnalogIOGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_AnalogIOGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_AnalogIOGet(dev) OK\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					deb_out = 213;
					AnalogIOGet = true;
					loopPins = true;
				}
			}
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_iDigitalCounters = %d\n", __FILE__, __FUNCTION__, dev->info.iDigitalCounters);
			if (dev->info.iDigitalCounters > 0)
			{
				deb_out = 214;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalCounterGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_DigitalCounterGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalCounterGet(dev) OK\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					deb_out = 215;
					DigitalCounterGet = true;
					loopPins = true;
				}
			}
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_iBasicEncoderCount = %d\n", __FILE__, __FUNCTION__, dev->info.iBasicEncoderCount);
			if (dev->info.iBasicEncoderCount && DoEncoders)
			{
				deb_out = 216;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EncoderValuesGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_EncoderValuesGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EncoderValuesGet(dev) OK\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					deb_out = 217;
					EncoderValuesGet = true;
					bool resetEncoders = false;

					resetEncoders = 0;
					
					/* known issue: since update to Bullseye & Lcnc 2.9 it hangs here*/
					for (i = 0; i < dev->info.iBasicEncoderCount; i++)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: read encoder %d\n", __FILE__, __FUNCTION__, i);
						deb_out = 218*100+i;
						encoder_count(i) = dev->Encoders[i].encoderValue;
						deb_out = 2180;
						encoder_position(i) = dev->Encoders[i].encoderValue * encoder_scale(i);
						deb_out = 2181;
						if ((encoder_reset(i) != 0) || (initEncodersDone == false))
						{
							deb_out = 2182;
							dev->Encoders[i].encoderValue = 0;
							deb_out = 2183;
							resetEncoders = true;
							deb_out = 2184;
						}
						deb_out = 2185;
						usleep(sleepdur);
					}
					
					/*
					known issue: since update to Bullseye & Lcnc 2.9 it hangs here*/
					deb_out = 219;
					if (dev->info.iUltraFastEncoders)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: read UltraFastEncoders\n", __FILE__, __FUNCTION__);
						usleep(sleepdur);
						deb_out = 220;
						
						for (i = dev->info.iBasicEncoderCount; i < (dev->info.iBasicEncoderCount + dev->info.iUltraFastEncoders); i++)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: UltraFastEncoders %d\n", __FILE__, __FUNCTION__, i);
							deb_out = 221;
							encoder_count(i) = dev->Encoders[i].encoderValue;
							encoder_position(i) = dev->Encoders[i].encoderValue * encoder_scale(i);
							if ((encoder_reset(i) != 0) || (initEncodersDone == false))
							{
								dev->Encoders[i].encoderValue = 0;
								resetEncoders = true;
							}
							usleep(sleepdur);
						}
					}
					/*
					if (dev->info.iFastEncoders)
					{
						for (i = dev->info.iBasicEncoderCount+ dev->info.iUltraFastEncoders; i < (dev->info.iBasicEncoderCount + dev->info.iUltraFastEncoders + dev->info.iFastEncoders ); i++)
						{
							encoder_count(i) = dev->Encoders[i].encoderValue;
						}
					}*/
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: resetEncoders = %d\n", __FILE__, __FUNCTION__, resetEncoders);
					if (resetEncoders == true)
					{
						deb_out = 140;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EncoderValuesSet(dev)\n", __FILE__, __FUNCTION__);
						if (PK_EncoderValuesSet(dev) == PK_OK)
						{
							rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_EncoderValuesSet(dev) OK\n", __FILE__, __FUNCTION__);
							usleep(sleepdur);
							resetEncoders = false;
							deb_out = 141;
							initEncodersDone = true;
						}
						deb_out = 142;
					}
					
				}
			}
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PWMCount = %d\n", __FILE__, __FUNCTION__, dev->info.iPWMCount);
			if (dev->info.iPWMCount && DoPWM)
			{
				adcout_deb_outv = 100;
				uint32_t  PWMperiod;                       // PWM period, shared among all channels

				uint32_t PWMduty[6];                         // PWM duty cycles (range between 0 and PWM period)
				uint8_t PWMenabledChannels[6];              // List of enabled PWM channels
				uint8_t PWMpinIDs[6];
				float PWM_SCale[6];
				float max_v[6];
				float high_limit[6];
				float low_limit[6];
				float PWM_value[6];
				float PWM_OffSet[6];
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PWMConfigurationGet(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PWMConfigurationGet(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PWMConfigurationGet(dev) OK\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					PWMperiod = adcout_pwm_period;
					
					if (PWMperiod=0)
					{
						PWMperiod = 2500;
					}
					PWMperiod = 2500;
					if (dev->PWM.PWMperiod!=  PWMperiod)
					{
						dev->PWM.PWMperiod= PWMperiod;
						doPwmConfig = true;
						PK_PWMConfigurationSet(dev);
						usleep(sleepdur);
					}

					if (adcout_pwm_period != PWMperiod)
					{
						adcout_pwm_period = PWMperiod;
					}


					//Pins_PinFunction(i)=dev->Pins[i].PinFunction;

					for (i = 0; i < 6; i++)
					{
						int PwmId = 5 - i;
						adcout_deb_out(PwmId) = 100;

						PWMduty[i]= dev->PWM.PWMduty[i];                         // PWM duty cycles (range between 0 and PWM period)
						PWMenabledChannels[i]= adcout_enable(PwmId) ;              // List of enabled PWM channels
						PWMpinIDs[i]= dev->PWM.PWMpinIDs[i];
						adcout_PinId(PwmId) = PWMpinIDs[i];
						PWM_SCale[i] = 1;

						PWM_value[i] = adcout_value(PwmId);
						PWM_OffSet[i] = adcout_offset(PwmId);
						max_v[i] = adcout_max_v(PwmId);
						high_limit[i] = adcout_high_limit(PwmId);
						low_limit[i] = adcout_low_limit(PwmId);


						if (max_v[PwmId] == 0) 
						{
							if ((PEv2_PG_extended_io == true) && (PWMpinIDs[i] = 17))
							{
								max_v[PwmId] = 10.000; // Pin17 0-10V
							}
							else
							{
								max_v[PwmId] = 5.000; // usually pokeys57 provide 0..5V PWM
							}
						}

						if (high_limit[PwmId] = low_limit[PwmId])
						{
							if (high_limit[PwmId] == 0) {
								high_limit[PwmId] = max_v[PwmId];
							}
						}

						if (PWMenabledChannels[i] == true)
						{
							float tmp = PWM_value[i] + PWM_OffSet[i];

							if (tmp <= low_limit[i])
							{
								tmp = low_limit[i];
							}
							else if (tmp >= high_limit[i])
							{
								tmp = high_limit[i];
							}

							tmp = tmp * PWM_SCale[i];

							PWMduty[i] = (uint32_t)((tmp / max_v[i]) * PWMperiod);

						}
						else
						{
							PWMduty[i] = 0;
						}

						adcout_deb_setval(PwmId) = PWMduty[i];
						usleep(sleepdur);

						/*if ((max_v[PwmId] > 0.000) && (high_limit[PwmId] > 0.000) && (high_limit[PwmId] > low_limit[PwmId]))
						{
							adcout_deb_out(PwmId) = 110;
							if (dev->PWM.PWMenabledChannels[i] = 0)
							{
								adcout_deb_out(PwmId) = 111;
								dev->PWM.PWMenabledChannels[i] = 1;
								doPwmConfig = true;
							}
							else {
								adcout_deb_out(PwmId) = 112;
							}
							if (PWM_SCale[i] = 0.000)
							{
								adcout_deb_out(PwmId) = 200;
								if ((high_limit[PwmId] = 0.000) && (low_limit[PwmId] = 0.000))
								{
									adcout_deb_out(PwmId) = 2050;
									PWM_SCale[i] = 1;
									high_limit[PwmId] = max_v[PwmId];
									low_limit[PwmId] = 0.000;
								}
								else if ((low_limit[PwmId] = 0.000)&&(high_limit[PwmId] != 0.000)&&(max_v[PwmId] != 0.000))
								{
									adcout_offset(PwmId) = 0;
									PWM_SCale[i] = high_limit[PwmId] / max_v[PwmId];
									adcout_deb_out(PwmId) = 205;
								}
								else if( (high_limit[PwmId] != 0.000) && (max_v[PwmId] != 0.000))
								{
									adcout_offset(PwmId) = low_limit[PwmId];
									PWM_SCale[i] = (high_limit[PwmId] - low_limit[PwmId]) / max_v[PwmId];
									adcout_deb_out(PwmId) = 210;
								}
								if (PWM_SCale[i] = 0.000)
								{
									PWM_SCale[i] = 1;
									adcout_deb_out(PwmId) = 220;
								}
							}
							else {
								adcout_deb_out(PwmId) = 201;

								if (PWM_SCale[i] > 0.000) {
									adcout_deb_out(PwmId) = 202;
								}else if (PWM_SCale[i] < 0.000) {
									adcout_deb_out(PwmId) = 203;
								}
							}
							uint32_t setVal = 0;

							if (adcout_enable(PwmId) == true)
							{
								int tmp = adcout_value(PwmId) + adcout_offset(PwmId);

								if (tmp <= low_limit[PwmId])
								{
									tmp = low_limit[PwmId];
								}
								else if (tmp >= high_limit[PwmId])
								{
									tmp = high_limit[PwmId];
								}

								tmp = tmp * PWM_SCale[i];

								setVal = (uint32_t)((tmp / max_v[PwmId]) * dev->PWM.PWMperiod);
							}

							if (*dev->PWM.PWMduty != setVal)
							{
								*dev->PWM.PWMduty = setVal;
								AnalogIOSet = true;
							}

							adcout_deb_setval(PwmId) = setVal;
							
						}
						else if ((max_v[PwmId] > 0.000) && (PWM_SCale[i] > 0.000))
						{
							if (adcout_offset(PwmId) = 0)
							{
								low_limit[PwmId] = 0;
								high_limit[PwmId] = max_v[PwmId] * PWM_SCale[i];
							}
							else
							{
								low_limit[PwmId] = adcout_offset(PwmId);
								high_limit[PwmId] = adcout_offset(PwmId) + max_v[PwmId] * PWM_SCale[i];
							}
						}
						else if (adcout_enable(PwmId) == true)
						{
							if (PWM_SCale[i] = 0.000)
							{
								PWM_SCale[i] = 1.0;
								adcout_deb_out(PwmId) = 230;
							}
							else {
								adcout_deb_out(PwmId) = 231;
							}

						}*/

						if (adcout_scale(PwmId) != PWM_SCale[i])
						{
							adcout_scale(PwmId) = PWM_SCale[i];
						}

						if (adcout_max_v(PwmId) != max_v[i])
						{
							adcout_max_v(PwmId) = max_v[i];
						}

						if (adcout_high_limit(PwmId) != high_limit[i])
						{
							adcout_high_limit(PwmId) = high_limit[i];
						}

						if (adcout_low_limit(PwmId) != low_limit[i])
						{
							adcout_low_limit(PwmId) = low_limit[i];
						}

						if (dev->PWM.PWMenabledChannels[i] != PWMenabledChannels[i]) 
						{
							dev->PWM.PWMenabledChannels[i] = PWMenabledChannels[i];
							doPwmConfig = true;
						}

						if (dev->PWM.PWMduty[i] != PWMduty[i])
						{
							dev->PWM.PWMduty[i] = PWMduty[i];
							AnalogIOSet = true;
						}

					}
				}

				if (doPwmConfig = true)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PWMConfigurationSet(dev)\n", __FILE__, __FUNCTION__);
					PK_PWMConfigurationSet(dev);
					if (PK_PWMConfigurationSet(dev) != PK_OK)
					{
						usleep(sleepdur);
						PK_PWMConfigurationSet(dev);
					}
				}

				if (AnalogIOSet = true)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PWMUpdate(dev)\n", __FILE__, __FUNCTION__);
					PK_PWMUpdate(dev);
					if (PK_PWMUpdate(dev) != PK_OK)
					{
						usleep(sleepdur);
						PK_PWMUpdate(dev);
					}
				}


			}
			else 
			{
				adcout_deb_outv = 150;
			}
			


			if (loopPins = true){  //gets IO data and checks return value 
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: read IO data\n", __FILE__, __FUNCTION__);
				err=0;
				sPoKeysPinData iPin;
				deb_out = 230;

				/* 
				if ( PEv2_digout_Emergency_Pin!=0 && PEv2_PulseEngineEnabled!=0)
				{	//check if pin is parametrized in HAL
					deb_out = 231;
					if (PEv2_digout_Emergency_out==0)
					{
						//error: lvalue required as left operand of assignment
						Pins_DigitalValueSet(PEv2_digout_Emergency_Pin-1)=0;
					}
					else
					{
						//error: lvalue required as left operand of assignment
						Pins_DigitalValueSet(PEv2_digout_Emergency_Pin-1)=1;
					}
					
				}*/

				deb_out = 232;
				int AnalogPinOffset = 40; 
				int AnalogPinCount = 7;

				int PwmPinOffset = 17;
				int PwmPinCount = 6;

				for(i=0;i<info_PinCount-1;i++)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Pin %d\n", __FILE__, __FUNCTION__, i);
					deb_out = 2320+i;
					int AinNr = i - AnalogPinOffset;

					if ((AnalogIOGet = true) && (AinNr >=0) && (AinNr < AnalogPinCount))
					{
						if (adcin_scale(AinNr) = 0)
						{
							adcin_scale(AinNr) = 1;
						}

						float ainVal = 3.3 * dev->Pins[i].AnalogValue / 4096;
						
						adcin_value_raw(AinNr) = ainVal;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: adcin_value_raw(%d) = %f\n", __FILE__, __FUNCTION__, AinNr, adcin_value_raw(AinNr));
						adcin_value(AinNr) = ainVal * adcin_scale(AinNr) - adcin_offset(AinNr);
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: adc value %d = %f\n", __FILE__, __FUNCTION__, AinNr, adcin_value(AinNr));
					}


					deb_out = 2321 + i;

					if (DigitalIOGet = true)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DigitalValueGet\n", __FILE__, __FUNCTION__);
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev->Pins[i].DigitalValueGet = %d\n", __FILE__, __FUNCTION__, dev->Pins[i].DigitalValueGet);
						if (dev->Pins[i].DigitalValueGet == 0)
						{
							//Pins_DigitalValueGet(i)=false;
							digin_in(i) = false;
							digin_in_not(i) = true;
						}
						else
						{
							//Pins_DigitalValueGet(i)=true;
							digin_in(i) = true;
							digin_in_not(i) = false;
						}
					}


					if (Pins_DigitalValueSet_ignore[i] = false) {
						bool setDigoutvalue = false;
						if (digout_out(i) == 1)
						{
							if (digout_invert(i) == 0)
							{
								setDigoutvalue=true;
							}
						}
						else
						{
							if (digout_invert(i) == 1)
							{
								setDigoutvalue = true;
							}
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: setDigoutvalue = %d\n", __FILE__, __FUNCTION__, setDigoutvalue);
						if ((setDigoutvalue = true) && (dev->Pins[i].DigitalValueSet = 0))
						{
							dev->Pins[i].DigitalValueSet = 1;
							DigitalIOSet = true;
						}
						else if ((setDigoutvalue = false) && (dev->Pins[i].DigitalValueSet = 1)) 
						{
							dev->Pins[i].DigitalValueSet = 0;
							DigitalIOSet = true;
						}
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DigitalValueSet[%d] = %d\n", __FILE__, __FUNCTION__, i, dev->Pins[i].DigitalValueSet);
					}

					//Pins_DigitalCounterAvailable(i)=dev->Pins[i].DigitalCounterAvailable;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: DigitalCounterAvailable[%d] = %d\n", __FILE__, __FUNCTION__, i, dev->Pins[i].DigitalCounterAvailable);
					if(dev->Pins[i].DigitalCounterAvailable)
					{
						//Pins_DigitalCounterValue(i) = dev->Pins[i].DigitalCounterValue;
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:countr value %d = %d\n", __FILE__, __FUNCTION__, i, dev->Pins[i].DigitalCounterValue);
						counter_value(i) = dev->Pins[i].DigitalCounterValue;
						//Pins_CounterOptions(i) = dev->Pins[i].CounterOptions;
					}


					//Pins_MappingType(i)=dev->Pins[i].MappingType;
					//Pins_KeyCodeMacroID(i)=dev->Pins[i].KeyCodeMacroID;
					//Pins_KeyModifier(i)=dev->Pins[i].KeyModifier;
					//Pins_downKeyCodeMacroID(i)=dev->Pins[i].downKeyCodeMacroID;
					//Pins_downKeyModifier(i)=dev->Pins[i].downKeyModifier;
					//Pins_upKeyCodeMacroID(i)=dev->Pins[i].upKeyCodeMacroID;
					//Pins_upKeyModifier(i)=dev->Pins[i].upKeyModifier;
					//dev->Pins[i].preventUpdate=Pins_preventUpdate(i);
					
					deb_out = 2330+i;
				}
					usleep(sleepdur); 


					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s:PEv2_PulseEngineEnabled = %d\n", __FILE__, __FUNCTION__, PEv2_PulseEngineEnabled);
					if (PEv2_PulseEngineEnabled!=0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PulseEngineState = %d\n", __FILE__, __FUNCTION__, dev->PEv2.PulseEngineState);
						if (dev->PEv2.PulseEngineState == PK_PEState_peSTOP_EMERGENCY)
						{
							PEv2_digin_Emergency_in = false;
							PEv2_digin_Emergency_in_not = true;
						}
						else
						{
							PEv2_digin_Emergency_in = true;
							PEv2_digin_Emergency_in_not = false;
						}
					}





				deb_out = 236;
				if (DigitalIOSet = true)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOSet(dev)\n", __FILE__, __FUNCTION__);
					if (PK_DigitalIOSet(dev) != PK_OK)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOSet(dev) failed\n", __FILE__, __FUNCTION__);
						usleep(sleepdur);
					}
					else 
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOSet(dev) passed\n", __FILE__, __FUNCTION__);
					}
					if (PK_DigitalIOSet(dev) != PK_OK)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOSet(dev) failed\n", __FILE__, __FUNCTION__);
						usleep(sleepdur);
					}
					else 
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_DigitalIOSet(dev) passed\n", __FILE__, __FUNCTION__);
					}
				}

				deb_out = 237;
			 }
			 /*else
			 {             		  //on connection error
				deb_out = 245;
				PK_DisconnectDevice(dev);
				dev=NULL;  		  //tries to reconnect
				err=1;

			 }*/
	
	/*if (info_MatrixKeyboard!=0)
	{
		deb_out = 330;
		Update_MatrixKB;
		for (i = 0; i < 128; i++)
		{
		//	MatrixKB_matrixKBvalues(i) = MatrixKB.matrixKBvalues[i];
		//	MatrixKB_matrixKBPins(i) = MatrixKB.matrixKBPins[i];
		//	usleep(sleepdur); 
		}
		usleep(sleepdur); 
	}*/
	
			if (kbd48CNC_available!=0)
			{
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kb48CNC\n", __FILE__, __FUNCTION__);
				deb_out = 340;
				dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				PK_PoNETGetModuleSettings(dev);
				if (PK_PoNETGetModuleSettings(dev) != PK_OK)
				{

					if (PK_PoNETGetModuleSettings(dev) != PK_OK)
					{
					}
				}

				dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				PK_PoNETGetModuleLight(dev);
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleLight(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PoNETGetModuleLight(dev) == PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleLight(dev) OK\n", __FILE__, __FUNCTION__);
					kbd48CNC_lightValue = dev->PoNETmodule.lightValue;


					kbd48CNC_KeyBrightness = 255-kbd48CNC_lightValue;

					if (kbd48CNC_prevBrightness != kbd48CNC_KeyBrightness)
					{
						dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
						dev->PoNETmodule.PWMduty = kbd48CNC_KeyBrightness;
						if (PK_PoNETSetModulePWM(dev) != PK_OK)
						{
							usleep(sleepdur); 
							if (PK_PoNETSetModulePWM(dev) != PK_OK)
							{

							}
						}
					
					}
					usleep(sleepdur); 
				}




				dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleStatusRequest(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PoNETGetModuleStatusRequest(dev) != PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleStatusRequest(dev) failed\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					dev->PoNETmodule.moduleID = 0;
					if (PK_PoNETGetModuleStatusRequest(dev) != PK_OK)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleStatusRequest(dev) failed\n", __FILE__, __FUNCTION__);
						kbd48CNC_PoNetID =0;
						usleep(sleepdur);
					}
				}
				kbd48CNC_Counter[i]=0;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleStatus(dev)\n", __FILE__, __FUNCTION__);
				while (PK_PoNETGetModuleStatus(dev) != PK_OK && kbd48CNC_Counter[i]<10)
				{
					kbd48CNC_Counter[i]++;
				}

				dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleStatus(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PoNETGetModuleStatus(dev) != PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETGetModuleStatus(dev) failed\n", __FILE__, __FUNCTION__);
					if (PK_PoNETGetModuleStatus(dev) != PK_OK)
					{
						usleep(sleepdur);
					}
				}

				for (i = 0; i < 48; i++)
				{
					bool state = false;
					bool instate = false;
					// blinking 1Hz for Debug
					//state=secBlink;
					int offset[] = {15, 8, 7, 0};

					int top = (i & 0xF0) + offset[(i / 4) % 4];
					int y = i % 4;
					int ID = top + y;
					if (((i / 4) % 2) == 0)
					{
						ID = top - y;
					}
						
					if (kbd48CNC_LED(i) == true)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kbd48CNC_LED(%d) = true\n", __FILE__, __FUNCTION__, i);
						state=true;
					}

					if ((dev->PoNETmodule.statusIn[ID/8] & (1<<(ID%8))) > 0)
					{
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kbd48CNC statusIn[%d] = %d\n", __FILE__, __FUNCTION__, ID/8, dev->PoNETmodule.statusIn[ID/8]);
						instate=true;
						state = true;
					}

					/*while (kbd48CNC_Button(i)!=instate)
					{
						kbd48CNC_Button(i)=instate;
						//usleep(sleepdur/10);
					}*/
					
					kbd48CNC_Button(i)=instate;
					int tmp = dev->PoNETmodule.statusOut[ID/8];

					if (state)
					{
						tmp |= (1<<(ID%8));
					}
					else
					{
						tmp &= ~(1<<(ID%8));
					}
					dev->PoNETmodule.statusOut[ID/8] = tmp;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kbd48CNC statusOut[%d] = %d\n", __FILE__, __FUNCTION__, ID/8, dev->PoNETmodule.statusOut[ID/8]);
					/*while (dev->PoNETmodule.statusOut[ID/8] != tmp)
					{
						dev->PoNETmodule.statusOut[ID/8] = tmp;
						//usleep(sleepdur/10);
					}*/
				}

				dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				PK_PoNETSetModuleStatus(dev);
				PK_PoNETSetModuleStatus(dev);
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETSetModuleStatus(dev)\n", __FILE__, __FUNCTION__);
				if (PK_PoNETSetModuleStatus(dev) != PK_OK)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoNETSetModuleStatus(dev) failed\n", __FILE__, __FUNCTION__);
					usleep(sleepdur);
					dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
					if (PK_PoNETSetModuleStatus(dev) != PK_OK)
					{
						usleep(sleepdur);
					}
				}

				dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kbd48CNC_PoNetID = %d\n", __FILE__, __FUNCTION__, kbd48CNC_PoNetID);

				if (PK_PoNETSetModuleStatus(dev) != PK_OK)
				{
					dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: kbd48CNC PK_PoNETSetModuleStatus(dev)\n", __FILE__, __FUNCTION__);
					if (PK_PoNETSetModuleStatus(dev) != PK_OK)
					{
					}
				}
				
				//dev->PoNETmodule.moduleID = kbd48CNC_PoNetID;
				//PK_PoNETSetModuleStatus(dev);
			}
/*
			if (info_EasySensors!=0)
			{
				Update_EasySensors;
				for (i = 0; i < dev->info.iEasySensors; i++)
				{
					EasySensors_sensorValue(i) = EasySensors[i].sensorValue;            // Current sensor value
				}
			}
*/
	
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PoExtBus = %d\n", __FILE__, __FUNCTION__, info_PoExtBus);
			if (info_PoExtBus!=0)
			{
				
				for (i = 0; i < 10; i++)
				{
					rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoExtBusGet(dev) i = %d\n", __FILE__, __FUNCTION__, i);
					PK_PoExtBusGet(dev);
					PoExtBus_DataGet[i] = dev->PoExtBusData[i];

					PoExtBus_digin_0_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 0);
					PoExtBus_digin_1_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 1);
					PoExtBus_digin_2_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 2);
					PoExtBus_digin_3_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 3);
					PoExtBus_digin_4_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 4);
					PoExtBus_digin_5_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 5);
					PoExtBus_digin_6_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 6);
					PoExtBus_digin_7_in(i) = Get_BitOfByte(PoExtBus_DataGet[i], 7);

					PoExtBus_digin_0_in_not(i) = !PoExtBus_digin_0_in(i);
					PoExtBus_digin_1_in_not(i) = !PoExtBus_digin_1_in(i);
					PoExtBus_digin_2_in_not(i) = !PoExtBus_digin_2_in(i);
					PoExtBus_digin_3_in_not(i) = !PoExtBus_digin_3_in(i);
					PoExtBus_digin_4_in_not(i) = !PoExtBus_digin_4_in(i);
					PoExtBus_digin_5_in_not(i) = !PoExtBus_digin_5_in(i);
					PoExtBus_digin_6_in_not(i) = !PoExtBus_digin_6_in(i);
					PoExtBus_digin_7_in_not(i) = !PoExtBus_digin_7_in(i);

					if (PoExtBus_digout_0_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 0, PoExtBus_digout_0_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 0, !PoExtBus_digout_0_out(i));
					}

					if (PoExtBus_digout_1_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 1, PoExtBus_digout_1_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 1, !PoExtBus_digout_1_out(i));
					}

					if (PoExtBus_digout_2_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 2, PoExtBus_digout_2_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 2, !PoExtBus_digout_2_out(i));
					}

					if (PoExtBus_digout_3_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 3, PoExtBus_digout_3_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 3, !PoExtBus_digout_3_out(i));
					}

					if (PoExtBus_digout_4_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 4, PoExtBus_digout_4_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 4, !PoExtBus_digout_4_out(i));
					}

					if (PoExtBus_digout_5_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 5, PoExtBus_digout_5_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 5, !PoExtBus_digout_5_out(i));
					}

					if (PoExtBus_digout_6_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 6, PoExtBus_digout_6_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 6, !PoExtBus_digout_6_out(i));
					}

					if (PoExtBus_digout_7_invert(i) == false) {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 7, PoExtBus_digout_7_out(i));
					}
					else {
						PoExtBus_DataSet[i] = Set_BitOfByte(PoExtBus_DataSet[i], 7, !PoExtBus_digout_7_out(i));
					}

					if (PoExtBus_DataGet[i] != PoExtBus_DataSet[i])
					{
						
						dev->PoExtBusData[i] = PoExtBus_DataSet[i];
						rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_PoExtBusSet(dev)\n", __FILE__, __FUNCTION__);
						PK_PoExtBusSet(dev);
						usleep(sleepdur); 
						PK_PoExtBusSet(dev);
					}
					usleep(sleepdur); 
				}
			}
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PoNET = %d\n", __FILE__, __FUNCTION__, info_PoNET);
			if (info_protI2C!=0)
			{
			
			}

			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: rtc_lastmin = %d\n", __FILE__, __FUNCTION__, rtc_lastmin);
			if (rtc_lastmin!=rtc_min)
			{
				alive = 0;

				deb_out = 310;
				rtc_lastmin=rtc_min;
				
				 info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
				 info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
				 info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
				 info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
				 info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
				 info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
				 info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
				 info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
				 info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
				 info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
				 info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
				 info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
				 info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
				 info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
				 info_Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
				 info_MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
				 info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
				 info_LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
				 info_MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
				 info_ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
				 info_PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
				 info_PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
				 info_AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
				 info_InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
				 info_protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
				 info_prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
				 info_AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
				 info_LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
				 info_CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
				 info_PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
				 info_SensorList = dev->info.iSensorList;                      // Device supports sensor lists
				 info_WebInterface = dev->info.iWebInterface;                    // Device supports web interface
				 info_FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
				 info_JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
				 info_PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
				 info_PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
				 info_EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors
				 deb_out = 311;

				 
				 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: info_PulseEnginev2 = %d\n", __FILE__, __FUNCTION__, info_PulseEnginev2);
				 if (info_PulseEnginev2 != 0)
				 {
					 bool DoPeSetup = false;
					 bool DoPeReboot = false;
					 setPinConfig = false;
					 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_params_ApplyIniSettings = %d\n", __FILE__, __FUNCTION__, PEv2_params_ApplyIniSettings);
					 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: HAL_Machine_On = %d\n", __FILE__, __FUNCTION__, HAL_Machine_On);
					 if ((PEv2_params_ApplyIniSettings != 0) && (HAL_Machine_On==false))
					 {
						 //dev->PEv2.AxisEnabledStatesMask=0; //Disable axis power when not in Running state
						 //PK_PEv2_PulseEngineSetup(dev);
						 usleep(sleepdur);
						 if (PEv2_digin_Probe_Pin != 0)
						 {	//check if pin is parametrized in HAL
							 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev->Pins[%d].PinFunction = %d\n", __FILE__, __FUNCTION__, PEv2_digin_Probe_Pin - 1, dev->Pins[PEv2_digin_Probe_Pin - 1].PinFunction);
							 if (dev->Pins[PEv2_digin_Probe_Pin - 1].PinFunction != PK_PinCap_digitalInput)
							 {
								 dev->Pins[PEv2_digin_Probe_Pin - 1].PinFunction = PK_PinCap_digitalInput;
								 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SL_SetPinFunction(dev, %d, PK_PinCap_digitalInput)\n", __FILE__, __FUNCTION__, PEv2_digin_Probe_Pin - 1);
								 PK_SL_SetPinFunction(dev, PEv2_digin_Probe_Pin - 1, PK_PinCap_digitalInput);
								 setPinConfig = true;
							 }

						 }


						 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2.EmergencyInputPin = %d\n", __FILE__, __FUNCTION__, dev->PEv2.EmergencyInputPin);
						 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PEv2_digin_Emergency_Pin = %d\n", __FILE__, __FUNCTION__, PEv2_digin_Emergency_Pin);
						 if (dev->PEv2.EmergencyInputPin != PEv2_digin_Emergency_Pin)
						 {
							 dev->PEv2.EmergencyInputPin = PEv2_digin_Emergency_Pin;
							 DoPeSetup = true;
							 if (PEv2_digin_Emergency_Pin != 0)
							 {	//check if pin is parametrized in HAL
								 rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: dev->Pins[%d].PinFunction = %d\n", __FILE__, __FUNCTION__, PEv2_digin_Emergency_Pin - 1, dev->Pins[PEv2_digin_Emergency_Pin - 1].PinFunction);
								 dev->Pins[PEv2_digin_Emergency_Pin - 1].PinFunction = PK_PinCap_digitalInput;
									rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: PK_SL_SetPinFunction(dev, %d, PK_PinCap_digitalInput)\n", __FILE__, __FUNCTION__, PEv2_digin_Emergency_Pin - 1);
								 PK_SL_SetPinFunction(dev, PEv2_digin_Emergency_Pin - 1, PK_PinCap_digitalInput);
								 
								 setPinConfig = true;
							 }
						 }

						 if (PEv2_digout_Emergency_Pin != 0)
						 {	//check if pin is parametrized in HAL
							 if (dev->Pins[PEv2_digout_Emergency_Pin - 1].PinFunction != PK_PinCap_digitalOutput)
							 {
								 dev->Pins[PEv2_digout_Emergency_Pin - 1].PinFunction = PK_PinCap_digitalOutput;
								 PK_SL_SetPinFunction(dev, PEv2_digin_Emergency_Pin - 1, PK_PinCap_digitalOutput);
								 Pins_DigitalValueSet_ignore[PEv2_digin_Emergency_Pin - 1] = true;
								 setPinConfig = true;
							 }

						 }

						 if (dev->PEv2.PulseEngineEnabled != dev->PEv2.info.nrOfAxes)
						 {
							 dev->PEv2.PulseEngineEnabled = dev->PEv2.info.nrOfAxes;
							 PEv2_PulseEngineEnabled = dev->PEv2.info.nrOfAxes;
							 DoPeSetup = true;
						 }

						 if (PEv2_PulseEngineEnabled != 0)
						 {
							 dev->PEv2.PulseEngineActivated = 1;
							 DoPeSetup = true;
						 }
						 if (PEv2_PulseGeneratorType == 0)
						 {

							 if (PEv2_PG_swap_stepdir != false)
							 {
								 PEv2_PulseGeneratorType = Set_BitOfByte(PEv2_PulseGeneratorType, 6, true); // swap step / dir signals
								 DoPeSetup = true;
							 }


							 if (PEv2_PG_extended_io != false)
							 {
								 PEv2_PulseGeneratorType = Set_BitOfByte(PEv2_PulseGeneratorType, 7, true); // extended io
								 DoPeSetup = true;
							 }

						 }

						 if (dev->PEv2.ChargePumpEnabled != PEv2_ChargePumpEnabled) {
							dev->PEv2.ChargePumpEnabled = PEv2_ChargePumpEnabled;
							DoPeSetup = true;
						 }
						 if (dev->PEv2.PulseGeneratorType != PEv2_PulseGeneratorType) {
							 dev->PEv2.PulseGeneratorType = PEv2_PulseGeneratorType;
							 DoPeSetup = true;
						 }
						 if (dev->PEv2.EmergencySwitchPolarity != PEv2_digin_Emergency_invert) {
							 dev->PEv2.EmergencySwitchPolarity = PEv2_digin_Emergency_invert;
							 DoPeSetup = true;
						 }
						 //dev->PEv2.PulseEngineBufferSize = PEv2_stepgen_PulseEngineBufferSize;
						 
						 //dev->PEv2.AxisEnabledStatesMask = PEv2_stepgen_AxisEnabledStatesMask;
						 if (DoPeSetup = true) 
						 {
							 if (PK_PEv2_PulseEngineSetup(dev) != PK_OK)
							 {
								 usleep(sleepdur);
							 }

							 
							 if (PK_PEv2_PulseEngineSetup(dev) == PK_OK)
							 {
								 usleep(sleepdur);
							 }
							 if (DoPeReboot = true)
							 {
								 PK_PEv2_PulseEngineReboot(dev);
								 usleep(1000000);
							 }
						 }

					 }
					 else
					 {
						 if (PK_PEv2_StatusGet(dev) == PK_OK && PK_PEv2_Status2Get(dev) == PK_OK)
						 {
							 PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
							 PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
							 PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;
							 //PEv2_stepgen_PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
							 PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
							 //PEv2_stepgen_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;

							 PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
							 PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
							 PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;
							 //PEv2_stepgen_PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
							 PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
							 //PEv2_stepgen_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
						 }

						 if (PK_PEv2_AdditionalParametersGet(dev) == PK_OK)
						 {
							 PEv2_digin_Emergency_Pin = dev->PEv2.EmergencyInputPin;
							 usleep(sleepdur);
						 }
					 }

					 uint8_t AxesConfig[8];
					 uint8_t AxesSwitchConfig[8];
					 for (i = 0; i < dev->PEv2.info.nrOfAxes; i++)
					 {
						 if (PEv2_params_ApplyIniSettings != 0)
						 {
							 bool doAxisConfig = false;
							 // Convert mm/s -> pulses/s
							 if (PEv2_stepgen_STEP_SCALE(i) != 0)
							 {
								 //need to ensure positve values for the following calculations otherwise machine will not move
								 PEv2_MaxSpeed(i) = abs(PEv2_stepgen_STEPGEN_MAXVEL(i) * PEv2_stepgen_STEP_SCALE(i) / 1000);				// Maximum axis speed convert (mm/s) to (pulses per ms)
								 PEv2_MaxAcceleration(i) = abs(PEv2_stepgen_STEPGEN_MAXACCEL(i) * PEv2_stepgen_STEP_SCALE(i) / 1000000);	// Maximum axis acceleration convert (mm/s�) to (in pulses/ms/ms)
								 PEv2_MaxDecceleration(i) = abs(PEv2_stepgen_STEPGEN_MAXACCEL(i) * PEv2_stepgen_STEP_SCALE(i) / 1000000);	// Maximum axis deceleration convert (mm/s�) to (in pulses/ms/ms)

								 PEv2_digin_SoftLimit_PosMax(i) = PEv2_stepgen_MAX_LIMIT(i) * PEv2_stepgen_STEP_SCALE(i);		// Soft limit maximum position
								 PEv2_digin_SoftLimit_PosMin(i) = PEv2_stepgen_MIN_LIMIT(i) * PEv2_stepgen_STEP_SCALE(i);		// Soft limit minimum position
								 PEv2_digin_Home_Offset(i) = PEv2_stepgen_HOME_OFFSET(i) * PEv2_stepgen_STEP_SCALE(i);		// Home position offset

								 PEv2_HomingSpeed(i) = abs(PEv2_stepgen_HOME_SEARCH_VEL(i) * 100 / PEv2_stepgen_STEPGEN_MAXVEL(i));			// Homing speed per axis (in %)
								 PEv2_HomingReturnSpeed(i) = abs(PEv2_stepgen_HOME_LATCH_VEL(i) * 100 / PEv2_stepgen_HOME_SEARCH_VEL(i));	// Homing return speed per axis (in % of the homing speed)

								 // Convert parameters... assume little-endian format
								 if (dev->PEv2.MaxSpeed[i] != PEv2_MaxSpeed(i))
								 {
									 dev->PEv2.MaxSpeed[i] = PEv2_MaxSpeed(i);
									 doAxisConfig = true;
								 }
								 if (dev->PEv2.MaxAcceleration[i] != PEv2_MaxAcceleration(i))
								 {
									 dev->PEv2.MaxAcceleration[i] = PEv2_MaxAcceleration(i);
									 doAxisConfig = true;
								 }
								 
								 if (dev->PEv2.MaxDecceleration[i] != PEv2_MaxDecceleration(i))
								 {
									 dev->PEv2.MaxDecceleration[i] = PEv2_MaxDecceleration(i);
									 doAxisConfig = true;
								 }
								 
								 if (dev->PEv2.SoftLimitMinimum[i] != PEv2_digin_SoftLimit_PosMin(i))
								 {
									 dev->PEv2.SoftLimitMinimum[i] = PEv2_digin_SoftLimit_PosMin(i);
									 doAxisConfig = true;
								 }
								 
								 if (dev->PEv2.SoftLimitMaximum[i] != PEv2_digin_SoftLimit_PosMax(i))
								 {
									 dev->PEv2.SoftLimitMaximum[i] = PEv2_digin_SoftLimit_PosMax(i);
									 doAxisConfig = true;
								 }
								 
								 if (dev->PEv2.HomeOffsets[i] != PEv2_digin_Home_Offset(i))
								 {
									 dev->PEv2.HomeOffsets[i] = PEv2_digin_Home_Offset(i);
									 doAxisConfig = true;
								 }
								 
								 if (dev->PEv2.HomingSpeed[i] != PEv2_HomingSpeed(i))
								 {
									 dev->PEv2.HomingSpeed[i] = PEv2_HomingSpeed(i);
									 doAxisConfig = true;
								 }
								 
								 if (dev->PEv2.HomingReturnSpeed[i] != PEv2_HomingReturnSpeed(i))
								 {
									 dev->PEv2.HomingReturnSpeed[i] = PEv2_HomingReturnSpeed(i);
									 doAxisConfig = true;
								 }
								

							 }

							 AxesConfig[i] = 0;
							 // Read the structure and set the bits accordingly
							 /*
								 PK_AC_ENABLED            = (1 << 0),       // 1 Axis enabled
								 PK_AC_INVERTED           = (1 << 1),       // 2 Axis inverted
								 PK_AC_INTERNAL_PLANNER   = (1 << 2),       // 4 Axis uses internal motion planner
								 PK_AC_POSITION_MODE      = (1 << 3),       // 8 Internal motion planner for this axis is in position mode
								 PK_AC_INVERTED_HOME      = (1 << 4),       // 16 Axis homing direction is inverted
								 PK_AC_SOFT_LIMIT_ENABLED = (1 << 5),       // 32 Use soft-limits for this axis
								 PK_AC_ENABLED_MASKED     = (1 << 7)        // 128 Use output enable pin masking
							 */
							 //PEv2_stepgen_AxesConfig(i) = PK_AC_ENABLED_MASKED;
							 if (PEv2_stepgen_STEPGEN_MAXVEL(i) != 0)
							 {
								 AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 0, true);  // PK_AC_ENABLED ;
								 AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 2, true);  // PK_AC_INTERNAL_PLANNER;

							 }


							 if (posMode[i]==true)
							 {
								 AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 3, true);  // PK_AC_POSITION_MODE;
								// posMode[i] = true;
							 }

							 /*
								 PK_ASO_SWITCH_LIMIT_N        = (1 << 0),   // 1 Limit- switch
								 PK_ASO_SWITCH_LIMIT_P        = (1 << 1),   // 2 Limit+ switch
								 PK_ASO_SWITCH_HOME           = (1 << 2),   // 4 Home switch
								 PK_ASO_SWITCH_COMBINED_LN_H  = (1 << 3),   // 8 Home switch is shared with Limit- switch
								 PK_ASO_SWITCH_COMBINED_LP_H  = (1 << 4),   // 16 Home switch is shared with Limit+ switch
								 PK_ASO_SWITCH_INVERT_LIMIT_N = (1 << 5),   // 32 Invert limit- switch polarity
								 PK_ASO_SWITCH_INVERT_LIMIT_P = (1 << 6),   // 64 Invert limit+ switch polarity
								 PK_ASO_SWITCH_INVERT_HOME    = (1 << 7)    // 128 Invert home switch polarity
							 */
							 AxesSwitchConfig[i] = PEv2_AxesSwitchConfig(i); // initial value from ini file

							 if (PEv2_digin_SoftLimit_PosMax(i) != 0 | PEv2_digin_SoftLimit_PosMin(i) != 0)
							 {
								// AxesConfig[i] = Set_BitOfByte(AxesConfig[i], 3, true); // PK_AC_SOFT_LIMIT_ENABLED;
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 3, true); // PK_AC_SOFT_LIMIT_ENABLED;
							 }


							 if (PEv2_digin_Home_Pin(i) != 0)
							 {
								 //check if pin is parametrized in HAL
								 int Home = PEv2_digin_Home_Pin(i);
								 int LimP = PEv2_digin_LimitP_Pin(i);
								 int LimM = PEv2_digin_LimitN_Pin(i);

								 if (Home != LimM && Home != LimP)
								 {
									 if (dev->PEv2.PinHomeSwitch[i] != Home) {
										 dev->PEv2.PinHomeSwitch[i] = Home;
										 doAxisConfig = true;
									 }
								 }
								 else if (Home == LimP)
								 {
									 //dev->PEv2.PinHomeSwitch[i]=0;
									 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 4, true); // 16 Home switch is shared with Limit+ switch
								 }
								 else if (Home == LimM)
								 {
									 //dev->PEv2.PinHomeSwitch(i)=0;
									 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 3, true); // 8 Home switch is shared with Limit- switch

								 }
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 2, true); // | PK_ASO_SWITCH_HOME;
								 if (dev->Pins[Home - 1].PinFunction != PK_PinCap_digitalInput)
								 {
									 dev->Pins[Home - 1].PinFunction = PK_PinCap_digitalInput;
									 PK_SL_SetPinFunction(dev, Home - 1, PK_PinCap_digitalInput);
									 setPinConfig = true;
								 }
							 }
							 else
							 {
								 dev->PEv2.PinHomeSwitch[i] = 0;
							 }

							 if (PEv2_digin_Home_invert(i)==true)
							 {
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 7, true); // PK_ASO_SWITCH_INVERT_HOME    = (1 << 7)    // 128 Invert home switch polarity
								 doAxisConfig = true;
							 }


							 if (dev->PEv2.PinLimitMSwitch[i] != PEv2_digin_LimitN_Pin(i))
							 {
								 dev->PEv2.PinLimitMSwitch[i] = PEv2_digin_LimitN_Pin(i);
								 doAxisConfig = true;
							 }
							 if (PEv2_digin_LimitN_invert(i) == true)
							 {
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 5, true); // PK_ASO_SWITCH_INVERT_LIMIT_N = (1 << 5),   // 32 Invert limit- switch polarity
								 doAxisConfig = true;
							 }
							 if (PEv2_digin_LimitP_invert(i) == true)
							 {
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 6, true); // PK_ASO_SWITCH_INVERT_LIMIT_P = (1 << 6),   // 64 Invert limit+ switch polarity
								 doAxisConfig = true;
							 }

							 if (PEv2_digin_LimitN_Pin(i) != 0)
							 {	//check if pin is parametrized in HAL
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 0, true); // | PK_ASO_SWITCH_LIMIT_N;
								 
								 if (dev->Pins[PEv2_digin_LimitN_Pin(i) - 1].PinFunction != PK_PinCap_digitalInput)
								 {
									 dev->Pins[PEv2_digin_LimitN_Pin(i) - 1].PinFunction = PK_PinCap_digitalInput;
									 PK_SL_SetPinFunction(dev, PEv2_digin_LimitN_Pin(i) - 1, PK_PinCap_digitalInput);
									 setPinConfig = true;
								 }
							 }

							 if (dev->PEv2.PinLimitPSwitch[i] != PEv2_digin_LimitP_Pin(i))
							 {
								 dev->PEv2.PinLimitPSwitch[i] = PEv2_digin_LimitP_Pin(i);
								 doAxisConfig = true;
							 }
							 
							 if (PEv2_digin_LimitP_Pin(i) != 0)
							 {	//check if pin is parametrized in HAL
								 AxesSwitchConfig[i] = Set_BitOfByte(AxesSwitchConfig[i], 1, true); // | PK_ASO_SWITCH_LIMIT_P;
								 
								 if (dev->Pins[PEv2_digin_LimitP_Pin(i) - 1].PinFunction != PK_PinCap_digitalInput)
								 {
									 dev->Pins[PEv2_digin_LimitP_Pin(i) - 1].PinFunction = PK_PinCap_digitalInput;
									 PK_SL_SetPinFunction(dev, PEv2_digin_LimitP_Pin(i) - 1, PK_PinCap_digitalInput);
									 setPinConfig = true;
								 }
							 
							 }

							 if (dev->PEv2.HomingSpeed[i] != PEv2_HomingSpeed(i))
							 {
								 dev->PEv2.HomingSpeed[i] = PEv2_HomingSpeed(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.HomingReturnSpeed[i] = PEv2_HomingReturnSpeed(i))
							 {
								 dev->PEv2.HomingReturnSpeed[i] != PEv2_HomingReturnSpeed(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.MPGjogEncoder[i] != PEv2_MPGjogEncoder(i))
							 {
								 dev->PEv2.MPGjogEncoder[i] = PEv2_MPGjogEncoder(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.MPGjogMultiplier[i] != PEv2_MPGjogMultiplier(i))
							 {
								 dev->PEv2.MPGjogMultiplier[i] = PEv2_MPGjogMultiplier(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.AxisEnableOutputPins[i] != PEv2_digout_AxisEnable_Pin(i))
							 {
								 dev->PEv2.AxisEnableOutputPins[i] = PEv2_digout_AxisEnable_Pin(i);
								 doAxisConfig = true;
							 }
							 
							 if (PEv2_digout_AxisEnable_Pin(i) != 0)
							 {	//check if pin is parametrized in HAL
								 if (dev->Pins[PEv2_digout_AxisEnable_Pin(i) - 1].PinFunction != PK_PinCap_digitalOutput)
								 {
									 dev->Pins[PEv2_digout_AxisEnable_Pin(i) - 1].PinFunction = PK_PinCap_digitalOutput;
									 PK_SL_SetPinFunction(dev, PEv2_digout_AxisEnable_Pin(i) - 1, PK_PinCap_digitalOutput);
									 setPinConfig = true;
								 }
								 Pins_DigitalValueSet_ignore[PEv2_digout_AxisEnable_Pin(i) - 1] = true;
							 }

							 if (dev->PEv2.InvertAxisEnable[i] != PEv2_digout_AxisEnable_invert(i))
							 {
								 dev->PEv2.InvertAxisEnable[i] = PEv2_digout_AxisEnable_invert(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.FilterLimitMSwitch[i] != PEv2_digin_LimitN_Filter(i))
							 {
								 dev->PEv2.FilterLimitMSwitch[i] = PEv2_digin_LimitN_Filter(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.FilterLimitPSwitch[i] != PEv2_digin_LimitP_Filter(i))
							 {
								 dev->PEv2.FilterLimitPSwitch[i] = PEv2_digin_LimitP_Filter(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.FilterHomeSwitch[i] != PEv2_digin_Home_Filter(i))
							 {
								 dev->PEv2.FilterHomeSwitch[i] = PEv2_digin_Home_Filter(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.HomingAlgorithm[i] != PEv2_HomingAlgorithm(i))
							 {
								 dev->PEv2.HomingAlgorithm[i] = PEv2_HomingAlgorithm(i);
								 doAxisConfig = true;
							 }
							 
							 // MPG 1x mode here
							 if (dev->PEv2.HomeBackOffDistance[i] != PEv2_HomeBackOffDistance(i))
							 {
								 dev->PEv2.HomeBackOffDistance[i] = PEv2_HomeBackOffDistance(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.MPGjogDivider[i] != PEv2_MPGjogDivider(i))
							 {
								 dev->PEv2.MPGjogDivider[i] = PEv2_MPGjogDivider(i);
								 doAxisConfig = true;
							 }
							 
							 if (dev->PEv2.AxesConfig[i] != AxesConfig[i])
							 {
								 dev->PEv2.AxesConfig[i] = AxesConfig[i];
								 doAxisConfig = true;
							 }
							 
							 //PEv2_AxesConfig(i) =AxesConfig[i]; Readonly!
							 //PEv2_AxesSwitchConfig(i)=AxesSwitchConfig[i];
							 if (dev->PEv2.AxesSwitchConfig[i] != AxesSwitchConfig[i])
							 {
								 dev->PEv2.AxesSwitchConfig[i] = AxesSwitchConfig[i];
								 doAxisConfig = true;
							 }
							 
							 //dev->PEv2.AxesConfig[i] = 0;
							 //dev->PEv2.AxesSwitchConfig[i] =0;
							 if (doAxisConfig = true)
							 {
								 dev->PEv2.param1 = i;
								 if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK)
								 {
									 usleep(sleepdur);
									 dev->PEv2.param1 = i;
									 if (PK_PEv2_AxisConfigurationSet(dev) != PK_OK)
									 {
										 usleep(sleepdur);
									 }
								 }
							 }

						 }
						 else
						 {
							 dev->PEv2.param1 = i;
							 if (PK_PEv2_AxisConfigurationGet(dev) == PK_OK)
							 {
								 // Read the structure
								 //PEv2_AxesConfig(i) = dev->PEv2.AxesConfig[i]; readonly
								 //PEv2_AxesSwitchConfig(i)  = dev->PEv2.AxesSwitchConfig[i];

								 //PEv2_digin_Home_Pin(i) = dev->PEv2.PinHomeSwitch[i];
								 //PEv2_digin_LimitN_Pin(i) = dev->PEv2.PinLimitMSwitch[i];
								 //PEv2_digin_LimitP_Pin(i) = dev->PEv2.PinLimitPSwitch[i];

								 PEv2_HomingSpeed(i) = dev->PEv2.HomingSpeed[i];
								 PEv2_HomingReturnSpeed(i) = dev->PEv2.HomingReturnSpeed[i];

								 PEv2_MPGjogEncoder(i) = dev->PEv2.MPGjogEncoder[i];

								 // Convert parameters... assume little-endian format
								 PEv2_MaxSpeed(i) = dev->PEv2.MaxSpeed[i];
								 PEv2_MaxAcceleration(i) = dev->PEv2.MaxAcceleration[i];
								 PEv2_MaxDecceleration(i) = dev->PEv2.MaxDecceleration[i];

								 PEv2_digin_SoftLimit_PosMin(i) = dev->PEv2.SoftLimitMinimum[i];
								 PEv2_digin_SoftLimit_PosMax(i) = dev->PEv2.SoftLimitMaximum[i];

								 PEv2_MPGjogMultiplier(i) = dev->PEv2.MPGjogMultiplier[i];

								 //PEv2_digout_AxisEnable_Pin(i) = dev->PEv2.AxisEnableOutputPins[i];
								 PEv2_digout_AxisEnable_invert(i) = dev->PEv2.InvertAxisEnable[i];

								 PEv2_digin_LimitN_Filter(i) = dev->PEv2.FilterLimitMSwitch[i];
								 PEv2_digin_LimitP_Filter(i) = dev->PEv2.FilterLimitPSwitch[i];
								 PEv2_digin_Home_Filter(i) = dev->PEv2.FilterHomeSwitch[i];

								 PEv2_HomingAlgorithm(i) = dev->PEv2.HomingAlgorithm[i];
								 // MPG 1x mode here
								 PEv2_HomeBackOffDistance(i) = dev->PEv2.HomeBackOffDistance[i];
								 PEv2_MPGjogDivider(i) = dev->PEv2.MPGjogDivider[i];
								 usleep(sleepdur);
							 }
						 }
					 }
					 //dev->PEv2.param1 = 0;
					 if (PK_PEv2_StatusGet(dev) == PK_OK)
					 {
						 PEv2_PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
						 PEv2_ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
						 PEv2_PulseGeneratorType = dev->PEv2.PulseGeneratorType;
						 //PEv2_stepgen_PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
						 PEv2_digin_Emergency_invert = dev->PEv2.EmergencySwitchPolarity;
						 //PEv2_stepgen_AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
					 }

					 if (setPinConfig == true)
					 {
						 if (PK_PinConfigurationSet(dev) != PK_OK)
						 {
							 usleep(sleepdur);
							 if (PK_PinConfigurationSet(dev) != PK_OK)
							 {
								 usleep(sleepdur);
							 }
							 else
							 {
								 setPinConfig = false;
							 }
						 }
						 else
						 {
							 setPinConfig = false;
						 }
					 }
				 }

			}
			else
			{
				alive = 0;
				usleep(sleepdur*50);
			}
			
			
        }
    }

    exit(0);
};

EXTRA_SETUP()
{
	int wait_ms = 5000;
	rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: extra_arg=%s\n", __FILE__, __FUNCTION__, extra_arg);

	//usleep(wait_ms);  // wait for the HAL to start up
	for (i = 0; i < retry; i++)
	{
		if (dev == NULL)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: TryConnectToDevice(0)", __FILE__, __FUNCTION__);
			dev = TryConnectToDevice(0);
		}
		if (dev != NULL)
		{
			rtapi_print_msg(RTAPI_MSG_DBG, "PoKeys: %s:%s: Connected", __FILE__, __FUNCTION__);
			break;
		}
	}

	rtapi_print("");
	// devSerial = extra_arg;
	return 0;
}

EXTRA_CLEANUP()
{
	if (dev != NULL)
	{
		PK_DisconnectDevice(dev);
	}
}





component pokeys "PoKeys IO driver, by Mit Zot";

option userspace yes;

pin out unsigned enum_usb_dev;
pin out unsigned enum_fusb_dev;
pin out unsigned enum_udp_dev;
pin out s32 a_debout;

pin out bit err;
pin out bit connected;
pin in unsigned devSerial;
pin out bit alive;

pin in bit machine_is_on;

// PoKeys device information
//sPoKeysDevice_Info info;
pin out unsigned info.PinCount;                        // Number of pins, physically on the device
pin out unsigned info.PWMCount;                        // Number of pins that support PWM output
pin out unsigned info.BasicEncoderCount;               // Number of basic encoders
pin out unsigned info.EncodersCount;                   // Number of encoder slots available
pin out unsigned info.FastEncoders;                    // Number of fast encoders supported
pin out unsigned info.UltraFastEncoders;               // Number of available ultra fast encoders
pin out unsigned info.PWMinternalFrequency;             // Main PWM peripheral clock
pin out unsigned info.AnalogInputs;                    // Number of available analog inputs
pin out unsigned info.KeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
pin out unsigned info.TriggeredKeyMapping;             // Device supports triggered key mapping
pin out unsigned info.KeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
pin out unsigned info.DigitalCounters;                 // Device supports digital counters
pin out unsigned info.JoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
pin out unsigned info.JoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
pin out unsigned info.Macros;                          // Device supports customizable macro sequences
pin out unsigned info.MatrixKeyboard;                  // Device supports matrix keyboard
pin out unsigned info.MatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
pin out unsigned info.LCD;                             // Device supports alphanumeric LCD display
pin out unsigned info.MatrixLED;                       // Device supports matrix LED display
pin out unsigned info.ConnectionSignal;                // Device supports connection signal output
pin out unsigned info.PoExtBus;                        // Device supports PoExtBus digital outputs
pin out unsigned info.PoNET;                           // Device supports PoNET bus devices
pin out unsigned info.AnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
pin out unsigned info.InitOutputsStart;                // Device supports initializing outputs at startup
pin out unsigned info.protI2C;                         // Device supports I2C bus (master)
pin out unsigned info.prot1wire;                       // Device supports 1-wire bus (master)
pin out unsigned info.AdditionalOptions;               // Device supports additional options with activation keys
pin out unsigned info.LoadStatus;                      // Device supports reporting load status
pin out unsigned info.CustomDeviceName;                // Device supports specifying custom device names
pin out unsigned info.PoTLog27support;                 // Device supports PoTLog27 firmware
pin out unsigned info.SensorList;                      // Device supports sensor lists
pin out unsigned info.WebInterface;                    // Device supports web interface
pin out unsigned info.FailSafeSettings;                // Device supports fail-safe mode
pin out unsigned info.JoystickHATswitch;               // Device supports joystick HAT switch mapping
pin out unsigned info.PulseEngine;                     // Device supports Pulse engine
pin out unsigned info.PulseEnginev2;                   // Device supports Pulse engine v2
pin out unsigned info.EasySensors;                     // Device supports EasySensors

// Pulse engine v2 information
pin out unsigned PEv2.nrOfAxes;
pin out unsigned PEv2.maxPulseFrequency;
pin out unsigned PEv2.bufferDepth;
pin out unsigned PEv2.slotTiming;

//***********************************************************************
//[TRAJ] information in HAL-INI 
pin in s32 PEv2.params.COORDINATES;
pin in s32 PEv2.params.LINEAR_UNITS;
pin in s32 PEv2.params.ANGULAR_UNITS;
pin in float PEv2.params.CYCLE_TIME;
pin in float PEv2.params.DEFAULT_LINEAR_VELOCITY;
pin in float PEv2.params.MAX_LINEAR_VELOCITY;

pin in bit PEv2.params.ApplyIniSettings;
//***********************************************************************

// Pulse engine v2 structure...
pin out unsigned PEv2.#.AxesState [8];				// Axis states (bit-mapped) - see ePK_PEAxisState
pin out unsigned PEv2.#.AxesConfig [8];				// Axis configuration - see ePK_PEv2_AxisConfig
pin in unsigned PEv2.#.AxesSwitchConfig [8];		// Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions

pin io u32 PEv2.#.InvertAxisEnable [8];		// Invert axis enable signal
pin io u32 PEv2.#.SoftLimitMaximum [8];		// Soft limit maximum position
pin io u32 PEv2.#.SoftLimitMinimum [8];		// Soft limit minimum position
pin io unsigned PEv2.#.HomingSpeed [8];			// Homing speed per axis (in %)
pin io unsigned PEv2.#.HomingReturnSpeed [8];		// Homing return speed per axis (in % of the homing speed)
pin io u32 PEv2.#.HomeOffsets [8];				// Home position offset
pin io unsigned PEv2.#.HomingAlgorithm [8];		// Homing algorithm configuration
pin io unsigned PEv2.#.FilterLimitMSwitch [8];		// Digital filter for limit- switch
pin io unsigned PEv2.#.FilterLimitPSwitch [8];		// Digital filter for limit+ switch
pin io unsigned PEv2.#.FilterHomeSwitch [8];		// Digital filter for home switch
pin io u32 PEv2.#.ProbePosition [8];			// Position where probe detected change
pin io u32 PEv2.#.ProbeMaxPosition [8];		// Maximum position to travel to until stopping and returning error

pin out u32 PEv2.#.CurrentPosition [8];			// Current position
pin io u32 PEv2.#.PositionSetup [8];			// Position to be set as current position
pin io u32 PEv2.#.ReferencePositionSpeed [8];	// Reference position or speed (position or pulses/s)
pin io float PEv2.#.MaxSpeed [8];					// Maximum axis speed (in pulses per ms)
pin io float PEv2.#.MaxAcceleration [8];			// Maximum axis acceleration (in pulses/ms/ms)
pin io float PEv2.#.MaxDecceleration [8];			// Maximum axis deceleration (in pulses/ms/ms)

pin io float PEv2.#.MaxSpeed_mm_per_sec [8];			// Maximum axis speed (mm/s)
pin io float PEv2.#.MaxAcceleration_mm_per_sec2 [8];	// Maximum axis acceleration (in mm/s�)
pin io float PEv2.#.MaxDecceleration_mm_per_sec2 [8];	// Maximum axis deceleration (in mm/s�)

	
pin in float PEv2.#.joint_vel_cmd [8];				
pin out float PEv2.#.joint_vel_fb [8];				
pin in float PEv2.#.joint_pos_cmd [8];				
pin out float PEv2.#.joint_pos_fb [8];				
    
//***********************************************************************
//[JOINT_n] information in HAL-INI 
pin in s32 PEv2.#.params.TYPE [8];			//LINEAR / ANGULAR
pin in float PEv2.#.params.HOME [8];
pin in float PEv2.#.params.FERROR [8];
pin in float PEv2.#.params.MIN_FERROR [8];
pin in float PEv2.#.params.MAX_VELOCITY [8];
pin in float PEv2.#.params.MAX_ACCELERATION [8];
pin in float PEv2.#.params.STEPGEN_MAXVEL [8];
pin in float PEv2.#.params.STEPGEN_MAXACCEL [8];
//pin in float PEv2.#.params.P [8];
//pin in float PEv2.#.params.I [8];
//pin in float PEv2.#.params.D [8];
//pin in float PEv2.#.params.FF0 [8];
//pin in float PEv2.#.params.FF1 [8];
//pin in float PEv2.#.params.FF2 [8];
//pin in float PEv2.#.params.BIAS [8];
pin in float PEv2.#.params.DEADBAND [8];
pin in float PEv2.#.params.MAX_OUTPUT [8];
pin in float PEv2.#.params.ENCODER_SCALE [8];
// these are in nanoseconds
pin in float PEv2.#.params.DIRSETUP [8] = 0;					// (ns)
pin in float PEv2.#.params.DIRHOLD [8] = 0;					// (ns)
pin in float PEv2.#.params.STEPLEN [8] = 0;					// (ns)
pin in float PEv2.#.params.STEPSPACE [8] = 0;					// (ns)
pin in float PEv2.#.params.STEP_SCALE [8] = 0;					// (pulses/mm)
pin in float PEv2.#.params.MIN_LIMIT [8] = 0;					// position (mm)
pin in float PEv2.#.params.MAX_LIMIT [8] = 0;					// position (mm)
pin in float PEv2.#.params.HOME_OFFSET [8] = 0;				// position (mm)
pin in float PEv2.#.params.HOME_SEARCH_VEL [8] = 0;			// position (mm)
pin in float PEv2.#.params.HOME_LATCH_VEL [8] = 0;				// position (mm)
pin in float PEv2.#.params.HOME_FINAL_VEL [8] = 0;				// position (mm)
pin in s32 PEv2.#.params.HOME_USE_INDEX [8] = 0;				// YES / NO
pin in s32 PEv2.#.params.HOME_IGNORE_LIMITS [8] = 0;			// YES / NO
//***********************************************************************

pin io u32 PEv2.#.MPGjogMultiplier [8];		// MPG jog multiplier value
pin io unsigned PEv2.#.MPGjogEncoder [8];			// MPG jog encoder ID

pin io unsigned PEv2.#.PinHomeSwitch [8];			// Home switch pin (0 for external dedicated input)
pin io unsigned PEv2.#.PinLimitMSwitch [8];			// Limit- switch pin (0 for external dedicated input)
pin io unsigned PEv2.#.PinLimitPSwitch [8];			// Limit+ switch pin (0 for external dedicated input)
pin io unsigned PEv2.#.AxisEnableOutputPins [8];		// Axis enabled output pin (0 for external dedicated output)

pin out bit PEv2.#.HomeSwitchStat [8];				// Home switch
pin out bit PEv2.#.LimitMSwitch [8];			// Limit- switch
pin out bit PEv2.#.LimitPSwitch [8];			// Limit+ switch
pin in bit PEv2.#.AxisEnableOutput [8];		// Axis enabled output
pin out bit PEv2.HomeSwitch;				// Home switch

pin io unsigned PEv2.#.HomeBackOffDistance [8];		// Back-off distance after homing
pin io unsigned PEv2.#.MPGjogDivider [8];			// Divider for the MPG jogging (enhanced encoder resolution)

pin io unsigned PEv2.PulseEngineEnabled;			// Pulse engine enabled status, also number of enabled axes
pin io unsigned PEv2.PulseGeneratorType;			// Pulse engine generator type (0: external, 1: internal 3ch)
pin io unsigned PEv2.ChargePumpEnabled;				// Charge pump output enabled
pin io unsigned PEv2.EmergencySwitchPolarity;		// Emergency switch polarity (set to 1 to invert)
pin io unsigned PEv2.PulseEngineActivated;			// Pulse engine activation status
pin out unsigned PEv2.#.LimitStatusP[8];					// Limit+ status (NOT bit-mapped)
pin out unsigned PEv2.#.LimitStatusN[8];					// Limit- status (NOT bit-mapped)
pin out unsigned PEv2.#.HomeStatus[8];					// Home status (NOT bit-mapped)
pin out unsigned PEv2.ErrorInputStatus;				// Stepper motor driver error inputs status (bit-mapped)
pin out unsigned PEv2.MiscInputStatus;				// Miscelenous digital inputs...
pin io unsigned PEv2.LimitOverride;					// Limit override status
pin io unsigned PEv2.LimitOverrideSetup;			// Limit override configuration
pin io unsigned PEv2.PulseEngineState;				// State of pulse engine - see ePoKeysPEState
pin io unsigned PEv2.AxisEnabledMask;				// Bit-mapped ouput enabled mask

pin io unsigned PEv2.EmergencyInputPin;
pin out bit PEv2.EmergencyInput;
pin io unsigned PEv2.EmergencyOutputPin;				//added in component only for estop-out to reset estop (if 0 EmergencyInput will be reused)
pin in bit PEv2.EmergencyOutput;

pin io unsigned PEv2.param1;
pin io unsigned PEv2.param2;
pin io unsigned PEv2.param3;
pin io unsigned PEv2.AxisEnabledStatesMask;		// Bit-mapped states, where axis enabled and charge pump signals are active
pin io unsigned PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration
pin out unsigned PEv2.#.SoftLimitStatus [8] ;				// Bit-mapped soft-limit statuses per axes
pin io unsigned PEv2.ExternalRelayOutputs;			// External relay outputs
pin io unsigned PEv2.ExternalOCOutputs;			// External open-collector outputs
pin io unsigned PEv2.PulseEngineBufferSize;		// Buffer size information...
pin io unsigned PEv2.motionBufferEntriesAccepted;
pin io unsigned PEv2.newMotionBufferEntries;
pin io unsigned PEv2.HomingStartMaskSetup;			// Bit-mapped axes indexes to be homed
pin io unsigned PEv2.ProbeStartMaskSetup;			// Bit-mapped axis indexes for probing
pin io unsigned PEv2.ProbeInput;					// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
pin io unsigned PEv2.ProbeInputPolarity;			// Probe input polarity
pin out unsigned PEv2.ProbeStatus;					// Probe status (probe completion bit-mapped status)
//pin out unsigned PEv2.MotionBuffer[448];			// Motion buffer
pin io float PEv2.ProbeSpeed;						// Probe speed (ratio of the maximum speed)
pin io unsigned PEv2.#.BacklashWidth [8];			// half of real backlash width
pin io unsigned PEv2.#.BacklashRegister [8];		// current value of the backlash register
pin io unsigned PEv2.#.BacklashAcceleration [8];	// in pulses per ms^2
pin io unsigned PEv2.BacklashCompensationEnabled;

pin out unsigned rtc.sec;
pin out unsigned rtc.min;
pin out unsigned rtc.hour;
pin out unsigned rtc.dow;
pin out unsigned rtc.dom;
pin out unsigned rtc.tmp;
pin out unsigned rtc.doy;
pin out unsigned rtc.month;
pin out unsigned rtc.year;
pin out unsigned rtc.loopcount;

pin out unsigned rtc.lastmin;
pin out unsigned rtc.lastsec;
pin out unsigned rtc.loop_frequ;

pin out unsigned Pins.#.DigitalCounterValue [55];
pin out unsigned Pins.#.AnalogValue [55];
pin out unsigned Pins.#.PinFunction [55];
pin out unsigned Pins.#.CounterOptions [55];
pin out bit Pins.#.DigitalValueGet [55];
pin in bit Pins.#.DigitalValueSet [55];
pin out unsigned Pins.#.DigitalCounterAvailable [55];
pin out unsigned Pins.#.MappingType [55];
pin out unsigned Pins.#.KeyCodeMacroID [55];
pin out unsigned Pins.#.KeyModifier [55];
pin out unsigned Pins.#.downKeyCodeMacroID [55];
pin out unsigned Pins.#.downKeyModifier [55];
pin out unsigned Pins.#.upKeyCodeMacroID [55];
pin out unsigned Pins.#.upKeyModifier [55];
pin out unsigned Pins.#.preventUpdate [55];

pin out unsigned MatrixKB.matrixKBconfiguration;		// Matrix keyboard configuration (set to 1 to enable matrix keyboard support)
pin out unsigned MatrixKB.matrixKBwidth;				// Matrix keyboard width (number of columns)
pin out unsigned MatrixKB.matrixKBheight;				// Matrix keyboard height (number of rows)
pin out unsigned MatrixKB.matrixKBcolumnsPins.#[8];		// List of matrix keyboard column connections
pin out unsigned MatrixKB.matrixKBrowsPins.#[16];			// List of matrix keyboard row connections
pin out unsigned MatrixKB.matrixKBvalues.#[128];			// Current state of each matrix keyboard key (assumes fixed width of 8 columns)

pin out unsigned Encoders.#.encoderValue [26];       // Encoder current value
pin io unsigned Encoders.#.encoderOptions [26];      // Encoder options -    bit 0: enable encoder
													//                      bit 1: 4x sampling
													//                      bit 2: 2x sampling
													//                      bit 3: reserved
													//                      bit 4: direct key mapping for direction A
													//                      bit 5: mapped to macro for direction A
													//                      bit 6: direct key mapping for direction B
													//                      bit 7: mapped to macro for direction B
pin io unsigned Encoders.#.channelApin [26];         // Channel A encoder pin
pin io unsigned Encoders.#.channelBpin [26];         // Channel B encoder pin

pin out u32 EasySensors.#.sensorValue [10];            // Current sensor value
pin out unsigned EasySensors.#.sensorType [10];             // Type of the sensor
pin out unsigned EasySensors.#.sensorRefreshPeriod [10];    // Refresh period in 0.1s
pin out unsigned EasySensors.#.sensorFailsafeConfig [10];   // Failsafe configuration (bits 0-5: timeout in seconds, bit 6: invalid=0, bit 7: invalid=0x7FFFFFFF)
pin out unsigned EasySensors.#.sensorReadingID [10];        // Sensor reading selection (see Protocol description document for details)

pin io unsigned PoStep.EnablePoStepCommunication;
    // Status
pin out unsigned PoStep.#.SupplyVoltage [8];
pin out unsigned PoStep.#.Temperature [8];
pin out unsigned PoStep.#.InputStatus [8];
pin out unsigned PoStep.#.DriverStatus [8];
pin out unsigned PoStep.#.FaultStatus [8];
pin out unsigned PoStep.#.UpdateState [8];

    // Settings
pin io unsigned PoStep.#.DriverMode [8];
pin io unsigned PoStep.#.StepMode [8];
pin io unsigned PoStep.#.Current_FS [8];
pin io unsigned PoStep.#.Current_Idle [8];
pin io unsigned PoStep.#.Current_Overheat [8];
pin io unsigned PoStep.#.TemperatureLimit [8];

    // Configuration
pin io unsigned PoStep.#.AddressI2C [8];
pin io unsigned PoStep.#.DriverType [8];
pin io unsigned PoStep.#.UpdateConfig [8];

pin io unsigned PWM.PWMperiod;
pin io unsigned PWM.#.PWMduty [6];
pin io unsigned PWM.#.PWMenabledChannels [6];
pin io unsigned PWM.#.PWMpinIDs [6];

pin io unsigned PoNET.moduleID;
pin io unsigned PoNET.i2cAddress;
pin io unsigned PoNET.moduleType;
pin io unsigned PoNET.moduleSize;
pin io unsigned PoNET.moduleOptions;
pin io unsigned PoNET.PWMduty;
pin io unsigned PoNET.lightValue;
pin io unsigned PoNET.PoNETstatus;
pin out unsigned PoNET.#.statusIn [16];
pin in unsigned PoNET.#.statusOut [16];

pin io unsigned MatrixLED.displayEnabled;                    // Display enabled byte - set to 1 to enable the display
pin io unsigned MatrixLED.rows;                              // Number of Matrix LED rows
pin io unsigned MatrixLED.columns;                           // Number of Matrix LED columns
pin io unsigned MatrixLED.RefreshFlag;                       // Flag for refreshing data - set to 1 to refresh the display
pin io unsigned MatrixLED.#.data [8];                           // Matrix LED buffer - one byte per row (assumes 8 columns)

pin io unsigned LCD.Configuration;                     // LCD configuration byte - 0: disabled, 1: enabled on primary pins, 2: enabled on secondary pins
pin io unsigned LCD.Rows;                              // Number of LCD module rows
pin io unsigned LCD.Columns;                           // Number of LCD module columns
pin io unsigned LCD.RowRefreshFlags;                   // Flag for refreshing data - bit 0: row 1, bit 1: row 2, bit 2: row 3, bit 3: row 4
    
pin io unsigned LCD.line1.# [20];                         // Line 1 buffer
pin io unsigned LCD.line2.# [20];                         // Line 2 buffer
pin io unsigned LCD.line3.# [20];                         // Line 3 buffer
pin io unsigned LCD.line4.# [20];                         // Line 4 buffer


license "GPL";

option extra_link_args "-lPoKeys";

;;

#include <unistd.h>   /* UNIX standard function definitions */
#include "PoKeysLib.h"




sPoKeysDevice * dev=0;
bool HAL_Machine_On = false;
bool setPkConfig = false;
bool setPinConfig = false;
unsigned Loop_Frequ =0;
int i=0;


int Config_PoNet()
{
	if(PK_PoNETGetPoNETStatus(dev) == PK_OK)
	{
				
	}
	if(PK_PoNETGetModuleSettings(dev) == PK_OK)
	{
				
	}
	return 0;
}

int Update_PoNet()
{
	if(PK_PoNETGetPoNETStatus(dev) == PK_OK)
	{
				
	}
	if(PK_PoNETGetModuleSettings(dev) == PK_OK)
	{
				
	}
	return 0;
}




// Pulse engine v2 information
typedef struct
{

	bool         SoftLimitStatus[8];           //soft-limit statuses per axes
	bool         AxisEnabledStates[8];     // Bit-mapped states, where axis enabled and charge pump signals are active
	uint8_t         AxisEnabledStatesMask;     // Bit-mapped states, where axis enabled and charge pump signals are active
	uint8_t         LimitOverride;             // Limit override status
	uint8_t         EmergencySwitchPolarity;   // Emergency switch polarity (set to 1 to invert)


	// Basic engine states
    uint8_t         PulseEngineEnabled;        // Pulse engine enabled status, also number of enabled axes
    uint8_t         PulseEngineActivated;      // Pulse engine activation status
    uint8_t         PulseEngineState;			 // State of pulse engine - see ePoKeysPEState
    uint8_t         ChargePumpEnabled;         // Charge pump output enabled
    uint8_t         PulseGeneratorType;        // Pulse engine generator type (0: external, 1: internal 3ch)

	// Switch states
    bool         LimitStatusP[8];              // Limit+ status (NOT bit-mapped)
    bool         LimitStatusN[8];              // Limit- status (NOT bit-mapped)
    bool         HomeStatus[8];                // Home status (bit-mapped)
	bool         EmergencyStatus;                // Home status 0=ok 1=Emergency

    uint8_t         AxesState[8];              // Axis states (bit-mapped) - see ePK_PEAxisState
    int32_t         CurrentPosition[8];        // Current position

	// Engine info
    uint8_t nrOfAxes;
    uint8_t maxPulseFrequency;
    uint8_t bufferDepth;
    uint8_t slotTiming;

	// Other inputs
    uint8_t         ErrorInputStatus;          // Stepper motor driver error inputs status (bit-mapped)
    uint8_t         MiscInputStatus;           // Miscelenous digital inputs...

	bool			DedicatedLimitNInputs[8];
	bool			DedicatedLimitPInputs[8];
	bool			DedicatedHomeInputs[8];

	uint8_t         ExternalRelayOutputs;      // External relay outputs
    uint8_t         ExternalOCOutputs;         // External open-collector outputs

	int32_t         PositionSetup[8];          // Position to be set as current position
    int32_t         ReferencePositionSpeed[8]; // Reference position or speed (position or pulses/s)
	
	// Cyclic Setting
	float			joint_vel_cmd[8];			// SetVelocity
	float			joint_pos_cmd[8];			// SetVelocity
	float			joint_vel_fb[8];			// GetVelocity
	float			joint_pos_fb[8];			// SetVelocity

	uint8_t         PulseEngineStateSetup;     // Pulse engine new state configuration
	uint8_t         LimitOverrideSetup;        // Limit override configuration

	bool         ExternalRelayOutput[8] ;      // External relay outputs
    bool         ExternalOCOutput[8];         // External open-collector outputs

} PK_PEv2_Stat;




typedef struct
{
// PK_PEv2_PulseEngineSetup   
    uint8_t         PulseEngineEnabled;        // Pulse engine enabled status, also number of enabled axes
    uint8_t         ChargePumpEnabled;         // Charge pump output enabled
    uint8_t         PulseGeneratorType;        // Pulse engine generator type (0: external, 1: internal 3ch)
    //dev->request[11] = dev->PEv2.PulseEngineBufferSize;
    uint8_t         EmergencySwitchPolarity;   // Emergency switch polarity (set to 1 to invert)
    //dev->request[13] = dev->PEv2.AxisEnabledStatesMask;
	
	
//PK_PEv2_AxisConfigurationGet
   // Read the structure
    uint8_t         AxesConfig[8];             // Axis configuration - see ePK_PEv2_AxisConfig
    uint8_t         AxesSwitchConfig[8];       // Axis switch configuration - see ePK_PEv2_AxisSwitchOptions

    uint8_t         PinHomeSwitch[8];          // Home switch pin (0 for external dedicated input)
    uint8_t         PinLimitMSwitch[8];        // Limit- switch pin (0 for external dedicated input)
    uint8_t         PinLimitPSwitch[8];        // Limit+ switch pin (0 for external dedicated input)

    uint8_t         HomingSpeed[8];            // Homing speed per axis (in %)
    uint8_t         HomingReturnSpeed[8];      // Homing return speed per axis (in % of the homing speed)

    uint8_t         MPGjogEncoder[8];          // MPG jog encoder ID

    // Convert parameters... assume little-endian format
    float           MaxSpeed[8];               // Maximum axis speed (in pulses per ms)
    float           MaxAcceleration[8];        // Maximum axis acceleration (in pulses/ms/ms)
    float           MaxDecceleration[8];       // Maximum axis deceleration (in pulses/ms/ms)

    int32_t         SoftLimitMaximum[8];       // Soft limit maximum position
    int32_t         SoftLimitMinimum[8];       // Soft limit minimum position

    int32_t         MPGjogMultiplier[8];       // MPG jog multiplier value

    uint8_t         AxisEnableOutputPins[8];   // Axis enabled output pin (0 for external dedicated output)
    int8_t          InvertAxisEnable[8];       // Invert axis enable signal

	uint8_t			FilterLimitMSwitch[8];	   // Digital filter for limit- switch
	uint8_t			FilterLimitPSwitch[8];	   // Digital filter for limit+ switch
	uint8_t			FilterHomeSwitch[8];	   // Digital filter for home switch

	uint8_t			HomingAlgorithm[8];		   // Homing algorithm configuration
	// MPG 1x mode here
	uint32_t		HomeBackOffDistance[8];	   // Back-off distance after homing
    uint16_t        MPGjogDivider[8];          // Divider for the MPG jogging (enhanced encoder resolution)

// 	uint16_t		BacklashWidth[8];			// half of real backlash width
	int16_t			BacklashRegister[8];		// current value of the backlash register
	uint8_t			BacklashAcceleration[8];	// in pulses per ms^2
	uint8_t			BacklashCompensationEnabled;

// add pins
    uint8_t         ProbeInput;                // Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
    uint8_t         ProbeInputPolarity;        // Probe input polarity

//int32_t PK_PEv2_AdditionalParametersGet(sPoKeysDevice * device)
//int32_t PK_PEv2_AdditionalParametersSet(sPoKeysDevice * device)
    uint8_t         EmergencyInputPin;
    uint8_t         EmergencyOutputPin;

// HAL-INI parameters
		bool ApplyIniSettings;
		char COORDINATES;
		char LINEAR_UNITS;
		char ANGULAR_UNITS;
		float CYCLE_TIME;
		float DEFAULT_LINEAR_VELOCITY;
		float MAX_LINEAR_VELOCITY;
		char TYPE [8];			//LINEAR / ANGULAR
		float HOME [8];
		float FERROR [8];
		float MIN_FERROR [8];
		float MAX_VELOCITY [8];
		float MAX_ACCELERATION [8];
		float STEPGEN_MAXVEL [8];
		float STEPGEN_MAXACCEL [8];
//		float P [8];
//		float I [8];
//		float D [8];
//		float FF0 [8];
//		float FF1 [8];
//		float FF2 [8];
//		float BIAS [8];
		float DEADBAND [8];
		float MAX_OUTPUT [8];
		float ENCODER_SCALE [8];
// these are in nanoseconds
		float DIRSETUP [8];					// (ns)
		float DIRHOLD [8];					// (ns)
		float STEPLEN [8];					// (ns)
		float STEPSPACE [8];					// (ns)
		float STEP_SCALE [8];					// (pulses/mm)
		float MIN_LIMIT [8];					// position (mm)
		float MAX_LIMIT [8];					// position (mm)
		float HOME_OFFSET [8];				// position (mm)
		float HOME_SEARCH_VEL [8];			// position (mm)
		float HOME_LATCH_VEL [8];				// position (mm)
		float HOME_FINAL_VEL [8];				// position (mm)
		bool HOME_USE_INDEX [8];				// YES / NO
		bool HOME_IGNORE_LIMITS [8];			// YES / NO
} PK_PEv2_Parameters;



PK_PEv2_Parameters PEv2_params;
PK_PEv2_Stat PEv2_status;

bool Get_BitOfByte(uint8_t in_Byte, int Bit_Id)
{
	return (in_Byte >> Bit_Id) & 1;
}

uint8_t Merge_8BitsToByte(bool Bit_array[8])
{
  uint8_t sum = 0;
  for (int i = 0; i < 8; i++)
  {
    sum += Bit_array[i] - '0';
    sum<<=1;
  }
  return sum;
}

PK_PEv2_Parameters GetConfig_PEv2(PK_PEv2_Parameters params)
{

	if ( params.ProbeInput!=0)
	{	//check if pin is parametrized in HAL
		dev->Pins[ params.ProbeInput-1].PinFunction = PK_PinCap_digitalInput;
		setPinConfig=true;
	}

	if (params.ApplyIniSettings!=0)
	{
		dev->PEv2.EmergencyInputPin = params.EmergencyInputPin;
		if ( params.EmergencyInputPin!=0)
		{	//check if pin is parametrized in HAL
			dev->Pins[params.EmergencyInputPin-1].PinFunction = PK_PinCap_digitalInput;
			setPinConfig=true;
		}
		if ( params.EmergencyOutputPin!=0)
		{	//check if pin is parametrized in HAL
			dev->Pins[ params.EmergencyOutputPin-1].PinFunction = PK_PinCap_digitalOutput;
			setPinConfig=true;
		}



		dev->PEv2.PulseEngineEnabled = params.PulseEngineEnabled;
		dev->PEv2.ChargePumpEnabled = params.ChargePumpEnabled;
		dev->PEv2.PulseGeneratorType = params.PulseGeneratorType;
		//dev->PEv2.PulseEngineBufferSize = params.PulseEngineBufferSize;
		dev->PEv2.EmergencySwitchPolarity = params.EmergencySwitchPolarity;
		//dev->PEv2.AxisEnabledStatesMask = params.AxisEnabledStatesMask;

		for (i = 0; i < dev->PEv2.info.nrOfAxes; i++)
		{
			// Read the structure
			dev->PEv2.AxesConfig[i] = params.AxesConfig[i];
			dev->PEv2.AxesSwitchConfig[i] = params.AxesSwitchConfig[i];

			dev->PEv2.PinHomeSwitch[i] = params.PinHomeSwitch[i];
			if ( params.PinHomeSwitch[i]!=0)
			{	//check if pin is parametrized in HAL
				dev->Pins[ params.PinHomeSwitch[i]-1].PinFunction = PK_PinCap_digitalInput;
				setPinConfig=true;
			}

			dev->PEv2.PinLimitMSwitch[i] = params.PinLimitMSwitch[i];
			if ( params.PinLimitMSwitch[i]!=0)
			{	//check if pin is parametrized in HAL
				dev->Pins[ params.PinLimitMSwitch[i]-1].PinFunction = PK_PinCap_digitalInput;
				setPinConfig=true;
			}

			dev->PEv2.PinLimitPSwitch[i] = params.PinLimitPSwitch[i];
			if ( params.PinLimitPSwitch[i]!=0)
			{	//check if pin is parametrized in HAL
				dev->Pins[ params.PinLimitPSwitch[i]-1].PinFunction = PK_PinCap_digitalInput;
				setPinConfig=true;
			}

			dev->PEv2.HomingSpeed[i] = params.HomingSpeed[i];
			dev->PEv2.HomingReturnSpeed[i] = params.HomingReturnSpeed[i];

			dev->PEv2.MPGjogEncoder[i] = params.MPGjogEncoder[i] = dev->response[15];

			// Convert parameters... assume little-endian format
			dev->PEv2.MaxSpeed[i] = params.MaxSpeed[i];
			dev->PEv2.MaxAcceleration[i] = params.MaxAcceleration[i];
			dev->PEv2.MaxDecceleration[i] = params.MaxDecceleration[i];

			dev->PEv2.SoftLimitMinimum[i] = params.SoftLimitMinimum[i];
			dev->PEv2.SoftLimitMaximum[i] = params.SoftLimitMaximum[i];

			dev->PEv2.MPGjogMultiplier[i] = params.MPGjogMultiplier[i];

			dev->PEv2.AxisEnableOutputPins[i] = params.AxisEnableOutputPins[i];
			if ( params.AxisEnableOutputPins[i]!=0)
			{	//check if pin is parametrized in HAL
				dev->Pins[ params.AxisEnableOutputPins[i]-1].PinFunction = PK_PinCap_digitalOutput;
				setPinConfig=true;
			}

			dev->PEv2.InvertAxisEnable[i] = params.InvertAxisEnable[i];

			dev->PEv2.FilterLimitMSwitch[i] = params.FilterLimitMSwitch[i];
			dev->PEv2.FilterLimitPSwitch[i] = params.FilterLimitPSwitch[i];
			dev->PEv2.FilterHomeSwitch[i] = params.FilterHomeSwitch[i];

			dev->PEv2.HomingAlgorithm[i] = params.HomingAlgorithm[i];
				// MPG 1x mode here
			dev->PEv2.HomeBackOffDistance[i] = params.HomeBackOffDistance[i];
			dev->PEv2.MPGjogDivider[i] = params.MPGjogDivider[i];	
			dev->PEv2.param1 = i;
			PK_PEv2_AxisConfigurationSet(dev);
		}

		/*
		params.PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
		params.ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
		params.PulseGeneratorType = dev->PEv2.PulseGeneratorType;
		params.PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
		params.EmergencySwitchPolarity = dev->PEv2.EmergencySwitchPolarity;
		params.AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
		PK_PEv2_PulseEngineSetup
		*/

		if (setPinConfig==true)
		{
			PK_PinConfigurationSet(dev);
			setPinConfig=false;
		}
	}
	else
	{
		params.PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
		params.ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
		params.PulseGeneratorType = dev->PEv2.PulseGeneratorType;
		//params.PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
		params.EmergencySwitchPolarity = dev->PEv2.EmergencySwitchPolarity;
		//params.AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;

		if(PK_PEv2_AdditionalParametersGet(dev) == PK_OK)
		{
			params.EmergencyInputPin = dev->PEv2.EmergencyInputPin;   
		}

		for (i = 0; i < dev->PEv2.info.nrOfAxes; i++)
		{
			dev->PEv2.param1 = i;
			if(PK_PEv2_AxisConfigurationGet(dev) == PK_OK)
			{
				// Read the structure
				params.AxesConfig[i] = dev->PEv2.AxesConfig[i];

				params.AxesSwitchConfig[i] = dev->PEv2.AxesSwitchConfig[i];

				params.PinHomeSwitch[i] = dev->PEv2.PinHomeSwitch[i];
				params.PinLimitMSwitch[i] = dev->PEv2.PinLimitMSwitch[i];
				params.PinLimitPSwitch[i] = dev->PEv2.PinLimitPSwitch[i];

				params.HomingSpeed[i] = dev->PEv2.HomingSpeed[i];
				params.HomingReturnSpeed[i] = dev->PEv2.HomingReturnSpeed[i];

				params.MPGjogEncoder[i] = dev->PEv2.MPGjogEncoder[i] = dev->response[15];

				// Convert parameters... assume little-endian format
				params.MaxSpeed[i] = dev->PEv2.MaxSpeed[i];
				params.MaxAcceleration[i] = dev->PEv2.MaxAcceleration[i];
				params.MaxDecceleration[i] = dev->PEv2.MaxDecceleration[i];

				params.SoftLimitMinimum[i] = dev->PEv2.SoftLimitMinimum[i];
				params.SoftLimitMaximum[i] = dev->PEv2.SoftLimitMaximum[i];

				params.MPGjogMultiplier[i] = dev->PEv2.MPGjogMultiplier[i];

				params.AxisEnableOutputPins[i] = dev->PEv2.AxisEnableOutputPins[i];
				params.InvertAxisEnable[i] = dev->PEv2.InvertAxisEnable[i];

				params.FilterLimitMSwitch[i] = dev->PEv2.FilterLimitMSwitch[i];
				params.FilterLimitPSwitch[i] = dev->PEv2.FilterLimitPSwitch[i];
				params.FilterHomeSwitch[i] = dev->PEv2.FilterHomeSwitch[i];

				params.HomingAlgorithm[i] = dev->PEv2.HomingAlgorithm[i];
				// MPG 1x mode here
				params.HomeBackOffDistance[i] = dev->PEv2.HomeBackOffDistance[i];
				params.MPGjogDivider[i] = dev->PEv2.MPGjogDivider[i];	
			}
		}

		params.PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
		params.ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
		params.PulseGeneratorType = dev->PEv2.PulseGeneratorType;
		//params.PulseEngineBufferSize = dev->PEv2.PulseEngineBufferSize;
		params.EmergencySwitchPolarity = dev->PEv2.EmergencySwitchPolarity;
		//params.AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
	}

	return params;
}

PK_PEv2_Stat Update_PEv2()
{
	uint8_t         bm_LimitStatusP;              // Limit+ status (bit-mapped)
	uint8_t         bm_LimitStatusN;              // Limit- status (bit-mapped)
	uint8_t         bm_HomeStatus;                // Home status (bit-mapped)
	uint8_t			bm_DedicatedLimitNInputs;
	uint8_t			bm_DedicatedLimitPInputs;
	uint8_t			bm_DedicatedHomeInputs;
	PK_PEv2_Stat status;

	if(PK_PEv2_StatusGet(dev) == PK_OK)
	{

		
		// Engine info
		status.nrOfAxes = dev->PEv2.info.nrOfAxes;
		status.maxPulseFrequency = dev->PEv2.info.maxPulseFrequency;
		status.bufferDepth = dev->PEv2.info.bufferDepth;
		status.slotTiming = dev->PEv2.info.slotTiming;
		
		status.AxisEnabledStatesMask = dev->PEv2.AxisEnabledStatesMask;
		status.LimitOverride = dev->PEv2.LimitOverride;
		
		// Basic engine states
		status.PulseEngineEnabled = dev->PEv2.PulseEngineEnabled;
		status.PulseEngineActivated = dev->PEv2.PulseEngineActivated;
		status.PulseEngineState = dev->PEv2.PulseEngineState;
		status.ChargePumpEnabled = dev->PEv2.ChargePumpEnabled;
		status.PulseGeneratorType = dev->PEv2.PulseGeneratorType;

		// Switch states
		bm_LimitStatusP = dev->PEv2.LimitStatusP;              // Limit+ status (bit-mapped)
		bm_LimitStatusN = dev->PEv2.LimitStatusN;              // Limit- status (bit-mapped)
		bm_HomeStatus = dev->PEv2.HomeStatus;                // Home status (bit-mapped)

		status.EmergencySwitchPolarity = dev->PEv2.EmergencySwitchPolarity;

		// Other inputs
		status.ErrorInputStatus = dev->PEv2.ErrorInputStatus;
		status.MiscInputStatus = dev->PEv2.MiscInputStatus;
		
		if(HAL_Machine_On==true)
		{
			dev->PEv2.PulseEngineStateSetup = PK_PEState_peRUNNING;
		}
		else
		{
			dev->PEv2.PulseEngineStateSetup = PK_PEState_peSTOPPED;
		}

		switch (status.PulseEngineState)
		{
		    case PK_PEState_peSTOPPED:           // Pulse engine is stopped
				break;
		    casePK_PEState_peINTERNAL:           // PEv1: Internal motion controller is in use, PEv2: not used
				break;
		    casePK_PEState_peBUFFER:           // PEv1: Buffered operation mode is in use, PEv2: not used
				break;
		    casePK_PEState_peRUNNING:           // Pulse engine is activated
				break;
		    casePK_PEState_peJOGGING:          // Jogging mode enabled
				break;
		    casePK_PEState_peSTOPPING:          // Pulse engine is stopping
				break;
		    casePK_PEState_peHOME:          // All axes are homed
				break;
		    casePK_PEState_peHOMING:          // Axes homing is in progress
				break;
		    casePK_PEState_pePROBECOMPLETE:          // All axes are homed
				break;
		    casePK_PEState_pePROBE:          // Axes probing is in progress
				break;
		    casePK_PEState_pePROBEERROR:          // Error occured during probing

				break;
		    casePK_PEState_peHYBRIDPROBE_STOPPING:
				if(HAL_Machine_On==false)
				{
					dev->PEv2.PulseEngineStateSetup = PK_PEState_peSTOPPED;
					dev->PEv2.LimitOverrideSetup = 0;
					dev->PEv2.AxisEnabledMask = 0;
					PK_PEv2_PulseEngineStateSet(dev);

					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peHYBRIDPROBE_COMPLETE:
				if(HAL_Machine_On==false)
				{
					dev->PEv2.PulseEngineStateSetup = PK_PEState_peSTOPPED;
					dev->PEv2.LimitOverrideSetup = 0;
					dev->PEv2.AxisEnabledMask = 0;
					PK_PEv2_PulseEngineStateSet(dev);

					PK_PEv2_PulseEngineStateSet(dev);
				}
				break;
		    casePK_PEState_peSTOP_LIMIT:         // Pulse engine stopped due to limit reached
				break;
		    casePK_PEState_peSTOP_EMERGENCY:          // Pulse engine stopped due to emergency switch
				break;
		}
		
	}

	if(dev->PEv2.PulseEngineStateSetup != status.PulseEngineState)
	{

		PK_PEv2_PulseEngineStateSet(dev);
		PK_PEv2_PulseEngineStateSet(dev);
	}

	if(PK_PEv2_Status2Get(dev) == PK_OK)
	{
		bm_DedicatedLimitNInputs = dev->PEv2.DedicatedLimitNInputs;
		bm_DedicatedLimitPInputs = dev->PEv2.DedicatedLimitPInputs;
		bm_DedicatedHomeInputs = dev->PEv2.DedicatedHomeInputs;
	}

	bool doPositionSet = false;
	bool doMove = false;
	if (status.nrOfAxes!=0)
	{
		for (i = 0; i < status.nrOfAxes; i++)
		{
			status.AxesState[i] = dev->PEv2.AxesState[i];
			status.CurrentPosition[i] = dev->PEv2.CurrentPosition[i];

			status.LimitStatusP[i] = Get_BitOfByte(bm_LimitStatusP,i);
			status.LimitStatusN[i] = Get_BitOfByte(bm_LimitStatusN,i);
			status.HomeStatus[i] =  Get_BitOfByte(bm_HomeStatus,i);

			status.DedicatedLimitNInputs[i] =  Get_BitOfByte(bm_DedicatedLimitNInputs,i);
			status.DedicatedLimitPInputs[i] =  Get_BitOfByte(bm_DedicatedLimitPInputs,i);
			status.DedicatedHomeInputs[i] =  Get_BitOfByte(bm_DedicatedHomeInputs,i);

			uint8_t  bm_SoftLimitStatus = dev->PEv2.SoftLimitStatus;
			status.SoftLimitStatus[i] = Get_BitOfByte(dev->PEv2.SoftLimitStatus,i);

			switch( status.AxesState[i])
			{
				case PK_PEAxisState_axSTOPPED:        // Axis is stopped


					break ;
				case PK_PEAxisState_axREADY:        // Axis ready


					break ;
				case PK_PEAxisState_axRUNNING:        // Axis is running
		
					if ( PEv2_params.AxesConfig[i]!=PK_AC_POSITION_MODE)
					{
						if(status.ReferencePositionSpeed[i] != status.joint_vel_cmd[i] * PEv2_params.STEP_SCALE[i])
						{
							status.ReferencePositionSpeed[i] = status.joint_vel_cmd[i] * PEv2_params.STEP_SCALE[i];
							status.PositionSetup[i] = status.joint_pos_cmd[i] * PEv2_params.STEP_SCALE[i];

							doMove=true;
							dev->PEv2.ReferencePositionSpeed[i] = status.ReferencePositionSpeed[i];
							dev->PEv2.PositionSetup[i] = status.PositionSetup[i];
						}
					}
					else
					{

						if ((status.CurrentPosition[i] - status.ReferencePositionSpeed[i]) < 10 )
						{
							status.ReferencePositionSpeed[i] = status.joint_pos_cmd[i] * PEv2_params.STEP_SCALE[i];
							dev->PEv2.ReferencePositionSpeed[i] = status.ReferencePositionSpeed[i];
							dev->PEv2.PositionSetup[i] = status.PositionSetup[i];
							//doPositionSet =true;
							doMove=true;
						}
					}
					// calculate actual velocity by position difference (time estimated by actual rtc_loop_frequ [Hz] / [1/sec] )
					status.joint_vel_fb[i] = ( status.joint_pos_fb[i] - (status.CurrentPosition[i] / PEv2_params.STEP_SCALE[i]) )* Loop_Frequ;
					status.joint_pos_fb[i] = dev->PEv2.CurrentPosition[i] / PEv2_params.STEP_SCALE[i];

					break ;
				case PK_PEAxisState_axHOMING_RESETTING:   // Stopping the axis to reset the position counters
					break ;
				case PK_PEAxisState_axHOMING_BACKING_OFF:   // Backing off switch
					break ;
				case PK_PEAxisState_axHOME:       // Axis is homed
				// PEv2_joint_
					break ;
				case PK_PEAxisState_axHOMINGSTART:       // Homing procedure is starting on axis
					break ;
				case PK_PEAxisState_axHOMINGSEARCH:       // Homing procedure first step - going to home
					break ;
				case PK_PEAxisState_axHOMINGBACK:       // Homing procedure second step - slow homing
					break ;
				case PK_PEAxisState_axPROBED:       // Probing completed for this axis
					break ;
				case PK_PEAxisState_axPROBESTART:       // Probing procedure is starting on axis
					break ;
				case PK_PEAxisState_axPROBESEARCH:       // Probing procedure - probing
					break ;
				case PK_PEAxisState_axERROR:       // Axis error
					break ;
				case PK_PEAxisState_axLIMIT:        // Axis limit tripped
					break ;
				default:
					break ;
			}
		}
	}


	if(PK_PEv2_ExternalOutputsGet(dev) == PK_OK)
	{
		bool RelBit_array[8];
		bool OcBit_array[8];


		uint8_t ExternalRelayOutputs_set=  Merge_8BitsToByte(status.ExternalRelayOutput);
		uint8_t ExternalOCOutputs_set=  Merge_8BitsToByte(status.ExternalOCOutput);
		bool doSetExtOut = false;

		status.ExternalRelayOutputs = dev->PEv2.ExternalRelayOutputs;
		status.ExternalOCOutputs = dev->PEv2.ExternalOCOutputs;

		if (status.ExternalRelayOutputs != ExternalRelayOutputs_set)
		{
			dev->PEv2.ExternalRelayOutputs = ExternalRelayOutputs_set;
			doSetExtOut=true;
		}
		if (status.ExternalOCOutputs != ExternalOCOutputs_set)
		{
			dev->PEv2.ExternalOCOutputs = ExternalOCOutputs_set;
			doSetExtOut=true;
		}
		if (doSetExtOut==true)
		{
			PK_PEv2_ExternalOutputsSet(dev);
		}

	}

	if (status.PulseEngineState != status.PulseEngineStateSetup)
	{

		dev->PEv2.PulseEngineStateSetup = status.PulseEngineStateSetup;
		dev->PEv2.LimitOverrideSetup = 0;
		dev->PEv2.AxisEnabledMask = 0;

		PK_PEv2_PulseEngineStateSet(dev);
	}

	if (doMove==true)
	{
		PK_PEv2_PulseEngineMove(dev);
	}

	
	//PK_PEv2_PositionSet
	return status;
}

int Config_MatrixKB()
{
	if(PK_MatrixKBConfigurationGet(dev) == PK_OK)
	{
	/*
			dev->matrixKB.matrixKBconfiguration = dev->response[8];
			dev->matrixKB.matrixKBheight = 1 + (dev->response[9] & 0x0F);
			dev->matrixKB.matrixKBwidth = 1 + ((dev->response[9] >> 4) & 0x0F);

			for (n = 0; n < 8; n++)
			{
				dev->matrixKB.matrixKBrowsPins[n] = dev->response[10 + n];
				dev->matrixKB.matrixKBrowsPins[8 + n] = dev->response[42 + n];

				dev->matrixKB.matrixKBcolumnsPins[n] = dev->response[18 + n];
			}

			for (n = 0; n < 128; n++)
			{
				dev->matrixKB.macroMappingOptions[n] = ((dev->response[26 + n / 8] & (1 << (n % 8))) > 0) ? 1 : 0;
			}
	*/
	}

	//PK_MatrixKBConfigurationSet
	return 0;
}

int Update_MatrixKB()
{
	if(PK_MatrixKBStatusGet(dev) == PK_OK)
	{
	/*
	for (n = 0; n < 128; n++)
            {
				dev->matrixKB.matrixKBvalues[n];
            }
	*/
	}
	return 0;
}

int Config_LCD()
{
	if(PK_LCDConfigurationGet(dev) == PK_OK)
	{
	}

	//PK_LCDConfigurationSet
	// Change between modes PK_LCD_MODE_DIRECT and PK_LCD_MODE_BUFFERED
	// PK_LCDChangeMode(dev, PK_LCD_MODE_DIRECT);
	return 0;
}

int Update_LCD()
{
	if(PK_LCDUpdate(dev) == PK_OK)
	{
	}
	if(PK_LCDSetCustomCharacters(dev) == PK_OK)
	{
	}
	return 0;
}

int Config_EasySensors()
{
	if(PK_EasySensorsSetupGet(dev) == PK_OK)
	{
	}

	//PK_EasySensorsSetupSet
	return 0;
}

int Update_EasySensors()
{
	if(PK_EasySensorsValueGetAll(dev) == PK_OK)
	{
	}
	return 0;
}


int Config_PoStep()
{
	if(PK_PoStep_ConfigurationGet(dev) == PK_OK)
	{
	}

	if(PK_PoStep_DriverConfigurationGet(dev) == PK_OK)
	{
	}

	//PK_PoStep_ConfigurationSet(dev)
	//PK_PoStep_DriverConfigurationSet(dev)
	return 0;
}

int Update_PoStep()
{
	if(PK_PoStep_StatusGet(dev) == PK_OK)
	{
	}
	return 0;
}





void user_mainloop(void) 
{ 


    while(0xb){
       FOR_ALL_INSTS() {
	   rtc_loopcount++;
	   a_debout = 100;
	 while(dev == NULL)
	 {
			HAL_Machine_On = machine_is_on;
			Loop_Frequ = rtc_loop_frequ;
		 if (devSerial!=0 )
		 {
				a_debout = 110;
				enum_usb_dev = PK_EnumerateUSBDevices();
				a_debout = 111;
				if (enum_usb_dev != 0)
				{
				dev = PK_ConnectToDeviceWSerial(devSerial, 5000);  //waits for usb device
				}
				
				a_debout = 112;
				if (dev == NULL)
				{
					a_debout = 113;
					dev = PK_ConnectToDeviceWSerial_UDP(devSerial, 5000);  //waits for usb device
				}

		 }
		else
		{
			a_debout = 114;
			sPoKeysNetworkDeviceSummary *udp_devices;
			enum_usb_dev = PK_EnumerateUSBDevices();
			enum_fusb_dev = PK_EnumerateUSBDevices();
			//enum_udp_dev = PK_EnumerateNetworkDevices(udp_devices,180); // does not work - it hangs here

		}

		if(dev != NULL)
		{
			a_debout = 121;
			connected=1;

			 info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
			 info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
			 info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
			 info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
			 info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
			 info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
			 info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
			 info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
			 info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
			 info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
			 info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
			 info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
			 info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
			 info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
			 info_Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
			 info_MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
			 info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
			 info_LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
			 info_MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
			 info_ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
			 info_PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
			 info_PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
			 info_AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
			 info_InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
			 info_protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
			 info_prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
			 info_AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
			 info_LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
			 info_CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
			 info_PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
			 info_SensorList = dev->info.iSensorList;                      // Device supports sensor lists
			 info_WebInterface = dev->info.iWebInterface;                    // Device supports web interface
			 info_FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
			 info_JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
			 info_PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
			 info_PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
			 info_EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors

			 a_debout = 122;
			 if ( info_PinCount!=0 )
			 {
				a_debout = 123;

			 }
			 a_debout = 124;
			 if ( info_PulseEnginev2!=0 )
			 {
				//***************************************************************************
				// Setting Parameters from INI
				PEv2_params.ApplyIniSettings =PEv2_params_ApplyIniSettings;
				PEv2_params.COORDINATES = PEv2_params_COORDINATES;
				PEv2_params.LINEAR_UNITS = PEv2_params_LINEAR_UNITS;
				PEv2_params.ANGULAR_UNITS = PEv2_params_ANGULAR_UNITS;
				PEv2_params.CYCLE_TIME = PEv2_params_CYCLE_TIME;
				PEv2_params.DEFAULT_LINEAR_VELOCITY = PEv2_params_DEFAULT_LINEAR_VELOCITY;
				PEv2_params.MAX_LINEAR_VELOCITY = PEv2_params_MAX_LINEAR_VELOCITY;
				for(i=0;i< PEv2_nrOfAxes;i++)
				{
					PEv2_params.TYPE[i] = PEv2_params_TYPE(i);			//LINEAR / ANGULAR
					PEv2_params.HOME[i] = PEv2_params_HOME(i);
					PEv2_params.FERROR[i] = PEv2_params_FERROR(i);
					PEv2_params.MIN_FERROR[i] = PEv2_params_MIN_FERROR(i);
					PEv2_params.MAX_VELOCITY[i] = PEv2_params_MAX_VELOCITY(i);
					PEv2_params.STEPGEN_MAXVEL[i] = PEv2_params_MAX_ACCELERATION(i);
					PEv2_params.STEPGEN_MAXVEL[i] = PEv2_params_STEPGEN_MAXVEL(i);
					PEv2_params.STEPGEN_MAXACCEL[i] = PEv2_params_STEPGEN_MAXACCEL(i);
					//		float P(i);
					//		float I(i);
					//		float D(i);
					//		float FF0(i);
					//		float FF1(i);
					//		float FF2(i);
					//		float BIAS(i);
					PEv2_params.DEADBAND[i] = PEv2_params_DEADBAND(i);
					PEv2_params.MAX_OUTPUT[i] = PEv2_params_MAX_OUTPUT(i);
					PEv2_params.ENCODER_SCALE[i] = PEv2_params_ENCODER_SCALE(i);
					// these are in nanoseconds
					PEv2_params.DIRSETUP[i] = PEv2_params_DIRSETUP(i);					// (ns)
					PEv2_params.DIRHOLD[i] = PEv2_params_DIRHOLD(i);					// (ns)
					PEv2_params.STEPLEN[i] = PEv2_params_STEPLEN(i);					// (ns)
					PEv2_params.STEPSPACE[i] = PEv2_params_STEPSPACE(i);					// (ns)
					PEv2_params.STEP_SCALE[i] = PEv2_params_STEP_SCALE(i);					// (pulses/mm)
					PEv2_params.MIN_LIMIT[i] = PEv2_params_MIN_LIMIT(i);					// position (mm)
					PEv2_params.MAX_LIMIT[i] = PEv2_params_MAX_LIMIT(i);					// position (mm)
					PEv2_params.HOME_OFFSET[i] = PEv2_params_HOME_OFFSET(i);				// position (mm)
					PEv2_params.HOME_SEARCH_VEL[i] = PEv2_params_HOME_SEARCH_VEL(i);			// position (mm)
					PEv2_params.HOME_FINAL_VEL[i] = PEv2_params_HOME_FINAL_VEL(i);				// position (mm)
					PEv2_params.HOME_FINAL_VEL[i] = PEv2_params_HOME_FINAL_VEL(i);				// position (mm)
					PEv2_params.HOME_USE_INDEX[i] = PEv2_params_HOME_USE_INDEX(i);				// YES / NO
					PEv2_params.HOME_IGNORE_LIMITS[i] = PEv2_params_HOME_IGNORE_LIMITS(i);			// YES / NO
				}
				

				PEv2_params = GetConfig_PEv2(PEv2_params);
				// PK_PEv2_PulseEngineSetup   
				PEv2_PulseEngineEnabled=PEv2_status.PulseEngineEnabled;        // Pulse engine enabled status, also number of enabled axes
				PEv2_ChargePumpEnabled=PEv2_status.ChargePumpEnabled;         // Charge pump output enabled
				PEv2_PulseGeneratorType=PEv2_status.PulseGeneratorType;        // Pulse engine generator type (0: external, 1: internal 3ch)
				//dev->request[11] = dev->PEv2.PulseEngineBufferSize;
				PEv2_EmergencySwitchPolarity=PEv2_status.EmergencySwitchPolarity;   // Emergency switch polarity (set to 1 to invert)
				//dev->request[13] = dev->PEv2.AxisEnabledStatesMask;

				//PK_PEv2_AxisConfigurationGet
				PEv2_BacklashCompensationEnabled=PEv2_params.BacklashCompensationEnabled;
				for(i=0;i< PEv2_nrOfAxes;i++)
				{
					// Read the structure
						PEv2_AxesConfig(i) = PEv2_params.AxesConfig[i];             // Axis configuration - see ePK_PEv2_AxisConfig
						//PEv2_AxesSwitchConfig(i) = PEv2_params.AxesSwitchConfig[i];       // Axis switch configuration - see ePK_PEv2_AxisSwitchOptions

						PEv2_PinHomeSwitch(i) = PEv2_params.PinHomeSwitch[i];          // Home switch pin (0 for external dedicated input)
						PEv2_PinLimitMSwitch(i) = PEv2_params.PinLimitMSwitch[i];        // Limit- switch pin (0 for external dedicated input)
						PEv2_PinLimitPSwitch(i) = PEv2_params.PinLimitPSwitch[i];        // Limit+ switch pin (0 for external dedicated input)

						PEv2_HomingSpeed(i) = PEv2_params.HomingSpeed[i];            // Homing speed per axis (in %)
						PEv2_HomingReturnSpeed(i) = PEv2_params.HomingReturnSpeed[i];      // Homing return speed per axis (in % of the homing speed)

						PEv2_MPGjogEncoder(i) = PEv2_params.MPGjogEncoder[i];          // MPG jog encoder ID

						// Convert parameters... assume little-endian format
						PEv2_MaxSpeed(i) = PEv2_params.MaxSpeed[i];               // Maximum axis speed (in pulses per ms)
						PEv2_MaxAcceleration(i) = PEv2_params.MaxAcceleration[i];        // Maximum axis acceleration (in pulses/ms/ms)
						PEv2_MaxDecceleration(i) = PEv2_params.MaxDecceleration[i];       // Maximum axis deceleration (in pulses/ms/ms)

						PEv2_SoftLimitMaximum(i) = PEv2_params.SoftLimitMaximum[i];       // Soft limit maximum position
						PEv2_SoftLimitMinimum(i) = PEv2_params.SoftLimitMinimum[i];       // Soft limit minimum position

						PEv2_MPGjogMultiplier(i) = PEv2_params.MPGjogMultiplier[i];       // MPG jog multiplier value

						PEv2_AxisEnableOutputPins(i) = PEv2_params.AxisEnableOutputPins[i];   // Axis enabled output pin (0 for external dedicated output)
						PEv2_InvertAxisEnable(i) = PEv2_params.InvertAxisEnable[i];       // Invert axis enable signal

						PEv2_FilterLimitMSwitch(i) = PEv2_params.FilterLimitMSwitch[i];	   // Digital filter for limit- switch
						PEv2_FilterLimitPSwitch(i) = PEv2_params.FilterLimitPSwitch[i];	   // Digital filter for limit+ switch
						PEv2_FilterHomeSwitch(i) = PEv2_params.FilterHomeSwitch[i];	   // Digital filter for home switch

						PEv2_HomingAlgorithm(i) = PEv2_params.HomingAlgorithm[i];		   // Homing algorithm configuration
						// MPG 1x mode here
						PEv2_HomeBackOffDistance(i) = PEv2_params.HomeBackOffDistance[i];	   // Back-off distance after homing
						PEv2_MPGjogDivider(i) = PEv2_params.MPGjogDivider[i];          // Divider for the MPG jogging (enhanced encoder resolution)

					// 	PEv2_BacklashWidth(i) = PEv2_params.BacklashWidth[i];			// half of real backlash width
						PEv2_BacklashRegister(i) = PEv2_params.BacklashRegister[i];		// current value of the backlash register
						PEv2_BacklashAcceleration(i) = PEv2_params.BacklashAcceleration[i];	// in pulses per ms^2
				}
			
				PEv2_nrOfAxes=PEv2_status.nrOfAxes;
				PEv2_maxPulseFrequency=PEv2_status.maxPulseFrequency;
				PEv2_bufferDepth=PEv2_status.bufferDepth;
				PEv2_slotTiming=PEv2_status.slotTiming;
		
				bool setPeConfig = false;
				PEv2_EmergencyInputPin = PEv2_params.EmergencyInputPin;

				// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
				//check if pin is parametrized in HAL
				dev->PEv2.ProbeInput= PEv2_ProbeInput;
				//check if pin is parametrized in HAL
				dev->PEv2.ProbeInputPolarity= PEv2_ProbeInputPolarity;
				a_debout = 133;

				a_debout = 134;
				dev->PEv2.PulseEngineEnabled=8; //Enable 8 axes
				dev->PEv2.PulseEngineActivated=true;
				dev->PEv2.AxisEnabledStatesMask=0; //Disable axis power when not in Running state
				PK_PEv2_PulseEngineSetup(dev);
				
				for(i=0;i< PEv2_nrOfAxes;i++)
				{
					a_debout = 1310 + 1;
					if(PEv2_params_STEP_SCALE(i)!=0)
					{
						
						if ( PEv2_AxesConfig(i)!=PK_AC_POSITION_MODE)
						{
							a_debout = 130 + 1;
							dev->PEv2.ReferencePositionSpeed[i] = PEv2_joint_vel_cmd(i) * PEv2_params_STEP_SCALE(i);

							PEv2_joint_vel_fb(i) = dev->PEv2.PositionSetup[i] / PEv2_params_STEP_SCALE(i);
							PEv2_joint_pos_fb(i) = dev->PEv2.CurrentPosition[i] / PEv2_params_STEP_SCALE(i);
						}
						else
						{
							a_debout = 1320 + 1;
							dev->PEv2.ReferencePositionSpeed[i] = PEv2_joint_pos_cmd(i) * PEv2_params_STEP_SCALE(i);
							PEv2_joint_vel_fb(i) = dev->PEv2.PositionSetup[i] / PEv2_params_STEP_SCALE(i);
							PEv2_joint_pos_fb(i) = dev->PEv2.CurrentPosition[i] / PEv2_params_STEP_SCALE(i);
						}
						a_debout = 1330 + 1;
						dev->PEv2.MaxSpeed[i] = PEv2_params_STEPGEN_MAXVEL(i)* PEv2_params_STEP_SCALE(i)/1000;					// Maximum axis speed convert (mm/s) to (pulses per ms)
						dev->PEv2.MaxAcceleration[i] = PEv2_params_STEPGEN_MAXVEL(i)* PEv2_params_STEP_SCALE(i) /1000000;			// Maximum axis acceleration convert (mm/s�) to (in pulses/ms/ms)
						dev->PEv2.MaxDecceleration[i] = PEv2_params_STEPGEN_MAXVEL(i)* PEv2_params_STEP_SCALE(i) /1000000;			// Maximum axis deceleration convert (mm/s�) to (in pulses/ms/ms)

						dev->PEv2.SoftLimitMaximum[i] = PEv2_params_MAX_LIMIT(i)* PEv2_params_STEP_SCALE(i);		// Soft limit maximum position
						dev->PEv2.SoftLimitMinimum[i] = PEv2_params_MIN_LIMIT(i)* PEv2_params_STEP_SCALE(i);		// Soft limit minimum position
						dev->PEv2.HomeOffsets[i] = PEv2_params_HOME_OFFSET(i)* PEv2_params_STEP_SCALE(i);				// Home position offset

						dev->PEv2.HomingSpeed[i] = PEv2_params_HOME_SEARCH_VEL(i)*100/ PEv2_params_MAX_VELOCITY(i) ;			// Homing speed per axis (in %)
						dev->PEv2.HomingReturnSpeed[i] = PEv2_params_HOME_LATCH_VEL(i)*100/ PEv2_params_HOME_SEARCH_VEL(i);		// Homing return speed per axis (in % of the homing speed)

						dev->PEv2.AxesSwitchConfig[i]= PEv2_AxesSwitchConfig(i);
						dev->PEv2.FilterLimitMSwitch[i]= PEv2_FilterLimitMSwitch(i);		// Digital filter for limit- switch
						dev->PEv2.FilterLimitPSwitch[i]= PEv2_FilterLimitPSwitch(i);		// Digital filter for limit+ switch
						dev->PEv2.FilterHomeSwitch[i]= PEv2_FilterHomeSwitch(i);		// Digital filter for home switch

						// Limit- switch pin (0 for external dedicated input)
						dev->PEv2.PinLimitMSwitch[i]= PEv2_PinLimitMSwitch(i);

						// Limit+ switch pin (0 for external dedicated input)
						dev->PEv2.PinLimitPSwitch[i]= PEv2_PinLimitPSwitch(i);

						if ( PEv2_PinLimitPSwitch(i)!=0)
						{	//check if pin is parametrized in HAL
							dev->Pins[ PEv2_PinLimitPSwitch(i)-1].PinFunction = PK_PinCap_digitalInput;
							setPinConfig=true;
						}
						if ( PEv2_PinLimitPSwitch(i)!=0)
						{	//check if pin is parametrized in HAL
							dev->Pins[ PEv2_PinLimitPSwitch(i)-1].PinFunction = PK_PinCap_digitalInput;
							setPinConfig=true;
						}
						a_debout = 1350 + 1;

						dev->PEv2.param1 = i;
						PK_PEv2_AxisConfigurationSet(dev);
					}
				}

				a_debout = 136;
			 }
			
			if (info_MatrixKeyboard!=0)
			{
				dev->matrixKB.matrixKBconfiguration = 1;
			}

			 if (setPinConfig==true)
			 {
				a_debout = 140;
				PK_PinConfigurationSet(dev);
				setPinConfig = false;
			 }
			 if (info_PoNET!=0)
			 {
				Config_PoNet;
			 }
			 

			 //dev->DeviceData.DeviceLockStatus=1;
			 PK_SaveConfiguration(dev);
			 a_debout = 141;
		}
		else
		{
			connected=0;
			err=1;
		}
		usleep(40000);
	 }
	 alive=1; 

	 a_debout = 200;
	 // RTC
	if (PK_RTCGet(dev) == PK_OK)
	{
		a_debout = 210;
		rtc_sec=dev->RTC.SEC;
		rtc_min=dev->RTC.MIN;
		rtc_hour=dev->RTC.HOUR;
		rtc_dow=dev->RTC.DOW;
		rtc_dom=dev->RTC.DOM;
		rtc_tmp=dev->RTC.tmp;
		rtc_doy=dev->RTC.DOY;
		rtc_month=dev->RTC.MONTH;
		rtc_year=dev->RTC.YEAR;

		if (rtc_lastsec!=rtc_sec)
		{
			a_debout = 211;
			rtc_loop_frequ=rtc_loopcount;
			rtc_loopcount=0;
			rtc_lastsec=rtc_sec;

				
		}
		a_debout = 212;
	}

	// PulseEnginev2
	if (info_PulseEnginev2!=0)
	{
		a_debout = 220;
		PEv2_status = Update_PEv2(PEv2_status);
		if (0==0)
		{
			a_debout = 221;
			// Engine info
			PEv2_nrOfAxes = PEv2_status.nrOfAxes;
			PEv2_maxPulseFrequency = PEv2_status.maxPulseFrequency;
			PEv2_bufferDepth = PEv2_status.bufferDepth;
			PEv2_slotTiming = PEv2_status.slotTiming;
	
			PEv2_AxisEnabledStatesMask = PEv2_status.AxisEnabledStatesMask;
			PEv2_LimitOverride = PEv2_status.LimitOverride;

			// Basic engine states
			PEv2_PulseEngineEnabled = PEv2_status.PulseEngineEnabled;
			PEv2_PulseEngineActivated = PEv2_status.PulseEngineActivated;
			PEv2_PulseEngineState = PEv2_status.PulseEngineState;
			PEv2_ChargePumpEnabled = PEv2_status.ChargePumpEnabled;
			PEv2_PulseGeneratorType = PEv2_status.PulseGeneratorType;
       
			PEv2_EmergencySwitchPolarity = PEv2_status.EmergencySwitchPolarity;

			// Other inputs
			PEv2_ErrorInputStatus = PEv2_status.ErrorInputStatus;
			PEv2_MiscInputStatus = PEv2_status.MiscInputStatus;
			a_debout = 222;
			for (i = 0; i < PEv2_nrOfAxes; i++)
			{
				a_debout = 2220 + i;
				PEv2_AxesState(i) = PEv2_status.AxesState[i];
				PEv2_CurrentPosition(i) = PEv2_status.CurrentPosition[i];

				PEv2_LimitStatusP(i) = PEv2_status.LimitStatusP[i];			// Limit+ status 
				PEv2_LimitStatusN(i) = PEv2_status.LimitStatusN[i];	// Limit- status 
				PEv2_HomeStatus(i) = PEv2_status.HomeStatus[i];		// Home status 

				//PEv2_status.DedicatedLimitNInputs[i];
				//PEv2_status.DedicatedLimitPInputs[i];
				//PEv2_status.DedicatedHomeInputs[i];
		
				PEv2_SoftLimitStatus(i) = PEv2_status.SoftLimitStatus[i];
			}
			a_debout = 223;
			PEv2_ExternalRelayOutputs = PEv2_status.ExternalRelayOutputs;
			PEv2_ExternalOCOutputs = PEv2_status.ExternalOCOutputs;
			a_debout = 224;
		}
	}

	if ((PK_DigitalIOGet(dev) == PK_OK) && (PK_AnalogIOGet(dev) == PK_OK) && (PK_PinConfigurationGet(dev) == PK_OK)){  //gets IO data and checks return value 
		err=0;
		sPoKeysPinData iPin;
		a_debout = 230;

		/* 
		if ( PEv2_EmergencyOutputPin!=0 && PEv2_PulseEngineEnabled!=0)
		{	//check if pin is parametrized in HAL
			a_debout = 231;
			if (PEv2_EmergencyOutput==0)
			{
				//error: lvalue required as left operand of assignment
				Pins_DigitalValueSet(PEv2_EmergencyOutputPin-1)=0;
			}
			else
			{
				//error: lvalue required as left operand of assignment
				Pins_DigitalValueSet(PEv2_EmergencyOutputPin-1)=1;
			}
			
		}*/

		a_debout = 232;
		for(i=0;i<info_PinCount-1;i++)
		{
			a_debout = 2320+i;
			Pins_DigitalCounterValue(i)=dev->Pins[i].DigitalCounterValue;
			Pins_AnalogValue(i)=dev->Pins[i].AnalogValue;
			Pins_PinFunction(i)=dev->Pins[i].PinFunction;
			Pins_CounterOptions(i)=dev->Pins[i].CounterOptions;
			if (dev->Pins[i].DigitalValueGet==0)
			{
				Pins_DigitalValueGet(i)=false;
			}
			else
			{
				Pins_DigitalValueGet(i)=true;
			}
			


			if (Pins_DigitalValueSet(i)==1)
			{
				dev->Pins[i].DigitalValueSet=1;
			}
			else
			{
				dev->Pins[i].DigitalValueSet=0;
			}
			;
			Pins_DigitalCounterAvailable(i)=dev->Pins[i].DigitalCounterAvailable;
			Pins_MappingType(i)=dev->Pins[i].MappingType;
			Pins_KeyCodeMacroID(i)=dev->Pins[i].KeyCodeMacroID;
			Pins_KeyModifier(i)=dev->Pins[i].KeyModifier;
			Pins_downKeyCodeMacroID(i)=dev->Pins[i].downKeyCodeMacroID;
			Pins_downKeyModifier(i)=dev->Pins[i].downKeyModifier;
			Pins_upKeyCodeMacroID(i)=dev->Pins[i].upKeyCodeMacroID;
			Pins_upKeyModifier(i)=dev->Pins[i].upKeyModifier;
			dev->Pins[i].preventUpdate=Pins_preventUpdate(i);
			
			a_debout = 2330+i;
		}

		if (PEv2_PulseEngineEnabled!=0)
		{
			if (dev->PEv2.EmergencyInputPin>0)
			{
				a_debout = 234;
				PEv2_EmergencyInput=Pins_DigitalValueGet(dev->PEv2.EmergencyInputPin-1);
			}
			else
			{
				a_debout = 235;
				if ( PEv2_EmergencyOutputPin!=0)
				{
					PEv2_EmergencyInput=PEv2_EmergencyOutput;
				}
				else
				{
					PEv2_EmergencyInput=false;
				}
			}
		}





		a_debout = 236;
		PK_DigitalIOSet(dev);
		a_debout = 237;
	 }
     else
	 {             		  //on connection error
		a_debout = 245;
		PK_DisconnectDevice(dev);
		dev=NULL;  		  //tries to reconnect
		err=1;

	 }
	
	if (info_MatrixKeyboard!=0)
	{
		a_debout = 250;
		if (PK_MatrixKBStatusGet(dev) == PK_OK)
		{
			a_debout = 251;
			if (MatrixKB_matrixKBwidth>0 && MatrixKB_matrixKBheight>0)
			{
				for(i=0;i<128;i++)
				{
					a_debout = 2520+i;
					MatrixKB_matrixKBvalues(i) = dev->matrixKB.matrixKBvalues[i]; 
				}
			}
		}
	}

	if (info_EasySensors!=0 && info_PinCount!=0)
	{
		a_debout = 260;
		if ((PK_EasySensorsSetupGet(dev) == PK_OK) && (PK_EasySensorsValueGetAll(dev) == PK_OK))
		{
			a_debout = 261;
			for(i=0;i<10;i++)
			{
				a_debout = 2610+i;
				EasySensors_sensorValue(i)=dev->EasySensors[i].sensorValue;
				EasySensors_sensorType(i)=dev->EasySensors[i].sensorType;
				EasySensors_sensorRefreshPeriod(i)=dev->EasySensors[i].sensorRefreshPeriod;
				EasySensors_sensorFailsafeConfig(i)=dev->EasySensors[i].sensorFailsafeConfig;
				EasySensors_sensorReadingID(i)=dev->EasySensors[i].sensorReadingID;

			}		
		}

	}
	if (rtc_lastmin!=rtc_min)
	{
		a_debout = 310;
		rtc_lastmin=rtc_min;
		
		 info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
		 info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
		 info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
		 info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
		 info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
		 info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
		 info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
		 info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
		 info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
		 info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
		 info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
		 info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
		 info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
		 info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
		 info_Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
		 info_MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
		 info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
		 info_LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
		 info_MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
		 info_ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
		 info_PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
		 info_PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
		 info_AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
		 info_InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
		 info_protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
		 info_prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
		 info_AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
		 info_LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
		 info_CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
		 info_PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
		 info_SensorList = dev->info.iSensorList;                      // Device supports sensor lists
		 info_WebInterface = dev->info.iWebInterface;                    // Device supports web interface
		 info_FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
		 info_JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
		 info_PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
		 info_PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
		 info_EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors
		 a_debout = 311;

		 if ( info_PulseEnginev2!=0)
		 {
			a_debout = 320;
			 PEv2_nrOfAxes=dev->PEv2.info.nrOfAxes;
			 PEv2_maxPulseFrequency=dev->PEv2.info.maxPulseFrequency;
			 PEv2_bufferDepth=dev->PEv2.info.bufferDepth;
			 PEv2_slotTiming=dev->PEv2.info.slotTiming;
		 }

			if (info_MatrixKeyboard!=0)
			{
				a_debout = 330;
				if (PK_MatrixKBConfigurationGet(dev) == PK_OK)
				{

					MatrixKB_matrixKBconfiguration = dev->matrixKB.matrixKBconfiguration;
					MatrixKB_matrixKBwidth = dev->matrixKB.matrixKBwidth;
					MatrixKB_matrixKBheight = dev->matrixKB.matrixKBheight;
					for(i=0;i<MatrixKB_matrixKBwidth-1;i++)
					{
						a_debout = 3310+i;
						MatrixKB_matrixKBcolumnsPins(i) = dev->matrixKB.matrixKBcolumnsPins[i]; 
					}
					for(i=0;i<MatrixKB_matrixKBheight-1;i++)
					{
						a_debout = 3320+i;
						MatrixKB_matrixKBrowsPins(i) = dev->matrixKB.matrixKBrowsPins[i]; 
					}
				}

			}
	}
	alive=0;
	usleep(40000); 
        }
    }

    exit(0);
};





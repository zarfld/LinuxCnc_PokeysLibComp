component pokeys "PoKeys IO driver, by Mit Zot";

option userspace yes;

pin out bit in-# [55];
pin in bit out-# [55];
pin out unsigned ain-# [7];
pin out unsigned enum_usb_dev;
pin out unsigned enum_fusb_dev;
pin out unsigned enum_udp_dev;

pin out bit err;
pin out bit connected;
pin in unsigned devSerial;
pin out bit alive;

// PoKeys device information
pin out unsigned info_PinCount;                        // Number of pins, physically on the device
pin out unsigned info_PWMCount;                        // Number of pins that support PWM output
pin out unsigned info_BasicEncoderCount;               // Number of basic encoders
pin out unsigned info_EncodersCount;                   // Number of encoder slots available
pin out unsigned info_FastEncoders;                    // Number of fast encoders supported
pin out unsigned info_UltraFastEncoders;               // Number of available ultra fast encoders
pin out unsigned info_PWMinternalFrequency;             // Main PWM peripheral clock
pin out unsigned info_AnalogInputs;                    // Number of available analog inputs
pin out unsigned info_KeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
pin out unsigned info_TriggeredKeyMapping;             // Device supports triggered key mapping
pin out unsigned info_KeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
pin out unsigned info_DigitalCounters;                 // Device supports digital counters
pin out unsigned info_JoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
pin out unsigned info_JoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
pin out unsigned info_Macros;                          // Device supports customizable macro sequences
pin out unsigned info_MatrixKeyboard;                  // Device supports matrix keyboard
pin out unsigned info_MatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
pin out unsigned info_LCD;                             // Device supports alphanumeric LCD display
pin out unsigned info_MatrixLED;                       // Device supports matrix LED display
pin out unsigned info_ConnectionSignal;                // Device supports connection signal output
pin out unsigned info_PoExtBus;                        // Device supports PoExtBus digital outputs
pin out unsigned info_PoNET;                           // Device supports PoNET bus devices
pin out unsigned info_AnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
pin out unsigned info_InitOutputsStart;                // Device supports initializing outputs at startup
pin out unsigned info_protI2C;                         // Device supports I2C bus (master)
pin out unsigned info_prot1wire;                       // Device supports 1-wire bus (master)
pin out unsigned info_AdditionalOptions;               // Device supports additional options with activation keys
pin out unsigned info_LoadStatus;                      // Device supports reporting load status
pin out unsigned info_CustomDeviceName;                // Device supports specifying custom device names
pin out unsigned info_PoTLog27support;                 // Device supports PoTLog27 firmware
pin out unsigned info_SensorList;                      // Device supports sensor lists
pin out unsigned info_WebInterface;                    // Device supports web interface
pin out unsigned info_FailSafeSettings;                // Device supports fail-safe mode
pin out unsigned info_JoystickHATswitch;               // Device supports joystick HAT switch mapping
pin out unsigned info_PulseEngine;                     // Device supports Pulse engine
pin out unsigned info_PulseEnginev2;                   // Device supports Pulse engine v2
pin out unsigned info_EasySensors;                     // Device supports EasySensors

// Pulse engine v2 information
pin out unsigned PEv2_nrOfAxes;
pin out unsigned PEv2_maxPulseFrequency;
pin out unsigned PEv2_bufferDepth;
pin out unsigned PEv2_slotTiming;

// Pulse engine v2 structure...
pin out unsigned PEv2_AxesState-# [8];				// Axis states (bit-mapped) - see ePK_PEAxisState
pin out unsigned PEv2_AxesConfig-# [8];				// Axis configuration - see ePK_PEv2_AxisConfig
pin out unsigned PEv2_AxesSwitchConfig-# [8];		// Axis switch configuration - see ePK_PulseEngineV2_AxisSwitchOptions
pin out u32 PEv2_CurrentPosition-# [8];			// Current position
pin out u32 PEv2_PositionSetup-# [8];			// Position to be set as current position
pin out u32 PEv2_ReferencePositionSpeed-# [8];	// Reference position or speed (position or pulses/s)
pin out u32 PEv2_InvertAxisEnable-# [8];		// Invert axis enable signal
pin out u32 PEv2_SoftLimitMaximum-# [8];		// Soft limit maximum position
pin out u32 PEv2_SoftLimitMinimum-# [8];		// Soft limit minimum position
pin out unsigned PEv2_HomingSpeed-# [8];			// Homing speed per axis (in %)
pin out unsigned PEv2_HomingReturnSpeed-# [8];		// Homing return speed per axis (in % of the homing speed)
pin out u32 PEv2_HomeOffsets-# [8];				// Home position offset
pin out unsigned PEv2_HomingAlgorithm-# [8];		// Homing algorithm configuration
pin out unsigned PEv2_FilterLimitMSwitch-# [8];		// Digital filter for limit- switch
pin out unsigned PEv2_FilterLimitPSwitch-# [8];		// Digital filter for limit+ switch
pin out unsigned PEv2_FilterHomeSwitch-# [8];		// Digital filter for home switch
pin out u32 PEv2_ProbePosition-# [8];			// Position where probe detected change
pin out u32 PEv2_ProbeMaxPosition-# [8];		// Maximum position to travel to until stopping and returning error
pin out float PEv2_MaxSpeed-# [8];					// Maximum axis speed (in pulses per ms)
pin out float PEv2_MaxAcceleration-# [8];			// Maximum axis acceleration (in pulses/ms/ms)
pin out float PEv2_MaxDecceleration-# [8];			// Maximum axis deceleration (in pulses/ms/ms)
pin out u32 PEv2_MPGjogMultiplier-# [8];		// MPG jog multiplier value
pin out unsigned PEv2_MPGjogEncoder-# [8];			// MPG jog encoder ID

pin in unsigned PEv2_PinHomeSwitch-# [8];			// Home switch pin (0 for external dedicated input)
pin in unsigned PEv2_PinLimitMSwitch-# [8];			// Limit- switch pin (0 for external dedicated input)
pin in unsigned PEv2_PinLimitPSwitch-# [8];			// Limit+ switch pin (0 for external dedicated input)
pin in unsigned PEv2_AxisEnableOutputPins-# [8];		// Axis enabled output pin (0 for external dedicated output)

pin out unsigned PEv2_HomeSwitch-# [8];				// Home switch
pin out unsigned PEv2_LimitMSwitch-# [8];			// Limit- switch
pin out unsigned PEv2_LimitPSwitch-# [8];			// Limit+ switch
pin in unsigned PEv2_AxisEnableOutput-# [8];		// Axis enabled output

pin out unsigned PEv2_HomeBackOffDistance-# [8];		// Back-off distance after homing
pin out unsigned PEv2_MPGjogDivider-# [8];			// Divider for the MPG jogging (enhanced encoder resolution)
pin out unsigned PEv2_PulseEngineEnabled;			// Pulse engine enabled status, also number of enabled axes
pin out unsigned PEv2_PulseGeneratorType;			// Pulse engine generator type (0: external, 1: internal 3ch)
pin out unsigned PEv2_ChargePumpEnabled;				// Charge pump output enabled
pin out unsigned PEv2_EmergencySwitchPolarity;		// Emergency switch polarity (set to 1 to invert)
pin out unsigned PEv2_PulseEngineActivated;			// Pulse engine activation status
pin out unsigned PEv2_LimitStatusP;					// Limit+ status (bit-mapped)
pin out unsigned PEv2_LimitStatusN;					// Limit- status (bit-mapped)
pin out unsigned PEv2_HomeStatus;					// Home status (bit-mapped)
pin out unsigned PEv2_ErrorInputStatus;				// Stepper motor driver error inputs status (bit-mapped)
pin out unsigned PEv2_MiscInputStatus;				// Miscelenous digital inputs...
pin out unsigned PEv2_LimitOverride;					// Limit override status
pin out unsigned PEv2_LimitOverrideSetup;			// Limit override configuration
pin out unsigned PEv2_PulseEngineState;				// State of pulse engine - see ePoKeysPEState
pin out unsigned PEv2_AxisEnabledMask;				// Bit-mapped ouput enabled mask

pin in unsigned PEv2_EmergencyInputPin;
pin out unsigned PEv2_EmergencyInput;
pin in unsigned PEv2_EmergencyOutputPin;				//added in component only for estop-out to reset estop (if 0 EmergencyInput will be reused)
pin out unsigned PEv2_EmergencyOutput;

pin out unsigned PEv2_param1;
pin out unsigned PEv2_param2;
pin out unsigned PEv2_param3;
pin out unsigned PEv2_AxisEnabledStatesMask;		// Bit-mapped states, where axis enabled and charge pump signals are active
pin out unsigned PEv2_PulseEngineStateSetup;		// Pulse engine new state configuration
pin out unsigned PEv2_SoftLimitStatus;				// Bit-mapped soft-limit statuses per axes
pin out unsigned PEv2_ExternalRelayOutputs;			// External relay outputs
pin out unsigned PEv2_ExternalOCOutputs;			// External open-collector outputs
pin out unsigned PEv2_PulseEngineBufferSize;		// Buffer size information...
pin out unsigned PEv2_motionBufferEntriesAccepted;
pin out unsigned PEv2_newMotionBufferEntries;
pin out unsigned PEv2_HomingStartMaskSetup;			// Bit-mapped axes indexes to be homed
pin out unsigned PEv2_ProbeStartMaskSetup;			// Bit-mapped axis indexes for probing
pin out unsigned PEv2_ProbeInput;					// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
pin out unsigned PEv2_ProbeInputPolarity;			// Probe input polarity
pin out unsigned PEv2_ProbeStatus;					// Probe status (probe completion bit-mapped status)
//pin out unsigned PEv2_MotionBuffer[448];			// Motion buffer
pin out float PEv2_ProbeSpeed;						// Probe speed (ratio of the maximum speed)
pin out unsigned PEv2_BacklashWidth-# [8];			// half of real backlash width
pin out unsigned PEv2_BacklashRegister-# [8];		// current value of the backlash register
pin out unsigned PEv2_BacklashAcceleration-# [8];	// in pulses per ms^2
pin out unsigned PEv2_BacklashCompensationEnabled;

pin out unsigned rtc_sec;
pin out unsigned rtc_min;
pin out unsigned rtc_hour;
pin out unsigned rtc_dow;
pin out unsigned rtc_dom;
pin out unsigned rtc_tmp;
pin out unsigned rtc_doy;
pin out unsigned rtc_month;
pin out unsigned rtc_year;
pin out unsigned rtc_loopcount;
pin out unsigned pincap-# [55];
pin out unsigned rtc_lastmin;
pin out unsigned rtc_lastsec;
pin out unsigned rtc_loop_frequ;
license "GPL";

option extra_link_args "-lPoKeys";

;;

#include <unistd.h>   /* UNIX standard function definitions */
#include "PoKeysLib.h"

sPoKeysDevice * dev=0;

int i=0;

void user_mainloop(void) 
{ 



    while(0xb){
       FOR_ALL_INSTS() {
	   rtc_loopcount++;
	 while(dev == NULL)
	 {
			
		 if (devSerial!=0 )
		 {
				rtc_loopcount=11;
				dev = PK_ConnectToDeviceWSerial(devSerial, 5000);  //waits for usb device
				rtc_loopcount=12;
				if (dev == NULL)
				{
					rtc_loopcount=13;
					dev = PK_ConnectToDeviceWSerial_UDP(devSerial, 5000);  //waits for usb device
				}

		 }
		else
		{
			sPoKeysNetworkDeviceSummary * udp_devices;
			enum_usb_dev = PK_EnumerateUSBDevices();
			enum_fusb_dev = PK_EnumerateUSBDevices();
			//enum_udp_dev = PK_EnumerateNetworkDevices(udp_devices,180); // does not work - it hangs here

			//dev = PK_ConnectToDeviceWSerial_UDP(27295, 5000);
		}

		if(dev != NULL)
		{
			connected=1;

		
			 info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
			 info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
			 info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
			 info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
			 info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
			 info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
			 info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
			 info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
			 info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
			 info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
			 info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
			 info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
			 info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
			 info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
			 info_Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
			 info_MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
			 info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
			 info_LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
			 info_MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
			 info_ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
			 info_PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
			 info_PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
			 info_AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
			 info_InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
			 info_protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
			 info_prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
			 info_AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
			 info_LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
			 info_CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
			 info_PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
			 info_SensorList = dev->info.iSensorList;                      // Device supports sensor lists
			 info_WebInterface = dev->info.iWebInterface;                    // Device supports web interface
			 info_FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
			 info_JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
			 info_PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
			 info_PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
			 info_EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors

			 if (info_PulseEnginev2!=0)
			 {
				 PEv2_nrOfAxes=dev->PEv2.info.nrOfAxes;
				 PEv2_maxPulseFrequency=dev->PEv2.info.maxPulseFrequency;
				 PEv2_bufferDepth=dev->PEv2.info.bufferDepth;
				 PEv2_slotTiming=dev->PEv2.info.slotTiming;
			 }
		}
		else
		{
		connected=0;
		err=1;
		}
	 }
	 alive=1; 

	 // RTC
	if (PK_RTCGet(dev) == PK_OK)
	{

		rtc_sec=dev->RTC.SEC;
		rtc_min=dev->RTC.MIN;
		rtc_hour=dev->RTC.HOUR;
		rtc_dow=dev->RTC.DOW;
		rtc_dom=dev->RTC.DOM;
		rtc_tmp=dev->RTC.tmp;
		rtc_doy=dev->RTC.DOY;
		rtc_month=dev->RTC.MONTH;
		rtc_year=dev->RTC.YEAR;

		if (rtc_lastsec!=rtc_sec)
		{
			rtc_loop_frequ=rtc_loopcount;
			rtc_loopcount=0;
			rtc_lastsec=rtc_sec;
		}


	}

	// PulseEnginev2
	if (info_PulseEnginev2!=0)
	{
	 if ((PK_PEv2_StatusGet(dev) == PK_OK) && (PK_PEv2_Status2Get(dev) == PK_OK))
	 {

	 // Pulse engine v2 structure...
		PEv2_PulseEngineEnabled=dev->PEv2.PulseEngineEnabled;			// Pulse engine enabled status, also number of enabled axes
		PEv2_PulseGeneratorType=dev->PEv2.PulseGeneratorType;			// Pulse engine generator type (0: external, 1: internal 3ch)
		PEv2_ChargePumpEnabled=dev->PEv2.ChargePumpEnabled;			// Charge pump output enabled
		PEv2_EmergencySwitchPolarity=dev->PEv2.EmergencySwitchPolarity;		// Emergency switch polarity (set to 1 to invert)
		PEv2_PulseEngineActivated=dev->PEv2.PulseEngineActivated;			// Pulse engine activation status
		PEv2_LimitStatusP=dev->PEv2.LimitStatusP;					// Limit+ status (bit-mapped)
		PEv2_LimitStatusN=dev->PEv2.LimitStatusN;					// Limit- status (bit-mapped)
		PEv2_HomeStatus=dev->PEv2.HomeStatus;					// Home status (bit-mapped)
		PEv2_ErrorInputStatus=dev->PEv2.ErrorInputStatus;				// Stepper motor driver error inputs status (bit-mapped)
		PEv2_MiscInputStatus=dev->PEv2.MiscInputStatus;				// Miscelenous digital inputs...
		PEv2_LimitOverride=dev->PEv2.LimitOverride;				// Limit override status
		PEv2_LimitOverrideSetup=dev->PEv2.LimitOverrideSetup;			// Limit override configuration
		PEv2_PulseEngineState=dev->PEv2.PulseEngineState;				// State of pulse engine - see ePoKeysPEState
		PEv2_AxisEnabledMask=dev->PEv2.AxisEnabledMask;				// Bit-mapped ouput enabled mask
		if (PEv2_EmergencyInputPin!=0)
		{	//check if pin is parametrized in HAL
			dev->PEv2.EmergencyInputPin=PEv2_EmergencyInputPin;
		}
		if (dev->PEv2.EmergencyInputPin>0)
		{
			PEv2_EmergencyInput=dev->Pins[dev->PEv2.EmergencyInputPin-1].DigitalValueGet;
		}

		if (PEv2_EmergencyOutputPin!=0)
		{	//check if pin is parametrized in HAL
			dev->Pins[PEv2_EmergencyOutputPin].DigitalValueSet=PEv2_EmergencyOutput;
		}
		else
		{
			if (dev->PEv2.EmergencyInputPin>0)
			{
				if(dev->Pins[dev->PEv2.EmergencyInputPin-1].DigitalValueGet>0)
				{
					PEv2_EmergencyInput=1;
				}
				else
				{
					PEv2_EmergencyInput=PEv2_EmergencyOutput;
				}
			}
			else
			{
				PEv2_EmergencyInput=PEv2_EmergencyOutput;
			}
		}
		PEv2_param1=dev->PEv2.param1;
		PEv2_param2=dev->PEv2.param2;
		PEv2_param3=dev->PEv2.param3;
		PEv2_AxisEnabledStatesMask=dev->PEv2.AxisEnabledStatesMask;		// Bit-mapped states, where axis enabled and charge pump signals are active
		PEv2_PulseEngineStateSetup=dev->PEv2.PulseEngineStateSetup;		// Pulse engine new state configuration
		PEv2_SoftLimitStatus=dev->PEv2.SoftLimitStatus;				// Bit-mapped soft-limit statuses per axes
		PEv2_ExternalRelayOutputs=dev->PEv2.ExternalRelayOutputs;			// External relay outputs
		PEv2_ExternalOCOutputs=dev->PEv2.ExternalOCOutputs;			// External open-collector outputs
		PEv2_PulseEngineBufferSize=dev->PEv2.PulseEngineBufferSize;		// Buffer size information...
		//PEv2_motionBufferEntriesAccepted=dev->PEv2.motionBufferEntriesAccepted;
		PEv2_newMotionBufferEntries=dev->PEv2.newMotionBufferEntries;
		PEv2_HomingStartMaskSetup=dev->PEv2.HomingStartMaskSetup;			// Bit-mapped axes indexes to be homed
		PEv2_ProbeStartMaskSetup=dev->PEv2.ProbeStartMaskSetup;			// Bit-mapped axis indexes for probing
		PEv2_ProbeInput=dev->PEv2.ProbeInput;					// Probe input (0:disabled, 1-8:external inputs, 9+ Pin ID-9)
		PEv2_ProbeInputPolarity=dev->PEv2.ProbeInputPolarity;			// Probe input polarity
		PEv2_ProbeStatus=dev->PEv2.ProbeStatus;					// Probe status (probe completion bit-mapped status)
		//PEv2_MotionBuffer=dev->PEv2.MotionBuffer;			// Motion buffer
		PEv2_ProbeSpeed=dev->PEv2.ProbeSpeed;						// Probe speed (ratio of the maximum speed)
		PEv2_BacklashCompensationEnabled=dev->PEv2.BacklashCompensationEnabled;
	 }
	 if (PK_PEv2_AxisConfigurationGet(dev) == PK_OK)
	 {


			for(i=0;i<PEv2_nrOfAxes;i++)
			{ 
				PEv2_AxesState(i)=dev->PEv2.AxesState[i];				// Axis states (bit-mapped) - see ePK_PEAxisState
				PEv2_AxesConfig(i)=dev->PEv2.AxesConfig[i];				// Axis configuration - see ePK_PEv2_AxisConfig
				PEv2_AxesSwitchConfig(i)=dev->PEv2.AxesSwitchConfig[i];		// Axis switch configuration - see ePK_PEv2_AxisSwitchOptions
				PEv2_CurrentPosition(i)=dev->PEv2.CurrentPosition[i];			// Current position
				PEv2_PositionSetup(i)=dev->PEv2.PositionSetup[i];			// Position to be set as current position
				PEv2_ReferencePositionSpeed(i)=dev->PEv2.ReferencePositionSpeed[i];	// Reference position or speed (position or pulses/s)
				PEv2_InvertAxisEnable(i)=dev->PEv2.InvertAxisEnable[i];		// Invert axis enable signal
				PEv2_SoftLimitMaximum(i)=dev->PEv2.SoftLimitMaximum[i];		// Soft limit maximum position
				PEv2_SoftLimitMinimum(i)=dev->PEv2.SoftLimitMinimum[i];		// Soft limit minimum position
				PEv2_HomingSpeed(i)=dev->PEv2.HomingSpeed[i];			// Homing speed per axis (in %)
				PEv2_HomingReturnSpeed(i)=dev->PEv2.HomingReturnSpeed[i];		// Homing return speed per axis (in % of the homing speed)
				PEv2_HomeOffsets(i)=dev->PEv2.HomeOffsets[i];				// Home position offset
				PEv2_HomingAlgorithm(i)=dev->PEv2.HomingAlgorithm[i];		// Homing algorithm configuration
				PEv2_FilterLimitMSwitch(i)=dev->PEv2.FilterLimitMSwitch[i];		// Digital filter for limit- switch
				PEv2_FilterLimitPSwitch(i)=dev->PEv2.FilterLimitPSwitch[i];		// Digital filter for limit+ switch
				PEv2_FilterHomeSwitch(i)=dev->PEv2.FilterHomeSwitch[i];		// Digital filter for home switch
				PEv2_ProbePosition(i)=dev->PEv2.ProbePosition[i];			// Position where probe detected change
				PEv2_ProbeMaxPosition(i)=dev->PEv2.ProbeMaxPosition[i];		// Maximum position to travel to until stopping and returning error
				PEv2_MaxSpeed(i)=dev->PEv2.MaxSpeed[i];					// Maximum axis speed (in pulses per ms)
				PEv2_MaxAcceleration(i)=dev->PEv2.MaxAcceleration[i];			// Maximum axis acceleration (in pulses/ms/ms)
				PEv2_MaxDecceleration(i)=dev->PEv2.MaxDecceleration[i];			// Maximum axis deceleration (in pulses/ms/ms)
				PEv2_MPGjogMultiplier(i)=dev->PEv2.MPGjogMultiplier[i];		// MPG jog multiplier value
				PEv2_MPGjogEncoder(i)=dev->PEv2.MPGjogEncoder[i];			// MPG jog encoder ID
				
				// Home switch pin (0 for external dedicated input)
				if (PEv2_PinHomeSwitch(i)!=0)
				{	//check if pin is parametrized in HAL
					dev->PEv2.PinHomeSwitch[i]=PEv2_PinHomeSwitch(i);
				}
				if (dev->PEv2.PinHomeSwitch[i]>0)
				{
					PEv2_HomeSwitch(i)=dev->Pins[dev->PEv2.PinHomeSwitch[i]-1].DigitalValueGet;
				}
				else
				{
					PEv2_HomeSwitch(i)=0;
				}

				// Limit- switch pin (0 for external dedicated input)
				if (PEv2_PinLimitMSwitch(i)!=0)
				{	//check if pin is parametrized in HAL
					dev->PEv2.PinLimitMSwitch[i]=PEv2_PinLimitMSwitch(i);
				}
				if (dev->PEv2.PinLimitMSwitch[i]>0)
				{
					PEv2_LimitMSwitch(i)=dev->Pins[dev->PEv2.PinLimitMSwitch[i]-1].DigitalValueGet;
				}
				else
				{
					PEv2_LimitMSwitch(i)=0;
				}

				// Limit+ switch pin (0 for external dedicated input)
				if (PEv2_PinLimitPSwitch(i)!=0)
				{	//check if pin is parametrized in HAL
					dev->PEv2.PinLimitPSwitch[i]=PEv2_PinLimitPSwitch(i);
				}
				if (dev->PEv2.PinLimitPSwitch[i]>0)
				{
					PEv2_LimitPSwitch(i)=dev->Pins[dev->PEv2.PinLimitPSwitch[i]-1].DigitalValueGet;
				}
				else
				{
					PEv2_LimitPSwitch(i)=0;
				}

				//PEv2_AxisEnableOutputPins(i)=dev->PEv2.AxisEnableOutputPins[i];	// Axis enabled output pin (0 for external dedicated output)
				if (PEv2_AxisEnableOutputPins(i)!=0)
				{	//check if pin is parametrized in HAL
					dev->PEv2.AxisEnableOutputPins[i]=PEv2_AxisEnableOutputPins(i);
				}
				if (dev->PEv2.AxisEnableOutputPins[i]>0)
				{
					dev->Pins[dev->PEv2.PinLimitPSwitch[i]-1].DigitalValueSet=PEv2_AxisEnableOutput(i);
				}

				PEv2_HomeBackOffDistance(i)=dev->PEv2.HomeBackOffDistance[i];	// Back-off distance after homing
				PEv2_MPGjogDivider(i)=dev->PEv2.MPGjogDivider[i];			// Divider for the MPG jogging (enhanced encoder resolution)
				PEv2_BacklashWidth(i)=dev->PEv2.BacklashWidth[i];			// half of real backlash width
				PEv2_BacklashRegister(i)=dev->PEv2.BacklashRegister[i];		// current value of the backlash register
				PEv2_BacklashAcceleration(i)=dev->PEv2.BacklashAcceleration[i];	// in pulses per ms^2
			}
	 }
	}

		 if ((PK_DigitalIOGet(dev) == PK_OK) && (PK_AnalogIOGet(dev) == PK_OK) && (PK_PinConfigurationGet(dev) == PK_OK)){  //gets IO data and checks return value 
		err=0;
		sPoKeysPinData iPin;
		
		for(i=0;i<info_PinCount-1;i++)
		{
			pincap(i) = dev->Pins[i].PinFunction;
			switch(dev->Pins[i].PinFunction)
			{
				case PK_PinCap_digitalInput:
					in(i)=dev->Pins[i].DigitalValueGet;           //just transfers values
					break;
				case PK_PinCap_digitalOutput:
					dev->Pins[i].DigitalValueSet=out(i);
					break;
				case PK_PinCap_analogInput:
					ain(i-40)=dev->Pins[i].AnalogValue;
					break;
				default:
					in(i)=0;
					break;
			}
		}
		PK_DigitalIOSet(dev);
	 }
     else
	 {             		  //on connection error
		PK_DisconnectDevice(dev);
		dev=NULL;  		  //tries to reconnect
		err=1;
		for(i=0;i<54;i++)in(i)=0;
		for(i=0;i<3;i++)ain(i)=0;
	 }
	
	if (rtc_lastmin!=rtc_min)
	{

		rtc_lastmin=rtc_min;
		
		 info_PinCount = dev->info.iPinCount;                        // Number of pins, physically on the device
		 info_PWMCount = dev->info.iPWMCount;                        // Number of pins that support PWM output
		 info_BasicEncoderCount = dev->info.iBasicEncoderCount;               // Number of basic encoders
		 info_EncodersCount = dev->info.iEncodersCount;                   // Number of encoder slots available
		 info_FastEncoders = dev->info.iFastEncoders;                    // Number of fast encoders supported
		 info_UltraFastEncoders = dev->info.iUltraFastEncoders;               // Number of available ultra fast encoders
		 info_PWMinternalFrequency = dev->info.PWMinternalFrequency;             // Main PWM peripheral clock
		 info_AnalogInputs = dev->info.iAnalogInputs;                    // Number of available analog inputs
		 info_KeyMapping = dev->info.iKeyMapping;                      // Device supports key mapping (acts as a USB keyboard)
		 info_TriggeredKeyMapping = dev->info.iTriggeredKeyMapping;             // Device supports triggered key mapping
		 info_KeyRepeatDelay = dev->info.iKeyRepeatDelay;                  // Device supports user customizable key repeat rates and delays
		 info_DigitalCounters = dev->info.iDigitalCounters;                 // Device supports digital counters
		 info_JoystickButtonAxisMapping = dev->info.iJoystickButtonAxisMapping;       // Device supports mapping of joystick buttons
		 info_JoystickAnalogToDigitalMapping = dev->info.iJoystickAnalogToDigitalMapping;  // Device supports mapping of analog inputs to digital keys
		 info_Macros = dev->info.iMacros;                          // Device supports customizable macro sequences
		 info_MatrixKeyboard = dev->info.iMatrixKeyboard;                  // Device supports matrix keyboard
		 info_MatrixKeyboardTriggeredMapping = dev->info.iMatrixKeyboardTriggeredMapping;  // Device supports matrix keyboard triggered key mapping
		 info_LCD = dev->info.iLCD;                             // Device supports alphanumeric LCD display
		 info_MatrixLED = dev->info.iMatrixLED;                       // Device supports matrix LED display
		 info_ConnectionSignal = dev->info.iConnectionSignal;                // Device supports connection signal output
		 info_PoExtBus = dev->info.iPoExtBus;                        // Device supports PoExtBus digital outputs
		 info_PoNET = dev->info.iPoNET;                           // Device supports PoNET bus devices
		 info_AnalogFiltering = dev->info.iAnalogFiltering;                 // Device supports analog inputs low-pass digital filtering
		 info_InitOutputsStart = dev->info.iInitOutputsStart;                // Device supports initializing outputs at startup
		 info_protI2C = dev->info.iprotI2C;                         // Device supports I2C bus (master)
		 info_prot1wire = dev->info.iprot1wire;                       // Device supports 1-wire bus (master)
		 info_AdditionalOptions = dev->info.iAdditionalOptions;               // Device supports additional options with activation keys
		 info_LoadStatus = dev->info.iLoadStatus;                      // Device supports reporting load status
		 info_CustomDeviceName = dev->info.iCustomDeviceName;                // Device supports specifying custom device names
		 info_PoTLog27support = dev->info.iPoTLog27support;                 // Device supports PoTLog27 firmware
		 info_SensorList = dev->info.iSensorList;                      // Device supports sensor lists
		 info_WebInterface = dev->info.iWebInterface;                    // Device supports web interface
		 info_FailSafeSettings = dev->info.iFailSafeSettings;                // Device supports fail-safe mode
		 info_JoystickHATswitch = dev->info.iJoystickHATswitch;               // Device supports joystick HAT switch mapping
		 info_PulseEngine = dev->info.iPulseEngine;                     // Device supports Pulse engine
		 info_PulseEnginev2 = dev->info.iPulseEnginev2;                   // Device supports Pulse engine v2
		 info_EasySensors = dev->info.iEasySensors;                     // Device supports EasySensors


		 if (info_PulseEnginev2!=0)
		 {
			 PEv2_nrOfAxes=dev->PEv2.info.nrOfAxes;
			 PEv2_maxPulseFrequency=dev->PEv2.info.maxPulseFrequency;
			 PEv2_bufferDepth=dev->PEv2.info.bufferDepth;
			 PEv2_slotTiming=dev->PEv2.info.slotTiming;
		 }
	}
	alive=0;
	usleep(40000); 
        }
    }

    exit(0);
};



